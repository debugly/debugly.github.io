{"meta":{"title":"Matt Reach","subtitle":"An iOS Developer","description":null,"author":"许乾隆","url":"http://debugly.cn"},"pages":[{"title":"About","date":"2018-03-27T14:45:15.706Z","updated":"2018-03-27T14:45:15.706Z","comments":true,"path":"about/index.html","permalink":"http://debugly.cn/about/index.html","excerpt":"","text":"我喜欢一个人的早晨，只有我，还有音乐。 Personal Profile17 年上半年主要做了几款小游戏，还有OpenSDK，更新千帆直播SDK。下半年正式开始带团队，为了提升团队战斗力，拉高组内技术水平，开始组织代码评审，技术调研，写issue。12月开始全部人马切到cocos2d-游戏开发中！ 16 年 5 月 中旬我加入了现在的团队（同属于视频），不再开发 App，主要从事 千帆直播 SDK 的开发工作，我度过了那段孤军奋战的 SDK 开发岁月，经过一年的沉淀队伍壮到了 5 人，我虽然不再孤单，但却更加忙碌，因为我一个人的时候只开发 千帆直播 SDK ，提供给视频和新闻！而现在我们团队需要负责 开心夺宝 SDK 、搜狐课堂 SDK 、千帆小游戏 SDK(目前是3款游戏)、开放平台播放器 SDK 等 SDK 的迭代开发，由于这些 SDK 的渠道不同，因此通常都是并行开发！ 15 年在太有乾（创业公司）做了半年的 P2P，辞职后加入搜狐视频。在搜狐视频团队主要负责下载上传模块，写的UI相对少一些，主要是完善逻辑，挖掘出了下载过程中遇到的各种错误，进而采取了相应的方案，还针对网络变化制定出了不同超时时长，离开团队之前下载成功率维持在 95% 以上。16 年 4 月中旬我要离开的事情已经确定了，但还是主动争取到了上传模块的封装设计，一方面由于这块本身就要给我做（在决定走之前），另一方面其实我也是有私心的，为的是充分消化前辈封装的下载模块架构，上传完成后，做了一次技术分享，然后离开了这个很棒的团队。 14 年就职于搜房网，做了几个月的租房帮 App，后来业务线合并了，去做搜房家居、装修频道。 13 年开始做 iOS 开发，Objective-C 是目前最熟悉的编程语言，了解 Java，Shell，JS，H5，Ruby；想学习下 Swift，Python … APP &amp; SDK从 16 年 5 月以来，我就开始从事 SDK 的开发工作，我觉得做 SDK 跟 App 是有很大差别的，因为 SDK 需要考虑很多合理性，既要满足 App 调用方便又要保证其通用性，优雅性，内外兼修，有的放矢，做 App 也许就不会考虑这么多的方面了，我和同事交流最多的就是问 ： “xxx，这样做你觉得合理吗？App 调用方便吗？是否通用，日后是否可以扩展？” 我抽时间写了一些做 SDK 过程中解决的问题，代码设计思路相关的文章，单独拎了一个 千帆SDK 的类别。 Productive Forces业余时间我写了一个简单的自动化远程打包服务器，实现了完全脚本话打包，打完后自动部署到 Apache 服务器；需要发包时，只需提交下代码，改下 build 号，等上 2 分钟就打好了，然后复制下载地址使用邮件发送即可；这比起人工打包，然后合并 framework，节省了不少宝贵的时间，其技术要点我也会一一写出来，供大家参考。 Products很期待你能去体验下我们公司的产品和我们 SDK 提供的服务： SDKs 集成渠道 千帆直播 SDK 搜狐视频、搜狐新闻、搜狐汽车，狗仔直播 搜狐课堂 SDK 搜狐视频 Game SDK (答题PK、水果转盘、题王争霸、成语接龙) 千帆直播 小视频 SDK 千帆直播 播放器 SDK 360影视大全，搜狗搜索，百度视频 Contact如有技术沟通，产品建议请微信联系我： 发邮件给我 : qianlongxu@gmail.com ."},{"title":"Project","date":"2018-03-27T14:45:16.015Z","updated":"2018-03-27T14:45:16.015Z","comments":true,"path":"project/index.html","permalink":"http://debugly.cn/project/index.html","excerpt":"","text":"发的是极乐空间"},{"title":"Tags","date":"2018-03-27T14:45:16.015Z","updated":"2018-03-27T14:45:16.015Z","comments":true,"path":"tags/index.html","permalink":"http://debugly.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Github Pages 自定义域名支持 HTTPS","slug":"2018/03/22-github-customdomain-support-https","date":"2018-03-22T13:56:06.000Z","updated":"2018-03-27T14:45:15.706Z","comments":true,"path":"2018/03/22/2018/03/22-github-customdomain-support-https.html","link":"","permalink":"http://debugly.cn/2018/03/22/2018/03/22-github-customdomain-support-https.html","excerpt":"","text":"自从有了自己的域名后，我的博客就失去了那把小绿锁，就在刚刚我还在搜索：Github 自定义域名怎么支持https，当我看到这个 帖子 之后，事情就有了翻转，没想到 Github 支持了，皆大欢喜了！也不用去折腾 Cloudflare 了…. 看了下，使用的是 Let’s Encrypt 提供的免费证书，有效期是3个月，到期后可以续，等于永久免费！ 看了下证书是 2018年3月10日 创建的，莫非是 Github 默默为所有用户都申请好了？ 开启方式： 之前在没有自定义域名的时候才能开启这个 https 选项！","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://debugly.cn/tags/Other/"}]},{"title":"macOS Install Jenkins","slug":"2018/03/07-macOS-Install-Jenkins","date":"2018-03-06T16:05:31.000Z","updated":"2018-03-27T14:45:15.705Z","comments":true,"path":"2018/03/07/2018/03/07-macOS-Install-Jenkins.html","link":"","permalink":"http://debugly.cn/2018/03/07/2018/03/07-macOS-Install-Jenkins.html","excerpt":"","text":"官网https://jenkins.io/download/ 下载 Jenkins官网的 download 不好使，点击后没能开始下，估计是被墙了，所以找了个镜像: http://mirrors.jenkins-ci.org/osx/ 也由 war 包的镜像: http://updates.jenkins-ci.org/download/war/ 启动 Jenkins 服务1java -jar /Applications/Jenkins/jenkins.war 需要 Java 环境，环境有问题的话，可以参考我的这篇文章 使用默认端口是 8080，所以直接浏览器里输入 localhost:8080 进行一次 admin 账户初始化就OK了！ 内置变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950The following variables are available to shell scriptsBRANCH_NAMEFor a multibranch project, this will be set to the name of the branch being built, for example in case you wish to deploy to production from master but not from feature branches; if corresponding to some kind of change request, the name is generally arbitrary (refer to CHANGE_ID and CHANGE_TARGET).CHANGE_IDFor a multibranch project corresponding to some kind of change request, this will be set to the change ID, such as a pull request number, if supported; else unset.CHANGE_URLFor a multibranch project corresponding to some kind of change request, this will be set to the change URL, if supported; else unset.CHANGE_TITLEFor a multibranch project corresponding to some kind of change request, this will be set to the title of the change, if supported; else unset.CHANGE_AUTHORFor a multibranch project corresponding to some kind of change request, this will be set to the username of the author of the proposed change, if supported; else unset.CHANGE_AUTHOR_DISPLAY_NAMEFor a multibranch project corresponding to some kind of change request, this will be set to the human name of the author, if supported; else unset.CHANGE_AUTHOR_EMAILFor a multibranch project corresponding to some kind of change request, this will be set to the email address of the author, if supported; else unset.CHANGE_TARGETFor a multibranch project corresponding to some kind of change request, this will be set to the target or base branch to which the change could be merged, if supported; else unset.BUILD_NUMBERThe current build number, such as &quot;153&quot;BUILD_IDThe current build ID, identical to BUILD_NUMBER for builds created in 1.597+, but a YYYY-MM-DD_hh-mm-ss timestamp for older buildsBUILD_DISPLAY_NAMEThe display name of the current build, which is something like &quot;#153&quot; by default.JOB_NAMEName of the project of this build, such as &quot;foo&quot; or &quot;foo/bar&quot;.JOB_BASE_NAMEShort Name of the project of this build stripping off folder paths, such as &quot;foo&quot; for &quot;bar/foo&quot;.BUILD_TAGString of &quot;jenkins-$&#123;JOB_NAME&#125;-$&#123;BUILD_NUMBER&#125;&quot;. All forward slashes (/) in the JOB_NAME are replaced with dashes (-). Convenient to put into a resource file, a jar file, etc for easier identification.EXECUTOR_NUMBERThe unique number that identifies the current executor (among executors of the same machine) that’s carrying out this build. This is the number you see in the &quot;build executor status&quot;, except that the number starts from 0, not 1.NODE_NAMEName of the agent if the build is on an agent, or &quot;master&quot; if run on masterNODE_LABELSWhitespace-separated list of labels that the node is assigned.WORKSPACEThe absolute path of the directory assigned to the build as a workspace.JENKINS_HOMEThe absolute path of the directory assigned on the master node for Jenkins to store data.JENKINS_URLFull URL of Jenkins, like http://server:port/jenkins/ (note: only available if Jenkins URL set in system configuration)BUILD_URLFull URL of this build, like http://server:port/jenkins/job/foo/15/ (Jenkins URL must be set)JOB_URLFull URL of this job, like http://server:port/jenkins/job/foo/ (Jenkins URL must be set)SVN_REVISIONSubversion revision number that&apos;s currently checked out to the workspace, such as &quot;12345&quot;SVN_URLSubversion URL that&apos;s currently checked out to the workspace. 中文对照：https://www.cnblogs.com/EasonJim/p/6758382.html 邮件配置 https://blog.csdn.net/fullbug/article/details/53024562 https://blog.csdn.net/u013066244/article/details/78665075 https://blog.csdn.net/chengtong_java/article/details/49815311 https://stackoverflow.com/questions/13650860/jenkins-extended-e-mail-wont-print-git-branch-or-git-commit","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"macOS-JavaRuntime","slug":"2018/03/06-macOS-JavaRuntime","date":"2018-03-06T15:28:58.000Z","updated":"2018-03-27T14:45:15.705Z","comments":true,"path":"2018/03/06/2018/03/06-macOS-JavaRuntime.html","link":"","permalink":"http://debugly.cn/2018/03/06/2018/03/06-macOS-JavaRuntime.html","excerpt":"","text":"Macos 配置 JRE. 我也记不清楚之前本机的 Java 环境是否是配置好了，昨天更新了 Macos 之后，今天想装个 Jenkins 完下，结果在运行 Jenkins 的时候发现 No Java runtime present, requesting install. 分析问题点击 系统偏好设置里的 Java 图标 如果没有这个图标或者点击后没有出来 Java 控制面板 那就需要去 oracle 下载安装 JRE http://www.oracle.com/technetwork/java/javase/downloads/jre9-downloads-3848532.html；下载 dmg 包就行，需要选中 Accept License Agreement ! 下载完成，双击一路安装即可！ 本以为这样就行了，其实不行！ 原因如下： 经查找在 /usr/bin 目录里有个 java 的替身: 经过验证发现该路径已经加入到了PATH里面！ 12bogon:~ xuqianlong$ echo $PATH/Users/xuqianlong/.rvm/gems/ruby-2.2.6/bin:/Users/xuqianlong/.rvm/gems/ruby-2.2.6@global/bin:/Users/xuqianlong/.rvm/rubies/ruby-2.2.6/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/xuqianlong/.rvm/bin:/usr/local/ssl 为什么不行，还不能确定，可以确定的是他的原身是在 JavaVM.framework: 这个 JavaVM.framework 不是我们安装的，好像是苹果自带的，我们刚才装的那个 JRE 其实是在这里: 我们可以将这个替身改为我们这个JRE里的java，可是很遗憾，对于 /usr/bin 目录没有修改权限，想拥有权限有些麻烦，这里不在介绍。 命令行输入的命令查找顺序是按照设置PATH里设置的路径查找的，因此可以从 PATH 入手，仔细查看发现 /usr/local/bin 在 /usr/bin 之前搜索，所以我们在 /usr/local/bin 里建个 Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java 的替身就行了！ 解决问题1ln -s /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java /usr/local/bin 重启终端再次查看环境： 1234java -versionjava version &quot;9.0.4&quot;Java(TM) SE Runtime Environment (build 9.0.4+11)Java HotSpot(TM) 64-Bit Server VM (build 9.0.4+11, mixed mode) OK 啦！ 参考博客 https://anas.pk/2015/09/02/solution-no-java-runtime-present-mac-yosemite/","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"调试我乐棋牌通用链接","slug":"2018/01/07-testUniversalLink","date":"2018-01-07T03:07:51.000Z","updated":"2018-03-27T14:45:15.704Z","comments":true,"path":"2018/01/07/2018/01/07-testUniversalLink.html","link":"","permalink":"http://debugly.cn/2018/01/07/2018/01/07-testUniversalLink.html","excerpt":"","text":"仅用于技术测试，严禁用于其他用途！ 0、 金币场 URL Scheme 1、斗地主 Universal Link 1、拉起斗地主-without-action 2、拉起斗地主-with-action URL Scheme 3、拉起斗地主 Share URL 4、分享地址 2、四川麻将 Universal Link 1、 拉起麻将-without-action 2、 拉起麻将-with-action Share URL 3、 打开麻将分享地址 3、Apple-app-site-association .well-known/apple-app-site-association apple-app-site-association zhihu apple-app-site-association 4、Guides Apple Guides Universal Link 前端部署采坑记 Universal Links通用链接应用跳转总结以及坑","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://debugly.cn/tags/test/"}]},{"title":"我的 2017","slug":"2017/12/31-my-2017","date":"2017-12-31T15:30:03.000Z","updated":"2018-03-27T14:45:15.704Z","comments":true,"path":"2017/12/31/2017/12/31-my-2017.html","link":"","permalink":"http://debugly.cn/2017/12/31/2017/12/31-my-2017.html","excerpt":"","text":"Bye，My 2017 ! 今天是 2017 年最后一天，上午约了朋友去外滩吃火锅，饭后去了新开业的滨海万达广场，建设的还挺不错的，四楼有很多美食，以后倒是可以经常去约个饭，看个电影啥的… 回首 2017，着实经历了不少事情，可真到写的时候不知道写什么了，还是按照时间顺序说几个大事吧： 2月，大组来了三个应届生，其中两个是我组的，有一个后来也转到我组了，这样以来我组规模更大了，有人了就得干些事出来才行！ 4月，去了趟广州，主要是为接下来的千帆小游戏布局，紧接着我们做了好几款小游戏，其中包括：快捷答题，水果转盘，成语接龙，答题 PK 等，SDK 的开发工作基本也到了鼎盛时期，因为此时 SDK 的数量最多，为此我还专门搞了打包服务器，远程打包发布，集成方从服务器下载更新。 在广州出差时，领导突然找到我说要给我升下 level，当时是 2.2，升过之后是 3.1（在搜狐是个高级职称），即高级开发工程师，我是一个技术狂，能够拿到高级也是我一直苦苦追求的！ 6月，领导决定将组内的汇报工作全部转移给我（之前都是统一汇报给领导，我是个有实无名的 leader），就这样我开始学习管理经验，但也没有因此抛弃写代码，因为我很喜欢 coding ！ 7月，拿到了天津的集体户口，来这的目的总算是达到了，就差买房落户了。 10 月，开始使用游戏引擎编写游戏，前面说到的几个小游戏都是使用 iOS Native UI 写的，没啥技术含量😓，这次我们选择了 Apple 的 SpriteKit 2d 引擎开始写斗地主，从开始码人到出来用了两个多月的时间，与此同时进行的还有使用 cocos2d-x 的安卓端，由于 iOS 使用的是原生平台游戏引擎，自然少了很多坑，没有内存，性能等一系列问题；安卓端则遇到了很多问题，所以他们进度稍慢些，所以 iOS 版最先开始公测的。 12 月，不寻常的一个月份了，某个早晨，我要找领导汇报点工作，结果他说他先给我讲点事情，被告知公司成立了一个创新平台事业部，部门组织架构要调整下，变化还挺大的，我们组要换领导了（😢），工作上变大也挺大的，要告别 SDKs 开发了，从此以后要专注于游戏开发，大早上听到这个消息我蛮震惊的，我工作上不喜欢换领导，前两次跳槽也都跟换领导有很大的关系。紧接着就是一面交接 SDKs，一面学习游戏开发，随着千帆 SDK3.1 封板，我彻底告别了做了 20 个月的最求卓越的 SDK 开发工作，十分不舍得，但是又没有办法，不舍是因为如果没有千帆 SDK 就没有我来天津这件事，也没有现在我带起来的这帮人，不得不承认在做 SDK 开发的这段时间摸索到了很多 SDK 开发的经验，期间做了很多的尝试与创新！封装了一批自己的库ಥ_ಥ，真真切切的写了好多代码，思考了很多，进步颇多，感谢团队，感恩我的领导！ 除了这些之外，我们组织了好多次代码评审，十多次技术分享，十几篇 issue，人人都有参与其中，大家都从中受益了。 2018 计划拥抱变化，努力做好主管工作，带领团队走向光明，为游戏事业奋斗到底！ 说点高兴的话题吧，那就是 2018 年，我要当爸爸了，敲锣打鼓迎接我的 “狗宝” !","categories":[],"tags":[{"name":"个人总结","slug":"个人总结","permalink":"http://debugly.cn/tags/个人总结/"}]},{"title":"使用 CAGradientLayer 实现渐变遮罩","slug":"2017/10/20-CAGradientLayer","date":"2017-10-20T01:40:21.000Z","updated":"2018-03-27T14:45:15.704Z","comments":true,"path":"2017/10/20/2017/10/20-CAGradientLayer.html","link":"","permalink":"http://debugly.cn/2017/10/20/2017/10/20-CAGradientLayer.html","excerpt":"","text":"在做歌词显示的时候需要实现文字渐变消失的效果，向同事请教后知道了一个实现方法：使用 CAGradientLayer 来做，但是对CAGradientLayer 的属性设置不是很明确，所以进行了总结，现将代码贴出来并做解释说明，方便大家使用： 实现效果 1、实现代码12345678910111213- (void)addLayerToView:(UIView *)view width:(CGFloat)width &#123; CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.frame = CGRectMake(0, 0, width, view.bounds.size.height);; gradientLayer.colors = @[(__bridge id)[UIColor clearColor].CGColor,(__bridge id)[UIColor blackColor].CGColor,(__bridge id)[UIColor blackColor].CGColor,(__bridge id)[UIColor clearColor].CGColor]; gradientLayer.locations = @[@(0),@(0.1),@(0.9),@(1)]; gradientLayer.startPoint = CGPointMake(0, 0); gradientLayer.endPoint = CGPointMake(0, 1); CGRect frame = view.bounds; UIView *gradientView = [[UIView alloc] initWithFrame:frame]; [gradientView.layer addSublayer:gradientLayer]; view.maskView = gradientView;&#125; 2、CAGradientLayer属性设置上面代码主要涉及CAGradientLayer的四个属性colors locations startPoint endPoint，colors是颜色分配，locations是颜色分割线，startPoint为起始点，endPoint为终止点。 从上图可以看出，locations里面的值代表颜色的分界线，如果想要实现view的上下端都有渐变消失的效果，需要四个颜色和四个颜色分割线，也就是从0到0.1是clearColor -&gt; blackColor，从0.1-0.9不变色所以是blackColor-&gt; blackColor，从0.9-1是blackColor -&gt; clearColor。。。这样就实现了只有显示文字的view的最上端和最下端出现渐变效果，如上图所示。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"实现随音乐播放滚动歌词的音乐提词器","slug":"2017/10/12-lrc","date":"2017-10-12T01:49:58.000Z","updated":"2018-03-27T14:45:15.704Z","comments":true,"path":"2017/10/12/2017/10/12-lrc.html","link":"","permalink":"http://debugly.cn/2017/10/12/2017/10/12-lrc.html","excerpt":"","text":"由于开发需要实现一个随音乐播放滚动歌词的音乐提词器，通过网上查找资料，实现了效果，将代码贴出来，方便大家使用，主要步骤如下： 1、歌词解析TEMusicLrcParser.h 123456789101112#import &lt;Foundation/Foundation.h&gt;@interface LrcParser : NSObject//时间@property (nonatomic,strong) NSMutableArray *timerArray;//歌词@property (nonatomic,strong) NSMutableArray *wordArray;//解析歌词-(void) parseLrc:(NSString*)lrc;@end TEMusicLrcParser.m 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;TEMusicLrcParser.h&quot;@interface LrcParser ()-(void) parseLrc:(NSString *)word;@end@implementation LrcParser-(instancetype) init&#123; self=[super init]; if(self!=nil)&#123; self.timerArray=[[NSMutableArray alloc] init]; self.wordArray=[[NSMutableArray alloc] init]; &#125; return self;&#125;-(void)parseLrc:(NSString *)lrc&#123; NSLog(@&quot;%@&quot;,lrc); if(![lrc isEqual:nil])&#123; NSArray *sepArray=[lrc componentsSeparatedByString:@&quot;[&quot;]; NSArray *lineArray=[[NSArray alloc] init]; [self.wordArray removeAllObjects]; [self.timerArray removeAllObjects]; for(int i=0;i&lt;sepArray.count;i++)&#123; if([sepArray[i] length]&gt;0)&#123; lineArray=[sepArray[i] componentsSeparatedByString:@&quot;]&quot;]; if(![lineArray[0] isEqualToString:@&quot;\\n&quot;])&#123; [self.timerArray addObject:lineArray[0]]; [self.wordArray addObject:lineArray.count&gt;1?lineArray[1]:@&quot;&quot;]; &#125; &#125; &#125; &#125;&#125;@end 歌词解析部分主要是将歌词格式的字符串切分开，wordArray里面是歌词，timerArray里面是每句时间点 2、实现歌词的滚动使用tableview来显示歌词 TEMusicLrcView.h 12345678910111213141516171819#import &lt;UIKit/UIKit.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;#import \"TEMusicLrcParser.h\"@protocol TEMusicLrcViewDelegate &lt;NSObject&gt;@optional-(void) updateTime;//根据音乐播放器的时间更新时间，代理中实现@end@interface TEMusicLrcView : UITableView &lt;UITableViewDataSource,UITableViewDelegate&gt;@property (strong,nonatomic) LrcParser* lrcContent;@property (assign) NSInteger currentRow;@property (nonatomic, weak) id&lt;TEMusicLrcViewDelegate&gt; musicLrcViewDelegate;@property (nonatomic,strong) AVAudioPlayer *player;@property (nonatomic,strong) NSString *musicTotalLrc;//整首歌的歌词解析前的字符串-(instancetype)initWithFrame:(CGRect)frame musicTotalLrc:(NSString *)musicTotalLrc;@end TEMusicLrcView.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#import &quot;TEMusicLrcView.h&quot;#import &quot;TECaptureViewController.h&quot;@interface TEMusicLrcView ()@property (nonatomic,strong) NSTimer *timer;@end@implementation TEMusicLrcView-(instancetype)initWithFrame:(CGRect)frame musicTotalLrc:(NSString *)musicTotalLrc&#123; self = [super initWithFrame:frame]; if(self) &#123; self.delegate=self; self.dataSource=self; self.lrcContent=[[LrcParser alloc] init]; self.separatorStyle = UITableViewCellSeparatorStyleNone; self.allowsSelection = NO; [self.lrcContent parseLrc:musicTotalLrc]; [self reloadData]; [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(update) userInfo:nil repeats:YES]; UIImageView *bgView=[[UIImageView alloc] init]; bgView.backgroundColor = [UIColor clearColor]; //bgView.alpha=0.8; self.backgroundView=bgView; &#125; return self;&#125;-(void)update&#123; [self.musicLrcViewDelegate updateTime];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.lrcContent.wordArray.count;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; if(indexPath.row==_currentRow)&#123; return 60.0/kVisualFactor; &#125; else&#123; return 54.0/kVisualFactor; &#125;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; [tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;TEMusicLrcCell&quot;]; UITableViewCell *cell=[self dequeueReusableCellWithIdentifier:@&quot;TEMusicLrcCell&quot; forIndexPath:indexPath]; cell.textLabel.text=self.lrcContent.wordArray[indexPath.row]; if(indexPath.row==_currentRow)&#123; cell.textLabel.textColor = [UIColor colorFromHex:@&quot;ffda44&quot;]; cell.textLabel.font = [UIFont systemFontOfSize:34.0/kVisualFactor]; cell.textLabel.layer.shadowColor = [UIColor clearColor].CGColor; cell.textLabel.layer.shadowOffset = CGSizeMake(0.0f, 0.0f); &#125; else&#123; cell.textLabel.textColor = [UIColor colorWithWhite:1 alpha:0.7]; cell.textLabel.font = [UIFont systemFontOfSize:28.0/kVisualFactor]; cell.textLabel.layer.shadowOpacity = 1.0; cell.textLabel.layer.shadowColor = [UIColor colorWithWhite:0 alpha:0.4].CGColor; cell.textLabel.layer.shadowOffset = CGSizeMake(0.0f, 1.0f); cell.textLabel.layer.shadowRadius = 2; &#125; cell.textLabel.textAlignment = NSTextAlignmentCenter; cell.backgroundColor=[UIColor clearColor]; return cell;&#125;@end 其中更新提词器的时间的实现方法是 1234567891011121314151617#pragma mark - 更新提词器时间-(void) updateTime&#123; CGFloat currentTime=self.musicPlayer.currentlocation;// NSLog(@&quot;%d:%d&quot;,(int)currentTime / 60, (int)currentTime % 60); for (int i=0; i&lt;self.musicLrcView.lrcContent.timerArray.count; i++) &#123; NSArray *timeArray=[self.musicLrcView.lrcContent.timerArray[i] componentsSeparatedByString:@&quot;:&quot;]; float lrcTime=[timeArray[0] intValue]*60+[timeArray[1] floatValue]; if(currentTime&gt;lrcTime)&#123;//过了这句歌词的起始时间后，刷新当前歌词 self.musicLrcView.currentRow=i; &#125;else break; &#125; [self.musicLrcView reloadData]; [self.musicLrcView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.musicLrcView.currentRow inSection:0] atScrollPosition:UITableViewScrollPositionMiddle animated:YES];&#125; currentTime为当前播放器的时间，lrcTime为当前歌词的开始时间，过了这句歌词的起始时间后，刷新当前歌词","categories":[],"tags":[{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"React Native和iOS原生方法交互","slug":"2017/09/21-reactnative native invoke","date":"2017-09-21T15:24:54.000Z","updated":"2018-03-27T14:45:15.703Z","comments":true,"path":"2017/09/21/2017/09/21-reactnative native invoke.html","link":"","permalink":"http://debugly.cn/2017/09/21/2017/09/21-reactnative native invoke.html","excerpt":"","text":"原生传递参数给React Native初始化时传值1234- (instancetype)initWithBundleURL:(NSURL *)bundleURL moduleName:(NSString *)moduleName initialProperties:(NSDictionary *)initialProperties launchOptions:(NSDictionary *)launchOptions; 通过初始化方法中的 initialProperties 可以给 RCTRootView 传值 appProperties传值同上面的方法类似，只是不是在初始化时传值，在设置 appProperties 之后，React Native应用将会根据新的属性重新渲染。当然，只有在新属性和之前的属性有区别时更新才会被触发。 123456789/** * The properties to apply to the view. Use this property to update * application properties and rerender the view. Initialized with * initialProperties argument of the initializer. * * Set this property only on the main thread. */ @property (nonatomic, copy, readwrite) NSDictionary *appProperties; 传递的参数为OC的字典类型，在js中可以通过属性值.props访问字典的key，就可以取到参数值 React Native执行原生方法调用Native方法Native端： 首先需要调用的原生方法需要实现 RCTBridgeModule 协议 类实现中需要添加 RCT_EXPORT_MODULE() 的宏 通过 RCT_EXPORT_METHOD()宏 来实现需要导出 javascript 的方法 12345678910@implementation YFTestObjectRCT_EXPORT_MODULE();RCT_EXPORT_METHOD(doSomethingCallback:(NSString *)string callback:(RCTResponseSenderBlock)callback)&#123; NSLog(@&quot;%@&quot;,string); callback(@[[NSNull null] ,@[@&quot;test1&quot;, @&quot;test2&quot;]]); // 第一个error，第二个回调参数&#125;@end JS端： 需要引用 NativeModules 模块 通过 NativeModules.xxx 获取 Native 的类，xxx为Native的类名 上一步获取到的 Native 类，调用 Native 中导出的方法 123456789101112131415render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableHighlight onPress=&#123;()=&gt;testObject.doSomethingCallback(&apos;点击按钮（回调）&apos;, (error,events)=&gt;&#123; if (error) &#123; console.error(error); &#125; else &#123; console.log(events); &#125; &#125;)&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt;点击（回调）&lt;/Text&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125; 如果需要Natvie方法回调，需要将导出的方法增加RCTResponseSenderBlock类型的参数，该参数则为方法的回调方法","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"UIButton选中状态下点击触发高亮的问题","slug":"2017/09/20-UIButton-highlight","date":"2017-09-20T10:27:03.000Z","updated":"2018-03-27T14:45:15.703Z","comments":true,"path":"2017/09/20/2017/09/20-UIButton-highlight.html","link":"","permalink":"http://debugly.cn/2017/09/20/2017/09/20-UIButton-highlight.html","excerpt":"","text":"在写发射彩蛋红包页面时，需要实现这样一个功能，即有两只蛋，一只彩蛋，一只金蛋，点击其中一个会变大，另外一个会变小，具体效果如下图所示： 具体的实现思路是设置两只蛋的Normal状态和Selected状态下的图片，一开始将彩蛋设为选中态，将金蛋设为正常态，然后在各自的点击事件中将两个按钮的状态都取反，这样就可以实现大小的切换了。具体代码如下： 12345- (void)clickGoldEgg:(UIButton *)sender&#123; if(sender.selected)&#123; return; &#125; sender.selected = !sender.selected; self.colorEggBtn.selected = !_colorEggBtn.selected; &#125; 但是这样写会出现问题，就是蛋蛋在点击之后高亮状态下的显示问题。我们知道，按钮有三种状态：UIControlStateNormal（正常）、UIControlStateHighlighted（高亮）、UIControlStateSelected（选中）。 在正常状态点击时不松手会触发高亮状态，调用系统方法（setHighlighted：），并显示为事先设置的高亮状态图片，如果之前没设置，默认显示效果为在原图片下加一层灰色。这个问题好解决，如果不想显示高亮状态，只需要将高亮状态下的图片设置为和正常状态下的一样就好了嘛： 12[goldEgg setImage:[UIImage imageNamed:@\"goldegg\"] forState:UIControlStateNormal];[goldEgg setImage:[UIImage imageNamed:@\"goldegg\"] forState:UIControlStateHighlighted]; 然而在变成选中状态之后，点击彩蛋，还是会有highlighted的状态，而且这次显示的图片是小蛋而不是大蛋！你们可以自行脑补一下效果，一只大金蛋突然变成个小蛋，一松手又变成个大的？！ 什么鬼！ 天真的我以为是highlight状态设置的图片是小蛋的原因，马上改成大蛋试下： 1[goldEgg setImage:[UIImage imageNamed:@\"goldeggpicked\"] forState:UIControlStateHighlighted]; 没有任何变化！！！ 看来选中状态时的点击并不是hightlighted状态啊，那是什么状态呢？又是通过上网找资料，我才发现，要选中时高亮是这个状态 UIControlStateSelected | UIControlStateHighlighted ，只要将这个状态下的图片设置成和选中状态下的一样就好啦！ 12[goldEgg setImage:[UIImage imageNamed:@\"goldeggpicked\"] forState:UIControlStateSelected];[goldEgg setImage:[UIImage imageNamed:@\"goldeggpicked\"] forState:UIControlStateSelected|UIControlStateHighlighted]; 问题完美解决，金蛋彩蛋可以愉快切换啦！ 虽然是个小问题，还是记录下和大家分享一下。万一也遇到类似问题，不用担心掉坑啦！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"在UITableViewCell上添加手势的问题","slug":"2017/09/20-UITableViewAndUIGestureRecognizer","date":"2017-09-20T05:40:38.000Z","updated":"2018-03-27T14:45:15.703Z","comments":true,"path":"2017/09/20/2017/09/20-UITableViewAndUIGestureRecognizer.html","link":"","permalink":"http://debugly.cn/2017/09/20/2017/09/20-UITableViewAndUIGestureRecognizer.html","excerpt":"","text":"问题描述在某一些UITableViewCell上添加长按手势。 1234567891011121314- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; SLPlaybackCommentViewCell *cell = [tableView dequeueReusableCellWithIdentifier:kSLPlaybackCommentViewCell]; SLZoneCommentModel *comment = [self.comments sc_objectOrNilAtIndex:indexPath.row]; [cell updateCell:comment]; if([[SLLiveUserCenter sdkUid] isEqualToString:comment.Uid]) &#123; UILongPressGestureRecognizer *longPressGR = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longPressGR:)]; longPressGR.minimumPressDuration = 1; [cell addGestureRecognizer:longPressGR]; &#125; return cell;&#125; 现在，列表里某些cell添加了长按手势，这时做如下操作：多次滑动列表，然后去长按那些没有添加长按手势的cell，竟然也响应了长按手势。经分析，原来是cell重用导致的这个问题，滑动列表的过程中，那些添加了长按手势的cell被重用了，所以导致某些原本没有添加长按手势的cell也被附着了长按手势。另外，这种写法也会导致在一个cell上多次添加长按手势。 解决方案如果我们只需要在UITableView的某些符合条件的cell上添加手势，我们可以直接在UITableView上添加手势： 1234UITableView *contentTableView = [[UITableView alloc] init];UILongPressGestureRecognizer *longPressGR = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longPressGR:)];longPressGR.minimumPressDuration = 1;[contentTableView addGestureRecognizer:longPressGR]; 然后我们去实现手势的处理方法，在处理方法里面去判断哪些cell需要做逻辑处理： 123456789101112131415//长按手势响应方法-(void)longPressGR:(UILongPressGestureRecognizer *)gesture&#123; if(gesture.state == UIGestureRecognizerStateBegan) &#123; //获取触摸点，根据触摸点确定哪一行cell被长按了 CGPoint point = [gesture locationInView:self.contentTableView]; NSIndexPath * indexPath = [self.contentTableView indexPathForRowAtPoint:point]; if(indexPath == nil) return ; SLZoneCommentModel *comment = [self.comments sc_objectOrNilAtIndex:indexPath.row]; //判断该行cell是否符合条件（自己定义），如果不符合直接return，符合了再去做逻辑处理 if(![[SLLiveUserCenter sdkUid] isEqualToString:comment.Uid]) return; //逻辑处理 ... &#125;&#125; 这样就解决了只在某些UITableViewCell上添加手势的需求，再也不用怕cell重用导致的添加手势相关的bug了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"TableViewCell 点击后背景蒙层变透明的解决方案","slug":"2017/09/15-ws2","date":"2017-09-15T11:17:23.000Z","updated":"2018-03-27T14:45:15.702Z","comments":true,"path":"2017/09/15/2017/09/15-ws2.html","link":"","permalink":"http://debugly.cn/2017/09/15/2017/09/15-ws2.html","excerpt":"","text":"做OpenSdk下载列表时， 点击cell ,封面图上会有暂停蒙层（黑色半透明，加在了contentView上），但是点击其它cell时， 系统会把这个蒙层的背景颜色改为透明。 解决方案： 需要重写系统的 setSelected:(BOOL)selected animated:(BOOL)animated 方法， 在这个方法中将背景色重新设置回来。 12345678- (void)setSelected:(BOOL)selected animated:(BOOL)animated&#123; [super setSelected:selected animated:animated]; self.progressView.backgroundColor = SVFUIColor9; if(self.stateView)&#123; self.stateView.backgroundColor = __SCUIColorWithHexAndAplha(@\"0x000000\", 0.5); &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"实现一个图片 360 度不停旋转","slug":"2017/09/15-360rotate","date":"2017-09-15T08:07:58.000Z","updated":"2018-03-27T14:45:15.701Z","comments":true,"path":"2017/09/15/2017/09/15-360rotate.html","link":"","permalink":"http://debugly.cn/2017/09/15/2017/09/15-360rotate.html","excerpt":"","text":"我想要实现一个图片不停的360度旋转的动画效果，类似于加载时候不停的转圈圈，通过网上查找资料，试用了两种方法： 1、UIView 动画递归的方式1234567891011- (void)startAnimation &#123; CGAffineTransform transform = CGAffineTransformMakeRotation(imageviewAngle * (M_PI / 180.0f)); [UIView animateWithDuration:0.01 delay:0 options:UIViewAnimationOptionCurveLinear animations:^&#123; imageView.transform = transform; &#125; completion:^(BOOL finished) &#123; imageviewAngle += 10; [self startAnimation]; &#125;]; &#125; 点击之后，我调用了这个方式让图片不停旋转，但是不断地点击就会导致图片越转越快，原因是这个函数是递归的，每点击一次就会增加递归，使之角度增加10，之前点击触发的递归调用并没有出口，因此多次点击后imageviewAngle就在好几个递归里一直累加，点击次数越多，累加的频率也就越快，所以图片就会转的越来越快，于是使用了下面的方法。 2、CABasicAnimation 方式12345678CABasicAnimation* rotationAnimation; rotationAnimation = [CABasicAnimation animationWithKeyPath:@\"transform.rotation.z\"]; rotationAnimation.toValue = [NSNumber numberWithFloat: M_PI * 2.0 ]; rotationAnimation.duration = duration; rotationAnimation.cumulative = YES; rotationAnimation.repeatCount = repeat; [_loadingView.layer addAnimation:rotationAnimation forKey:@\"rotationAnimation\"]; 这种方式不会出现不断点击图片越转越快的问题，移除掉动画就能停止： 1[_loadingView.layer removeAnimationForKey:@&quot;rotationAnimation&quot;];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"IOS 刷新 UITableView 的 section 时崩溃","slug":"2017/09/15-reloadSections","date":"2017-09-15T06:50:44.000Z","updated":"2018-03-27T14:45:15.702Z","comments":true,"path":"2017/09/15/2017/09/15-reloadSections.html","link":"","permalink":"http://debugly.cn/2017/09/15/2017/09/15-reloadSections.html","excerpt":"","text":"问题描述在调用UITableView的如下方法时崩溃 12NSIndexSet *indexSet=[[NSIndexSet alloc]initWithIndex:1];[tableview reloadSections:indexSet withRowAnimation:UITableViewRowAnimationNone]; 崩溃信息如下 123456789101112131415161718192021222324252627*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of rows in section 3. The number of rows contained in an existing section after the update (1) must be equal to the number of rows contained in that section before the update (0), plus or minus the number of rows inserted or deleted from that section (0 inserted, 0 deleted) and plus or minus the number of rows moved into or out of that section (0 moved in, 0 moved out).'*** First throw call stack:( 0 CoreFoundation 0x0000000106ed0d4b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x0000000105d5421e objc_exception_throw + 48 2 CoreFoundation 0x0000000106ed4e42 +[NSException raise:format:arguments:] + 98 3 Foundation 0x00000001058e966d -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 195 4 UIKit 0x00000001094c377d -[UITableView _endCellAnimationsWithContext:] + 17558 5 UIKit 0x00000001094dac43 -[UITableView _updateSections:updateAction:withRowAnimation:headerFooterOnly:] + 487 6 SohuLiveDemo 0x0000000101a91ad3 __40-[SLAnchorsTabView loadRecommendAnchors]_block_invoke + 771 7 SohuLiveDemo 0x0000000101ada0cb __50-[SCNetworkService(Maker) sendRequest:completion:]_block_invoke + 155 8 SohuLiveDemo 0x0000000101942778 __39-[SCNetworkRequest doFinishWithResult:]_block_invoke_2 + 168 9 CoreFoundation 0x0000000106e600b2 __53-[__NSArrayM enumerateObjectsWithOptions:usingBlock:]_block_invoke + 114 10 CoreFoundation 0x0000000106e5ff42 -[__NSArrayM enumerateObjectsWithOptions:usingBlock:] + 194 11 SohuLiveDemo 0x00000001019425e2 __39-[SCNetworkRequest doFinishWithResult:]_block_invoke + 194 12 libdispatch.dylib 0x000000010b8f1978 _dispatch_call_block_and_release + 12 13 libdispatch.dylib 0x000000010b91b0cd _dispatch_client_callout + 8 14 libdispatch.dylib 0x000000010b8fb8a4 _dispatch_main_queue_callback_4CF + 406 15 CoreFoundation 0x0000000106e94e49 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9 16 CoreFoundation 0x0000000106e5a37d __CFRunLoopRun + 2205 17 CoreFoundation 0x0000000106e59884 CFRunLoopRunSpecific + 420 18 GraphicsServices 0x000000010c7a2a6f GSEventRunModal + 161 19 UIKit 0x0000000109384c68 UIApplicationMain + 159 20 SohuLiveDemo 0x000000010031b3ef main + 111 21 libdyld.dylib 0x000000010b96768d start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 问题分析崩溃信息描述大概是这个意思，这个刷新无效，具体指section 3的行数无效。下面给出了具体的原因，section 3刷新前是1行，刷新后变成了0行，而在reloadSections的set里边又没有包含要刷新的section 3，故表在刷新的时候就报错了。这个问题该如何解决呢？ 我们在局部刷新的时候，若表数据改变了，一定要把所有改变的区，或者是行都包含进去，才能避免崩溃。 若section的row是动态变化的，考虑直接使用reloadData，可避免崩溃。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"Core Animation 与 UIView.frame","slug":"2017/09/14-layerAnimation_frame","date":"2017-09-14T09:02:23.000Z","updated":"2018-03-27T14:45:15.701Z","comments":true,"path":"2017/09/14/2017/09/14-layerAnimation_frame.html","link":"","permalink":"http://debugly.cn/2017/09/14/2017/09/14-layerAnimation_frame.html","excerpt":"","text":"引言 在做一次关于Core Animation的分享时，老大提出了一个很是尖锐的问题——如果让layer保持动画后的状态，那么layer对应的view的响应区域是否是动画后view展示在屏幕上的区域？带着这个问题，开启Core Animation与view.frame的讨论。 Core Animation 与 view.frame首先，先来看一下Core Animation对view.frame的影响。对于CALayer，有以下属性会对view的frame产生影响，包括：anchorPoint、position、transform。 首先，通过以下代码，创建了一个红色button，并且在打印出动画前button和button.layer的frame，为了便于观察动画前后的位置，还创建了一个只有黑色边框的view 123456789101112131415UIButton *moveButton = [UIButton buttonWithType:UIButtonTypeCustom];moveButton.backgroundColor = [UIColor redColor];moveButton.frame = CGRectMake(50, 100, 40, 40);[moveButton addTarget:self action:@selector(moveButtonClicked) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:moveButton];self.moveButton = moveButton;NSLog(@&quot;动画之前 frame: %@&quot;,NSStringFromCGRect(self.moveButton.frame));NSLog(@&quot;动画之前 layer frame: %@&quot;,NSStringFromCGRect(self.moveButton.layer.frame));UIView *bgView = [[UIView alloc] initWithFrame:CGRectMake(48, 98, 44, 44)];bgView.backgroundColor = [UIColor clearColor];bgView.layer.borderColor = [UIColor blackColor].CGColor;bgView.layer.borderWidth = 1;[self.view addSubview:bgView]; 在动画结束之后，再次打印button和button.layer的frame： 1234-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; NSLog(@&quot;动画之后 frame: %@&quot;,NSStringFromCGRect(self.moveButton.frame));&#125;NSLog(@&quot;动画之后 layer frame: %@&quot;,NSStringFromCGRect(self.moveButton.layer.frame)); anchorPoint看一下使用Core Animation对anchorPoint做动画： 123456789CABasicAnimation *positionAnimation = [CABasicAnimation animationWithKeyPath:@&quot;anchorPoint.x&quot;];positionAnimation.fromValue = @0.5;positionAnimation.toValue = @1;positionAnimation.duration = 1;positionAnimation.repeatCount = 1;positionAnimation.delegate = self;positionAnimation.fillMode = kCAFillModeForwards;positionAnimation.removedOnCompletion = NO;[self.moveButton.layer addAnimation:positionAnimation forKey:@&quot;anchorPoint&quot;]; 动画后如下： 此时，看一下console中的关于frame的输出信息： 使用Core Animation对anchorPoint做动画前后，虽然在屏幕上看起来，button的位置发生了变化，但是从console的输出可以看出，button和button.layer的frame是没有变化的。 并且，此时点击红色button左半边，是不会触发button的响应事件的，而点击黑框中的区域，即红色button动画前的区域，是可以触发button的响应事件。 position接下来看一下对layer的position做CA动画，frame的变化。 123456789CABasicAnimation *positionAnimation = [CABasicAnimation animationWithKeyPath:@&quot;position.x&quot;];positionAnimation.fromValue = @70;positionAnimation.toValue = @250;positionAnimation.duration = 1;positionAnimation.repeatCount = 1;positionAnimation.delegate = self;positionAnimation.fillMode = kCAFillModeForwards;positionAnimation.removedOnCompletion = NO;[self.moveButton.layer addAnimation:positionAnimation forKey:@&quot;Position&quot;]; 动画后如下： console中的关于frame的输出信息： 红色button的frame依然没有变化，并且，只有点击黑框中的区域，才能触发button的响应事件。 transformtransform可以对layer实现旋转rotation、缩放scale、平移transition等动画。 对于rotation： 123456789CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];rotationAnimation.fromValue = @0;rotationAnimation.toValue = @(M_PI/4);rotationAnimation.duration = 1;rotationAnimation.repeatCount = 1;rotationAnimation.delegate = self;rotationAnimation.fillMode = kCAFillModeForwards;rotationAnimation.removedOnCompletion = NO;[self.moveButton.layer addAnimation:rotationAnimation forKey:@&quot;Rotation&quot;]; 对于scale： 123456789CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];scaleAnimation.fromValue = @0.5;scaleAnimation.toValue = @3;scaleAnimation.duration = 1;scaleAnimation.repeatCount = 1;scaleAnimation.removedOnCompletion = NO;scaleAnimation.fillMode = kCAFillModeForwards;scaleAnimation.delegate = self;[self.moveButton.layer addAnimation:scaleAnimation forKey:@&quot;Scale&quot;]; 对于transition： 123456789CABasicAnimation *rotationXAnimation1 = [CABasicAnimation animationWithKeyPath:@&quot;transform.translation.x&quot;];rotationXAnimation1.fromValue = @(0);rotationXAnimation1.toValue = @200;rotationXAnimation1.duration = 1;rotationXAnimation1.removedOnCompletion = NO;rotationXAnimation1.fillMode = kCAFillModeForwards;rotationXAnimation1.repeatCount = 1;rotationXAnimation1.delegate = self;[self.moveButton.layer addAnimation:rotationXAnimation1 forKey:@&quot;Translation&quot;] 并且上述三种动画之后，console中的输出均为下图所示： 红色button的frame依然没有变化，并且，只有点击黑框中的区域，才能触发button的响应事件。 结论由此得出结论，Core Animation是作用在CALayer上的，不论CALayer在动画结束前后，是否保持动画后的状态，都不会改变view和view.layer的frame以及view的事件响应区域，即view和view.layer的frame均不会改变，并且view的事件响应区域也没有改变。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"使用信号量解决多线程同步问题","slug":"2017/09/14-use-semaphore","date":"2017-09-14T01:10:42.000Z","updated":"2018-03-27T14:45:15.701Z","comments":true,"path":"2017/09/14/2017/09/14-use-semaphore.html","link":"","permalink":"http://debugly.cn/2017/09/14/2017/09/14-use-semaphore.html","excerpt":"","text":"临时帮忙去做了一期千帆小视频的SDK，大致的流程是这样的 : 录制小视频公开了两个串行队列，一个是处理摄像头回调的，一个是处理麦克风数据回调的，当用户按下录制按钮时开始采集音视频，通过代理方法拿到一帧帧的数据，当检测到音频^1时就创建一个编码器，开始编码，用户松手后停止编码。 IMP看代码之前需要说明下，转码器的创建、开始/停止编码要在同一个线程中，这些操作是不耗时的，为了简单就在主线程中做，代码如下: 12345678910111213141516171819202122if (self.recordEncoder) &#123; NSLog(@\"--xql-prepare-created\"); return;&#125;WS(weakSelf);dispatch_block_t execute = ^&#123; SS(strongSelf); self.recordEncoder = [[TERecordEncoder alloc]initWithSavePath:videoPath muxerItem:item]; NSLog(@\"create encoder:%@\",self.recordEncoder);&#125;;if([NSThread isMainThread])&#123; NSLog(@\"dispatch_main_sync\"); execute();&#125;else&#123; NSLog(@\"dispatch_sync_begin\"); dispatch_sync(dispatch_get_main_queue(), execute);&#125; 解释： 如果已经创建了，不要重复创建； 如果当前就在主线程，则直接执行；否则就同步到主线程执行，注意我用 dispatch_sync[^2] 函数，主要考虑到编码器必须要初始化完成后，才能开始编码，否则时序就乱了。 Hole测试的时候发现，如果连续狂点录制按钮（按下松开/开始录制停止录制）的话，会导致上次编码还没结束，又创建了一个编码器，这就出了问题了，解码器内部错误；编码组要求时序要正确，不能同时搞两个编码器编码，必须等上一个完成！ 我就在代码里加了log，然后发现编码器确实创建了两次，但是看代码不知道哪里出了问题了，因为log显示都是在异步线程同步到主线程创建的，代理queue都是串行的。 然后我在log里加上了线程的信息，发现创建两次竟然是在不同的线程里创建的，我恍然大悟：因为数据是从两个队列里吐出来的，有可能是视频的，也有可能是音频的，虽然都是串行的，但是可能同时回调，于是这块代码就构成了竞态条件了！ 那么接下来就是处理多线程同步问题了，一般都是加同步块，加锁，串行队列，信号量等等。 Semaphore &amp; 互斥锁将信号量设置为1，做一把互斥锁就可以解决上面的问题了:如果是视频回调先获得了信号量，那么音频回调就需要等待，因为没有可用的信号量了，等待结束后，我们的编码器也就创建好了，创建的过程又是同步的，因此接下来就可以编码了；反之，音频回调先来了，那么视频回调时也只能等着！ 代码修改如下: 123init&#123; self.semaphore = dispatch_semaphore_create(1);&#125; 123456789101112131415161718192021222324252627///视频的线程和音频的线程都会走这个方法，因此做个信号量保证同步；dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);if (self.recordEncoder) &#123; NSLog(@\"--xql-prepare-created\"); dispatch_semaphore_signal(self.semaphore); return;&#125; WS(weakSelf);dispatch_block_t execute = ^&#123; SS(strongSelf); self.recordEncoder = [[TERecordEncoder alloc]initWithSavePath:videoPath muxerItem:item]; NSLog(@\"create encoder:%@\",self.recordEncoder);&#125;;if([NSThread isMainThread])&#123; NSLog(@\"dispatch_main_sync\"); execute(); dispatch_semaphore_signal(self.semaphore);&#125;else&#123; NSLog(@\"dispatch_sync_begin\"); dispatch_sync(dispatch_get_main_queue(), execute); NSLog(@\"dispatch_sync_end:%@\",self.recordEncoder); dispatch_semaphore_signal(self.semaphore);&#125; 只要进入竞态区就要获取信号量，用完之后要记得释放信号量，否则会导致线程死等！信号量使用这块完全可以封装成一把锁🔐来用！ [^2]: dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);的作用是：将通过block添加的任务派发到指定的queue去执行，这一过程将阻塞当前线程，只有当任务执行完毕后，逻辑才能接着往下走；如果当前线程和指定的queue是统一线程的话就会死锁！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"C语言malloc、free、memmove","slug":"2017/09/13-c-malloc","date":"2017-09-13T11:06:42.000Z","updated":"2018-03-27T14:45:15.699Z","comments":true,"path":"2017/09/13/2017/09/13-c-malloc.html","link":"","permalink":"http://debugly.cn/2017/09/13/2017/09/13-c-malloc.html","excerpt":"","text":"在开发斗地主的语音房时，显示当前音量用的C语言实现，会分配buffer地址，最后释放buffer，使用了malloc、free和memmove等方法。三个方法的具体使用如下： mallocvoid *malloc(long NumBytes); 该函数分配了NumBytes个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。 失败的原因有多种，比如说空间不足。 freefree(void *FirstByte);```12345678该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存。对于free(p)这句语句，如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。每次用free释放完空间，都将指针置为NULL，这样就避免了重复释放时程序崩溃。## memmove```cvoid *memcpy(void *dst, const void *src, size_t count);void *memmove(void *dst, const void *src, size_t count); 都是由src所指内存区域复制count个字节到dest所指内存区域。作用是一样的，唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确，但memcopy比memmove的速度要快一些。 在使用free时，会遇到崩溃的情况，应该是遇到野指针的问题，对同一内存多次释放，所以在使用free后，应该将指针置为NULL。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"UIScrollView 的 scrollsToTop 失效问题","slug":"2017/09/13-scrollsToTop","date":"2017-09-13T09:58:21.000Z","updated":"2018-03-27T14:45:15.700Z","comments":true,"path":"2017/09/13/2017/09/13-scrollsToTop.html","link":"","permalink":"http://debugly.cn/2017/09/13/2017/09/13-scrollsToTop.html","excerpt":"","text":"一般情况下，当前页面有滚动视图(UIScrollView或者UIScrollView的子类)时，触摸状态栏，视图会自动滚动的最顶端。如果页面有多个滚动视图，且是iOS10.0以下的系统，你会发现触摸状态栏没有反应了，回到顶部功能失效了。目前iOS10.0或以上系统没发现存在这个问题。 解决方案经研究发现，UIScrollView有个scrollsToTop属性，这个属性就是控制滚动到顶部手势的开关。它的默认值是YES ，所以不用我们设置，默认是支持滚动到顶部的。继续回到上面遇到的问题，既然默认是YES，为什么回到顶部的功能失效了呢，这是因为有多个UIScrollView的情况下，他们默认都有scrollsToTop的功能，所以触摸状态栏时，系统无法判断是使哪个UIScrollView回到顶部。解决方案很简单，如果当前页面有多个滚动视图的话，要确保只有一个滚动视图的scrollsToTop为YES，这样系统就知道要使哪个UIScrollView回到顶部了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"UIButton 设置图片的 contentMode","slug":"2017/09/13-ws1","date":"2017-09-13T02:02:54.000Z","updated":"2018-03-27T14:45:15.700Z","comments":true,"path":"2017/09/13/2017/09/13-ws1.html","link":"","permalink":"http://debugly.cn/2017/09/13/2017/09/13-ws1.html","excerpt":"","text":"在开发彩蛋红包时，有两个发送红包的按钮 “+”和 “-”。这两个按钮是两张图片。在设置图片时，发现其不能很好的适配6 plus机型，如下图所示。于是我尝试了设置图片的contentMode: 1[minus.imageView setContentMode:UIViewContentModeScaleToFill]; 然而并没有什么卵用。。。图片还是不能填充整个按钮，后来查阅资料才发现，设置图片的对齐方式是没有用的，需要设置按钮的内容水平对齐方式和垂直对齐方式，代码如下： minus.contentEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 0); minus.contentHorizontalAlignment= UIControlContentHorizontalAlignmentFill; minus.contentVerticalAlignment = UIControlContentVerticalAlignmentFill; 重新运行，发现已经OK啦！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"CALayer 的 anchorPoint 与 position","slug":"2017/09/12-anchorPoint_position","date":"2017-09-12T10:33:42.000Z","updated":"2018-03-27T14:45:15.699Z","comments":true,"path":"2017/09/12/2017/09/12-anchorPoint_position.html","link":"","permalink":"http://debugly.cn/2017/09/12/2017/09/12-anchorPoint_position.html","excerpt":"","text":"在项目中要实现一个动画，想让view从底部展开，经过搜索，知道了CALayer的anchorPoint可以控制动画的固定点，遂直接写了如下代码： 123456self.redView.layer.anchorPoint = CGPointMake(0.5, 1.0);self.redView.transform = CGAffineTransformMakeScale(1, 0);[UIView animateWithDuration:2 animations:^&#123; self.redView.transform = CGAffineTransformIdentity;&#125; completion:^(BOOL finished) &#123;&#125;]; 思路很简单，将view的底边终点作为anchorPoint，动画初始状态设置y轴缩放为0，动画结束状态恢复view的y轴缩放比例为1。 效果甚是明显，我想要的是左边绿色view的动画效果，然而红色view虽然也是从底边展开的，但是，红色view的位置却跑偏了，直接向上移动了半个view的高度。这是为什么呢？接下来就是漫长的搜索过程…… anchorPoint首先，认识一下CALayer的重要属性——anchorPoint，即锚点、定位点。 怎么理解它呢，设想一张纸被一颗钉子钉在墙上，那么纸就可以绕着钉子旋转，这个钉子在纸上的位置，就可以理解为纸的锚点。钉子在纸的左上角，则左上角（0，0）就是纸的锚点；钉子在中心点（0.5，0.5），则中心点就是纸的锚点，以此类推。 由此，让我们认识一下anchorPoint。它的坐标系是相对于layer自身的，x和y的取值范围是0~1，左上角为0，右下角为1，默认情况下，anchorPoint是（0.5，0.5）。 左图是初始状态，右图中是设置anchorPoint为不同的值的状态，绿色为(0,0)，蓝色为(0.5,0.5)，灰色为(0.5,1)，红色为(1,0.5)，看一下效果： 由此可见，单独设置anchorPoint，会改变view的frame。 position那么，作为CALayer的另一重要属性的position指的又是什么呢？position的坐标系是相对于父图层的，默认点是layer的中心点。在理解了anchorPoint的含义之后，为了做测试，分别将anchorPoint的设置成不同的点，而保持position不变，结果发现anchorPoint总是与position重合，效果如下： 由此，得出结论：position所指的位置，是anchorPoint在父图层所在的位置，即二者会一直保持重合。 并且经过搜索，得到如下计算公式： 12frame.origin.x = position.x - anchorPoint.x * bounds.size.width；frame.origin.y = position.y - anchorPoint.y * bounds.size.height； 通过公式，可以得到一个结论：改变anchorPoint或者position，都会对view的frame产生影响。通过这个公式也可以验证引言中提到的改变红色view的anchorPoint之后，动画向上偏移的原因了。红色view的坐标是确定的，所以在设置anchorPoint的同时，相应的改变下position使之也指向底部中点的位置，就能让view一直处在指定的位置，从而完美实现从底部向上展开的动画： 123456789CGPoint center = self.redView.center;CGFloat height = self.redView.frame.size.height;self.redView.layer.anchorPoint = CGPointMake(0.5, 1.0);self.redView.layer.position = CGPointMake(center.x, center.y+height/2);self.redView.transform = CGAffineTransformMakeScale(1, 0);[UIView animateWithDuration:2 animations:^&#123; self.redView.transform = CGAffineTransformIdentity;&#125; completion:^(BOOL finished) &#123;&#125;];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"Main Thread Checker","slug":"2017/09/12-main-thread-checker","date":"2017-09-12T09:36:14.000Z","updated":"2018-03-27T14:45:15.699Z","comments":true,"path":"2017/09/12/2017/09/12-main-thread-checker.html","link":"","permalink":"http://debugly.cn/2017/09/12/2017/09/12-main-thread-checker.html","excerpt":"","text":"我的测试机升级到 iOS11 beta10 之后，发现了严重的问题，我的手机直接卡死了，只有强制关机！这是我使用 Xcode 调试抓到的日志: 123456789101112131415161718192021222324252627282930313233343536373839404142Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 2015, TID: 196235, Thread name: (none), Queue name: com.apple.avfoundation.videodataoutput.bufferqueue, QoS: 0Backtrace:4 LittleVideoDemo 0x0000000104ca9630 -[TECaptureViewController didOutputVideoSampleBuffer:] + 925 LittleVideoDemo 0x0000000104c77fcc -[FUCamera captureOutput:didOutputSampleBuffer:fromConnection:] + 4166 AVFoundation 0x000000018bf57f0c &lt;redacted&gt; + 3447 AVFoundation 0x000000018bf57d24 &lt;redacted&gt; + 1008 CoreMedia 0x000000018983d598 &lt;redacted&gt; + 2609 CoreMedia 0x0000000189859b70 &lt;redacted&gt; + 22410 libdispatch.dylib 0x000000010750d45c _dispatch_client_callout + 1611 libdispatch.dylib 0x000000010751a800 _dispatch_continuation_pop + 59212 libdispatch.dylib 0x000000010750f24c _dispatch_source_invoke + 159213 libdispatch.dylib 0x000000010751bf30 _dispatch_queue_serial_drain + 21214 libdispatch.dylib 0x00000001075109a4 _dispatch_queue_invoke + 33215 libdispatch.dylib 0x000000010751bf30 _dispatch_queue_serial_drain + 21216 libdispatch.dylib 0x00000001075109a4 _dispatch_queue_invoke + 33217 libdispatch.dylib 0x000000010751d104 _dispatch_root_queue_drain_deferred_wlh + 42418 libdispatch.dylib 0x0000000107524100 _dispatch_workloop_worker_thread + 65219 libsystem_pthread.dylib 0x000000018631efe0 _pthread_wqthread + 93220 libsystem_pthread.dylib 0x000000018631ec30 start_wqthread + 42017-09-12 10:43:02.790898+0800 LittleVideoDemo[2015:196235] [reports] Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 2015, TID: 196235, Thread name: (none), Queue name: com.apple.avfoundation.videodataoutput.bufferqueue, QoS: 0Backtrace:4 LittleVideoDemo 0x0000000104ca9630 -[TECaptureViewController didOutputVideoSampleBuffer:] + 925 LittleVideoDemo 0x0000000104c77fcc -[FUCamera captureOutput:didOutputSampleBuffer:fromConnection:] + 4166 AVFoundation 0x000000018bf57f0c &lt;redacted&gt; + 3447 AVFoundation 0x000000018bf57d24 &lt;redacted&gt; + 1008 CoreMedia 0x000000018983d598 &lt;redacted&gt; + 2609 CoreMedia 0x0000000189859b70 &lt;redacted&gt; + 22410 libdispatch.dylib 0x000000010750d45c _dispatch_client_callout + 1611 libdispatch.dylib 0x000000010751a800 _dispatch_continuation_pop + 59212 libdispatch.dylib 0x000000010750f24c _dispatch_source_invoke + 159213 libdispatch.dylib 0x000000010751bf30 _dispatch_queue_serial_drain + 21214 libdispatch.dylib 0x00000001075109a4 _dispatch_queue_invoke + 33215 libdispatch.dylib 0x000000010751bf30 _dispatch_queue_serial_drain + 21216 libdispatch.dylib 0x00000001075109a4 _dispatch_queue_invoke + 33217 libdispatch.dylib 0x000000010751d104 _dispatch_root_queue_drain_deferred_wlh + 42418 libdispatch.dylib 0x0000000107524100 _dispatch_workloop_worker_thread + 65219 libsystem_pthread.dylib 0x000000018631efe0 _pthread_wqthread + 93220 libsystem_pthread.dylib 0x000000018631ec30 start_wqthread + 42017-09-12 10:43:03.145023+0800 LittleVideoDemo[2015:196235] current bundle is nil2017-09-12 10:43:05.278417+0800 LittleVideoDemo[2015:195860] key = 109004 attach = 可以很直观的看到，问题是在子线程更新了UI导致的，修改很简单，找到对应的代码，在主线程里调用即可。查了下之后才知道，他是继 Thread Sanitizer 之后新出的一种新的代码诊断，用来发现在子线程更新UI的问题。 工作原理在 App 启动后，这个 Checker 就利用 runtime 将只能在主线程执行的方法给替换掉（这不正是那些年被我们玩坏了的AOP嘛）然后帮你检查调用是否合法，对于本身就是线程安全的方法，则不会替换，不会帮你再次审查。因为是AOP所以不用重新编译代码，持续集成工具注入这个动态库 /Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib 就能帮你检查了[^Note]。 性能会额外增加大约 0.1s 的启动时候，和 1–2% 的 CPU 开销。这 0.1s 肯定是利用 runtime 是 swizzle 方法了呗。[^footnote]因为这个开销比较小，所以当连着线，直接使用 xcode 调试时，这货会自动启动，帮你检查，听起来挺省心的[^debugger]。 参考文章：https://developer.apple.com/documentation/code_diagnostics/main_thread_checker [^Note]: &gt; Unlike other code diagnostic tools, the Main Thread Checker doesn’t require recompilation, and can be used with existing binaries. You can run it on a macOS app without the Xcode debugger, such as on a continuous integration system, by injecting the dynamic library file located at /Applications/Xcode.app/Contents/Developer/usr/lib/libMainThreadChecker.dylib. [^debugger]: &gt; The Main Thread Checker is automatically enabled when you’re running your app with the Xcode debugger.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"SDK-issues 简介","slug":"2017/09/11-sdk-issues","date":"2017-09-11T14:50:11.000Z","updated":"2018-03-27T14:45:15.698Z","comments":true,"path":"2017/09/11/2017/09/11-sdk-issues.html","link":"","permalink":"http://debugly.cn/2017/09/11/2017/09/11-sdk-issues.html","excerpt":"","text":"该分类由千帆 SDK 团队共同维护，主要用来记录 SDK 开发过程中遇到的各种问题以及解决方案。写成博客记录是为了供组内其他成员学习参考，这样知识才能像血液一样在整个团队里不停循环，为我们注入更多的新鲜血液！ 提升团队整体战斗力，拉低技术差距。我为人人，人人为我。Hello,SDK issues","categories":[],"tags":[{"name":"issues","slug":"issues","permalink":"http://debugly.cn/tags/issues/"}]},{"title":"安装 iOS 11","slug":"2017/09/08-install-iOS11-beta10","date":"2017-09-08T00:46:43.000Z","updated":"2018-03-27T14:45:15.698Z","comments":true,"path":"2017/09/08/2017/09/08-install-iOS11-beta10.html","link":"","permalink":"http://debugly.cn/2017/09/08/2017/09/08-install-iOS11-beta10.html","excerpt":"","text":"9月12号苹果会发布新一代设备 — iPhone8，搭载 iOS 11 是肯定的，现在测试已经提了一些 iOS11上的问题了，因此我决定把我的设备也升级到 iOS 11，用来解 bug，适配等工作。 安装途径以下两种方式都可行，各有优缺，自行选择吧： OTA升级 到开发者中心，去下载 OTA 升级的一个描述文件： 这个描述文件需要装到手机里，最简单的方式是给自己发送一封邮件，把描述文件作为附件发给自己，然后在邮件App里点击附件就会安装了: 安装之后，去设置里就可以看到有新的更新了: 点击下载并安装: 下载完毕后，安装: 手机会重启，开机后会播放一段音乐。 下载镜像，使用 itunes 刷固件 到开发者中心，去下载对应机型的镜像文件： 下载完毕后，手机先要关闭查找我的 iPhone 功能，然后连上电脑，打开 itunes，找到 恢复 iPhone...选项： 按下 option 键 + 点击 恢复 iPhone... 就会弹出文件选择框，选择你下载的镜像即可。 iOS 11 变化大标题 📶好山寨，我之前信号没这么差的！桌面这些图标有所变化 控制项更多了，亮度和音量这里可以上下滑动的 下拉通知栏，猛地一看好像锁屏页面 新增文件App，感觉就是之前的 iCloud Drive App Store改版挺大的 调试安装了 iOS 11之后，Xcode 也要升级到 9 才能调试了，安装 Xcode9 必须升级 macOS ，至少是 10.12.6 ，一个个升级吧。都搞定之后就要去做适配工作了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"macOS 之 Unix 定时任务","slug":"2017/09/05-unix-crontab","date":"2017-09-05T05:10:32.000Z","updated":"2018-03-27T14:45:15.698Z","comments":true,"path":"2017/09/05/2017/09/05-unix-crontab.html","link":"","permalink":"http://debugly.cn/2017/09/05/2017/09/05-unix-crontab.html","excerpt":"","text":"截止目前，SDK的打包，已经代码审查都是通过脚本完成的，利用脚本可以轻松的帮我们搞定那些重复的枯燥工作，可以节省宝贵的时间又能避免修改配置环境引发的错误。虽然有了这些这些脚本了，不过还是得人工去执行，不够省心啊，作为一个追求极致又很懒的人，是不能忍的，于是就搞了个定时任务，每天下班后我们只需要提交下代码，到规定的时间后，打包机器（不关机）就自动去执行打包脚本，为我们打包，代码审查！ 简介在 Linux、Unix、MacOS(类Unix)系统下，crontab 命令可以用来设置周期性执行的任务。系统为每个用户分配一个 “table” 存储这些任务，这些任务通常称为 “cron job”。这些任务是在 cron 守护进程里执行的，因此执行时的环境跟用户登录的环境是不一样的，这也导致了很多新手都会遇到一个问题：直接执行脚本没一点问题，加入到 crontab 之后，就不能正常执行。 crontab 使用1、查看当前用户下的定时任务 123456crontab -l///没有定时任务crontab: no crontab for qianlongxu///有定时任务# 每分钟打印一次当前时间1 * * * * /Users/qianlongxu/Desktop/logdate.sh 2、删除当前用户设定的全部任务 1crontab -r 3、添加定时任务 先准备一个任务脚本 ‘logdate.sh’，最终由 cron 守护进程执行，内容如下： 12# 打印当前日期到文件echo $(date) &gt;&gt; /Users/qianlongxu/Desktop/log.txt 任务写好了，然后添加到 crontab 中，实现周期性的执行有两种方法： 直接编辑 1crontab -e 此时应该会打开 vim 编辑器，直接在里面写任务配置就好了；比如每分钟都执行可以这么写： 12# 每分钟打印一次当前时间* * * * * /Users/qianlongxu/Desktop/logdate.sh - 编写一个名为 `job.cron` 的shell脚本作为 crontab 的输入，内容如下： 12# 每分钟打印一次当前时间* * * * * /Users/qianlongxu/Desktop/logdate.sh 然后执行： 1crontab /Users/qianlongxu/Desktop/job.cron 这两种方法都可以添加任务。 任务格式编写任务是有格式的，一共6列，前五列是设定周期的，最后一列是要执行的命令或者脚本: 12分 时 日 月 周 命令/脚本* * * * * cmd 第1列表示分钟1～59 每分钟用或者 /1表示 第2列表示小时1～23（0表示0点） 第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令 任务不执行添加了任务后可能没有按照预期的周期去执行，可能是以下原因: 任务脚本没有执行权限，给他一个可执行的权限： sudo chmod 755 /Users/qianlongxu/Desktop/logdate.sh 添加任务是时间设置的有问题，我曾经想当然的把每小时的第一分钟执行理解为了每分钟都执行，我找了半个小时也没找到问题！ 网上有人说到 cron 服务，这个在 Mac下比较特殊，不像 Linux，cron 服务我们貌似干预不了，是 launchctl 控制的，比如: 12345678///在 launchctl 里找下 cron 服务sudo launchctl list | grep cronPassword:225 0 com.vix.cron /// 尝试停止 cron 服务，结果失败了sudo /usr/sbin/cron stopPassword:cron: cron already running, pid: 225 你就没法停止这个服务，执行 restart 也是一样的，服务也不会重新开始； 任务脚本里的路径不对，由于任务开始执行的进程没有加载环境变量，所以在脚本里使用的命名需要带上路径，使用的目录也需要是绝对路径。 中文乱码，这个也是环境问题，可以在脚本的最上面声明下语言：export LANG=&quot;zh_CN.UTF-8&quot;","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"},{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"iOS 获取设备、应用相关信息","slug":"2017/08/31-iPhone-types","date":"2017-08-31T01:13:18.000Z","updated":"2018-03-27T14:45:15.697Z","comments":true,"path":"2017/08/31/2017/08/31-iPhone-types.html","link":"","permalink":"http://debugly.cn/2017/08/31/2017/08/31-iPhone-types.html","excerpt":"","text":"有的时候我们需要针对特定的机型或者系统版本做一些特殊的处理，使得我们的程序能够正常的运行，这时就要去判断设备型号、系统版本了，获取这些信息本身并没有什么技术含量，只是比较零碎，因此为了查阅方便，整理了一份代码出来，用的时候直接copy即可。 设备信息使用 uname 方法可以获取设备的硬件信息，其中就包括型号，我们可以根据型号具体的判断一个设备，比如 iPhone5s 的型号是 ‘iPhone6,2’; 使用的时候需要导入头文件： #import \\&lt;sys/utsname.h&gt; 12345struct utsname systemInfo;uname(&amp;systemInfo);NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding]; 这样获取的型号，不是我们平时叫的设备名称，所以一般都需要一个对应关系，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104- (NSString *)deviceType &#123; struct utsname systemInfo; uname(&amp;systemInfo); NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding]; if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;; if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;; if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;; if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;; if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;; if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;; if ([platform isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;iPhone 7&quot;; if ([platform isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;iPhone 7 Plus&quot;; if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;; if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;; if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;; return @&quot;unKnown&quot;;&#125; UIDevice 获取设备相关信息 系统版本号 12// 10.3.2[[UIDevice currentDevice]systemVersion] 系统名称 12// iOS[[UIDevice currentDevice] systemName] 电池电量 12//模拟器得到的是 -1[[UIDevicecurrentDevice]batteryLevel] 厂商唯一串号 123//226072EA-5C4C-43F9-9E66-6E8ACE31DE49[[[UIDevice currentDevice] identifierForVendor]UUIDString] 用户名 12///Matt Reach&apos;s iPhone[[UIDevice currentDevice] name] infoDictionaryApp 的版本，应用名称等都记录在 info.plist 里，可以这样获取： 12345678910NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];// 应用装到设备上之后，显示的名称 [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]// 应用的版本号 比如：6.8.3[infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];// 应用的build号 比如：2778NSString *appCurVersionNum = [infoDictionary objectForKey:kCFBundleVersionKey]; 其实这个里面信息蛮多的，其他的不再一一列举了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&#123; BuildMachineOSBuild = 16A323; CFBundleDevelopmentRegion = \"zh_CN\"; CFBundleDisplayName = \"\\U5343\\U5e06-SDK\"; CFBundleExecutable = SohuLiveDemo; CFBundleIcons = &#123; CFBundlePrimaryIcon = &#123; CFBundleIconFiles = ( AppIcon29x29, AppIcon40x40, AppIcon57x57, AppIcon60x60 ); &#125;; &#125;; CFBundleIdentifier = \"com.sohu.live.demo\"; CFBundleInfoDictionaryVersion = \"6.0\"; CFBundleName = SohuLiveDemo; CFBundleNumericVersion = 0; CFBundlePackageType = APPL; CFBundleShortVersionString = \"6.8.3\"; CFBundleSignature = \"????\"; CFBundleSupportedPlatforms = ( iPhoneSimulator ); CFBundleVersion = 1598; DTCompiler = \"com.apple.compilers.llvm.clang.1_0\"; DTPlatformBuild = \"\"; DTPlatformName = iphonesimulator; DTPlatformVersion = \"10.2\"; DTSDKBuild = 14C89; DTSDKName = \"iphonesimulator10.2\"; DTXcode = 0821; DTXcodeBuild = 8C1002; LSApplicationCategoryType = \"\"; LSApplicationQueriesSchemes = ( wechat, weixin, alipay, qianfan56, qfA31D406E33689950, mqq ); LSRequiresIPhoneOS = 1; MinimumOSVersion = \"7.0\"; NSAppTransportSecurity = &#123; NSAllowsArbitraryLoads = 1; &#125;; NSCameraUsageDescription = \"\\U7231\\U4e0a\\U76f4\\U64ad\"; NSMicrophoneUsageDescription = \"\\U8bf7\\U5141\\U8bb8\\U6211\\U4f7f\\U7528\\U9ea6\\U514b\\U98ce\"; NSPhotoLibraryUsageDescription = \"\\U5343\\U5e06SDK\\U60f3\\U4f7f\\U7528\\U60a8\\U7684\\U76f8\\U518c\"; UIAppFonts = ( \"MFLiHei-Regular.ttf\" ); UIDeviceFamily = ( 1 ); UILaunchImages = ( &#123; UILaunchImageMinimumOSVersion = \"8.0\"; UILaunchImageName = \"Brand Assets-800-Portrait-736h\"; UILaunchImageOrientation = Portrait; UILaunchImageSize = \"&#123;414, 736&#125;\"; &#125;, &#123; UILaunchImageMinimumOSVersion = \"8.0\"; UILaunchImageName = \"Brand Assets-800-667h\"; UILaunchImageOrientation = Portrait; UILaunchImageSize = \"&#123;375, 667&#125;\"; &#125;, &#123; UILaunchImageMinimumOSVersion = \"7.0\"; UILaunchImageName = \"Brand Assets-700\"; UILaunchImageOrientation = Portrait; UILaunchImageSize = \"&#123;320, 480&#125;\"; &#125;, &#123; UILaunchImageMinimumOSVersion = \"7.0\"; UILaunchImageName = \"Brand Assets-700-568h\"; UILaunchImageOrientation = Portrait; UILaunchImageSize = \"&#123;320, 568&#125;\"; &#125; ); UILaunchStoryboardName = \"Launch Screen\"; UIRequiredDeviceCapabilities = ( armv7 ); UIStatusBarStyle = UIStatusBarStyleDefault; UISupportedInterfaceOrientations = ( UIInterfaceOrientationPortrait, UIInterfaceOrientationLandscapeLeft, UIInterfaceOrientationLandscapeRight ); UIViewControllerBasedStatusBarAppearance = 0;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"入职搜狐两周年","slug":"2017/08/19-join-sohu-2year","date":"2017-08-19T01:37:04.000Z","updated":"2018-03-27T14:45:15.697Z","comments":true,"path":"2017/08/19/2017/08/19-join-sohu-2year.html","link":"","permalink":"http://debugly.cn/2017/08/19/2017/08/19-join-sohu-2year.html","excerpt":"","text":"时光荏苒，来搜狐已经 2 年整了，最近挺忙的，以至于今天来公司加班，查看邮件后才发现，今天是入职两周年的纪念日。 2 年 2 个城市 2 个团队。。。 不忘初心，勇往直前！","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://debugly.cn/tags/Other/"}]},{"title":"糟糕的2017款 MacBook Pro","slug":"2017/08/18-bye-2017mbp","date":"2017-08-18T13:43:29.000Z","updated":"2018-03-27T14:45:15.697Z","comments":true,"path":"2017/08/18/2017/08/18-bye-2017mbp.html","link":"","permalink":"http://debugly.cn/2017/08/18/2017/08/18-bye-2017mbp.html","excerpt":"","text":"两个月前，我司第二季度申请的电脑到了，我组有几台 2017 款的 MacBook Pro，带 Multi-Touch Bar 的，跟现在使用的 2015 款比起来纤薄了许多，也更加轻盈，性能不用说，更加强大。于是心里痒痒，忍不住换了下。 拿到手之后，感觉挺别扭的，因为我无法连接手机调试，充电；只好先买了一个 type-c 转 USB 的转接头； 我习惯了使用双显示器工作，所以又买了一个 type-c 转 HDMI 的转接头，这玩意可不便宜，花了￥99块大洋。 “键盘采用第二代蝶式结构，按键稳定性是传统剪刀式结构的 4 倍，并且手感更舒适，响应更灵敏。” 这段话来自于官网，不过我并没有感觉到更舒适，反而觉得键盘太难受了！！！键程太短了，按下没一点感觉，回弹也很无力，总结起来就是毫无手感。。。为了找到手感就买了一个机械键盘+鼠标，其实我之前一直没有鼠标的，感觉鼠标会拖慢我的效率，触控板挺好用的，因为用了外接键盘，手够不着触控板了，只好用迁就使用鼠标了。 “宽大的 Force Touch 触控板，让你的手指有充分的空间施展触控手势和进行点按操作。” 新的 MBP 配备了更加大的触控板，但由于我使用了外接键盘，导致这么大一块板子给白白浪费了！并没有派上用场。 “它更配备了 Multi-Touch Bar，一个内置于键盘的玻璃面多点触控条，让你能在需要时快速取用各种工具。” 至于这个 Bar 的话，几乎没碰过，就是刚到手的时候，尝尝鲜玩玩而已，后来配了外接键盘后，离我就更加远了，我连触控板都几乎不去碰了，就更别说这个Bar了，当初想尝试这个新款，当然也有这个 Bar 的原因，因为这个 Bar 是可编程的，想着可以没事了搞个程序玩下。 跟工作性质也有关系，几乎每天都要开会，开会时一般会拿上电脑，这时如果想继续调试就还有带上转接头，或者手机没电了，要充电也是如此，这样就感觉很不方便。 直到前两天，公司更新了PC，我的老DELL机器也一起更新了，并且我还选择了配备显示器（之前用的是同事的），领取新的机器和显示器后就把同事的显示器归还了，没想到的是这个显示器也是个奇葩，可以插传统的 VGA，还可以插一个我之前没见过的 DELL DP，尼玛啊，我哪有这个接口啊，公司配备的转接头是 HDMI 转 VGA 的，所以我就只能看，不能用了，网上查了下 Type C 转 DELL DP 的转接头需要 ￥210 个大洋。我只想说真尼玛折腾啊，各大公司的接口不统一，才会有这么多的转接头出现。 我觉得苹果就是为了追求新一代 MBP 的纤薄，才狠下心去掉了自家的 DP 接口和 USB 接口，选择拥抱了 type-c，并且阉割了一半键程的键盘！ 至于更加惊人的性能，更好的显示效果，更快的存储速度，续航能力等，这些都没有那么的明显，因为目前 2015 款的配置已经完全够用了！就我们编程而言，你体会不到这些变化。 新亏组里还有台 2015 款的 MBP，经过周转，我又换了回去；兜兜转转，一阵新鲜感过后，还是我去年申请的 MBP 用着最顺手！新款的 MBP，至于没有给我带来更多的欢乐，反而是更多的不便利，因此我觉得一味的最求轻薄，牺牲实际使用体验，反而不好，至少用在写代码的体验很是糟糕。 Bye 2017 MacBook Pro My loved 2015 MacBook Pro","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"iOS 沙盒与文件管理类","slug":"2017/08/12-sandbox-filemanager","date":"2017-08-12T01:24:47.000Z","updated":"2018-03-27T14:45:15.697Z","comments":true,"path":"2017/08/12/2017/08/12-sandbox-filemanager.html","link":"","permalink":"http://debugly.cn/2017/08/12/2017/08/12-sandbox-filemanager.html","excerpt":"","text":"正常情况下，我们的文档只能存储到沙盒里，在写业务逻辑时经常需要判断沙盒里某个文件是否存在，或者文件夹不存在创建文件夹等操作，因此写篇文章记录下如何获取沙盒路径，如何使用文件管理类创建目录等常用操作。 沙盒路径什么是沙盒？为了保证App的正常运行，不受到其他App的干扰，或者病毒的侵害，苹果为每个App设定了自己独立的目录，对于开发者而言，你只能访问这个目录下的文件或者子目录，这个目录是你App的根目录，这就是沙盒机制，大大减少了流氓软件和病毒。 关于沙盒设计可看官方介绍 App Sandbox Design Guide 沙盒内重要目录获取沙盒根目录，直接使用这个 C 方法就OK了: NSHomeDirectory() 沙盒里面有几个文件夹还记得吗？有 3 个，分别是： Documents : 一般重要的文件会放这里，不过默认情况下，备份App时会备份这里面的数据；这个目录也可以设置共享，就可以在itunes里向App导入数据了 NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) 注意：NSSearchPathForDirectoriesInDomains 函数返回的是个数组，取一个就行了。 Library/Caches : 一般会将图片这种没那么重要的资源缓存到这里 NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) tmp : 就是个临时目录，中间临时文件，存这里面，系统可能会删这里的文件，最好我们自己清理临时文件，减少沙盒的体积 NSTemporaryDirectory() 这三个都在App沙盒根目录里，因此也可以通过 NSHomeDirectory() 拼接出来。 管理文件和目录iOS 里使用 NSFileManager 类管理文件（夹），这是一个单利类，但你仍旧可以创建新的实例，自己使用。下面总结下 NSFileManager 的常用方法： 创建文件 12345678NSFileManager *fileManager = [NSFileManager defaultManager];///文件路径，文件内容，相关属性BOOL succ = [fileManager createFileAtPath:path contents:nil attributes:nil];if (succ) &#123; NSLog(@&quot;创建成功&quot;);&#125; else &#123; NSLog(@&quot;创建失败&quot;);&#125; 直接写入文件 NSString,NSData,NSArray,NSDictionary等常用类均提供了直接写入文件的方法；这里以 NSString 举例说明；由于这个方法的存在，所以上面的创建文件方法用的不是很多； 12345678NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@&quot;iOS.txt&quot;];NSString *text = @&quot;测试直接写入&quot;;BOOL succ = [text writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];if (succ) &#123; NSLog(@&quot;写入成功&quot;);&#125; else &#123; succ(@&quot;写入失败&quot;);&#125; 从文件读取 1234- (void)readFileContent&#123; NSString *text = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; NSLog(@&quot;text: %@&quot;, text);&#125; 创建文件夹 12345678NSFileManager *fileManager = [NSFileManager defaultManager];///第二个参数，一般传YES，意思是创建中间目录；BOOL succ = [fileManager createDirectoryAtPath:@&quot;/a/b/c&quot; withIntermediateDirectories:YES attributes:nil error:nil];if (succ) &#123; NSLog(@&quot;创建成功&quot;);&#125; else &#123; NSLog(@&quot;创建失败&quot;);&#125; 删除文件，文件夹 最好在异步线程里删除文件 1234567NSFileManager *fileManager = [NSFileManager defaultManager];BOOL succ = [fileManager removeItemAtPath:path error:nil];if (succ) &#123; NSLog(@&quot;删除成功&quot;);&#125;else&#123; NSLog(@&quot;删除失败&quot;);&#125; 文件是否存在 123456BOOL succ = [[NSFileManager defaultManager]fileExistsAtPath:savePath];if (succ) &#123; NSLog(@&quot;文件存在&quot;);&#125;else&#123; NSLog(@&quot;文件不存在&quot;);&#125; 文件夹是否存在 12345678910111213141516NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];NSString *basePath = [cachePath stringByAppendingPathComponent:@&quot;telittleVideo&quot;]; BOOL directory = NO;///注意，文件夹存在时，这个方法返回的也是YES哦，所以要继续判断 directory ！if ([[NSFileManager defaultManager]fileExistsAtPath:basePath isDirectory:&amp;directory] &amp;&amp; !directory) &#123; ///如果不是文件夹，那么说明存在了同名文件了，删掉吧 [[NSFileManager defaultManager]removeItemAtPath:basePath error:nil];&#125; ///文件夹不存在，要创建if(!directory)&#123; NSError *err = nil; [[NSFileManager defaultManager] createDirectoryAtPath:basePath withIntermediateDirectories:YES attributes:nil error:&amp;err]; NSLog(@&quot;%@&quot;,err);&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"使用 CocoaPods 管理 frameworks","slug":"2017/07/21-use-cocoapods-manager-frameworks","date":"2017-07-21T07:09:56.000Z","updated":"2018-03-27T14:45:15.696Z","comments":true,"path":"2017/07/21/2017/07/21-use-cocoapods-manager-frameworks.html","link":"","permalink":"http://debugly.cn/2017/07/21/2017/07/21-use-cocoapods-manager-frameworks.html","excerpt":"","text":"上篇博客介绍了如何创建 pods 库，让 pods 库帮我们管理源码、依赖、编译成库、配置search path等工作；但有时候你可能不想或者不能把源码提供出去，还想要使用 pods 管理版本的话，就可以让 pods 直接管理 frameworks 而不是源码！ 我已经实践了过了，确实可以管理 framework 的，这是创建好的包含 demo 的 pods 库地址 ：https://github.com/debugly/TestSCFPods。 创建步骤和创建管理源码的 pods 库是一样的，只不过 podspec 里的配置不太一样而已！如果你没有创建过 pods 库的话，最好先去看下上篇博客 : 创建 CocoaPods 库。 创建 git 仓库同样的，我们需要先创建一个 git 仓库，用于管理 frameworks 的版本，并且打 tag。然后克隆到本地，进入仓库目录 : 1cd ~/GitWorkspace/TestSCFPods 创建 podspec 文件进入仓库目录后，开始创建 podspec 文件 123pod spec create TestSCFPodsSpecification created at TestSCFPods.podspec 我把和创建普通源码 pods 库不一样的地方拿出来说下： 123456//上篇博客里没用到，因此没提；这个是资源路径，我的 SohuGameSDK.framework 里包含的有 SohuGame.xcassets 这个图片库；s.resources = &quot;SohuGameSDK.framework/SohuGame.xcassets&quot;///这个很重要，把需要管理的 frameworks 都写出来，如果有依赖关系，最好被依赖的写在前面s.vendored_frameworks = &quot;SohuCoreFoundation.framework&quot;,&quot;SohuGameSDK.framework&quot;///不需要额外暴露头文件# s.source_files = &quot;**/*.&#123;h&#125;&quot; 验证 podspec 文件同样的，使用 pod spec lint --allow-warnings 验证下，通过如下： 12345-&gt; TestSCFPods (1.0.0)Analyzed 1 podspec.TestSCFPods.podspec passed validation. 有错误的话，就使用 pod spec lint --allow-warnings --verbose 再次验证，不过会打印详细的日志，通过日志去找问题！ 提交 podspec 文件如果没有账户的话，那就注册一个；注册过了就 push 吧： pod trunk push TestSCFPods.podspec --allow-warnings 12345678910111213141516171819202122232425262728Updating spec repo `master`CocoaPods 1.3.0.beta.3 is available.To update use: `sudo gem install cocoapods --pre`[!] This is a test version we&apos;d love you to try.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.0.beta.3Validating podspec -&gt; TestSCFPods (1.0.0)Updating spec repo `master`CocoaPods 1.3.0.beta.3 is available.To update use: `sudo gem install cocoapods --pre`[!] This is a test version we&apos;d love you to try.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.0.beta.3-------------------------------------------------------------------------------- 🎉 Congrats 🚀 TestSCFPods (1.0.0) successfully published 📅 July 20th, 07:25 🌎 https://cocoapods.org/pods/TestSCFPods 👍 Tell your friends!-------------------------------------------------------------------------------- 恭喜你，成功了，接下来就可以创建个 demo 试下了！ 不仅能管理 frameworks ，还可以管理 .a 静态库，区别是 s.vendored_frameworks 改为 s.vendored_libraries ! 我觉得很赞的是，不用将资源手动添加到主工程里去，pods会自动通过脚本帮你完成这件事，这个是新版 pods 才有的功能，最初是不支持的，大概是从 1.0 开始支持的！！ 实际效果使用 pods 的最初原因是为了，集成我 SDK 的开发人员能够简单高效的换包，从实际使用的效率上来看，其实没有那么理想，我举个栗子，比如我 SDK 要更新发包了： 我的工作是: 将 SDK（也就是相关的 frameworks）上传到 github 升级一个 tag 号 升级 podspec 版本号 将 podspec 推送到 cocospods 集成者的工作是: 升级 Podfile 的版本号 使用 pod update 把库更新下来 提交更新后的代码 总体看来，SDK更新一个版本一共需要 7 个步骤，我感觉是略繁琐了些，所以我并没有采用 pods 管理 frameworks 来自动换包这个方案！ 还有个弊端是，如果 Podfile 里没有指定小版本号，那么可能集成App依赖的其他库也被更新了，或许App开发并不想更新其他依赖库！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://debugly.cn/tags/CocoaPods/"}]},{"title":"创建自己的 CocoaPods 库","slug":"2017/07/20-create-pod-library","date":"2017-07-20T09:23:12.000Z","updated":"2018-03-27T14:45:15.696Z","comments":true,"path":"2017/07/20/2017/07/20-create-pod-library.html","link":"","permalink":"http://debugly.cn/2017/07/20/2017/07/20-create-pod-library.html","excerpt":"","text":"使用 CocoaPods 管理 iOS 库已经不是什么新鲜事了，我最近刚开源了一个网络库，为了方便集成使用，因此决定支持下 CocoaPods，期间也遇到了几个问题，分享给大家。 准备工作创建 Pods 库，其实意思是让你的开源库支持 CocoaPods 管理，因此前提是你应当有一个开源库，先发布到 github 上，记得创建空仓库的时候让 github 给你生成一个 license，方面等会填写 Spec License。 在创建 Pods 库之前，我已经把 demo 和 SCNetworkKit 库发布到 github 上了，这是目录结构： 注意：其实只需要把库的源码放进来就好了，等创建完毕 pods 库之后，再创建 demo ；由于支持 pods 之前我已经有了 demo 了所以就暂时没删除。 记得在最后一次提交记录那里添加一个 tag，并 push 到 github 上，记住这个 tag 值，一会要用到！ 创建 podspec首先进入到仓库跟目录： cd /Users/crown/gitworkspace/SCNetworkKit 我们将在这个目录里创建一个 SCNetworkKit.podspec 文件，文件里面是一些配置和描述信息，使用如下命令创建： pod spec create SCNetworkKit 看到提示 Specification created at SCNetworkKit.podspec 就表明创建好了！接下来我们修改这个文件，必要的配置改下就好了： s.name : 默认已经帮你写好了，不用改了，这个名字就是别人 pod 你的库的名字； s.version : 这个 version 和你 github 仓库的tag是对应的，比如我的tag 是 1.0.0； s.summary : 对这个库的一个简单描述，不写的话等会验证的时候会有警告，别人搜索这个库的时候也会显示出来，所以最好写下； s.description : 这个是个详细的描述，文字个数要比 summary 写得要多，否则也有警告；注意写到两个 DESC 之间就好了； s.homepage : 如果这个库有主页的话，可以填上，搜索这个库的时候也会显示出来的； s.license : 改为你实际使用的 license 即可，如果没有的话，那就创建一个补上； s.author : 作者，会帮你填写为 git 的全局账户； s.platform : 根据实际情况写 iOS 或者 OS X； s.source : 填上仓库地址，需要https哦，或者写 ssh 的也行； s.source_files : 库文件所在目录，可以递归； s.framework : 依赖的系统库； s.library : 依赖的系统库； s.requires_arc : 是否必须是 arc； s.dependency : 你这个库依赖了哪些其他 pods 库； 第一次可能写不好，所以可以直接下载一个，看着改。 写好了，就验证下文件是否有误，可能需要多次修改，多次验证： pod spec lint --allow-warnings 我遇到的错误： 123456-&gt; SCNetworkKit (1.0.0) - ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information. - NOTE | xcodebuild: Headers/Public/SCNetworkKit/SCNetworkKit.h:11:9: fatal error: &apos;NSDictionary+SCAddtions.h&apos; file not found - NOTE | xcodebuild: clang: error: linker command failed with exit code 1 (use -v to see invocation) - NOTE | [iOS] xcodebuild: fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can&apos;t open input file: /var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/CocoaPods/Lint/DerivedData/App/Build/Intermediates/App.build/Release-iphonesimulator/App.build/Objects-normal/i386/App (No such file or directory) - NOTE | [iOS] xcodebuild: error: cannot parse the debug map for &quot;/var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/CocoaPods/Lint/DerivedData/App/Build/Products/Release-iphonesimulator/App.app/App&quot;: No such file or directory 这个原因是我最初路径我写错了，写成了 s.source_files = &quot;SCNetworkKit/*.{h,m}&quot;，没有递归查找子文件夹里的类，所以说这个类别文件找不到！我是通过加上 --verbose 之后，查看执行过程发现的，验证的时候会下载文件，然后 copy 到别的目录去编译，我发现没有下载子文件里的文件！ 123456-&gt; Installing SCNetworkKit (1.0.0) &gt; Copying SCNetworkKit from `/Users/crown/Library/Caches/CocoaPods/Pods/External/SCNetworkKit/d91c7ff7dcd08eaf54117a932c0d41d7-b0517` to `../../../../private/var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/CocoaPods/Lint/Pods/SCNetworkKit` - Running pre install hooks 还遇到了这个错误： 123456-&gt; SCNetworkKit (1.0.0) - ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information. - NOTE | xcodebuild: /var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/CocoaPods/Lint/DerivedData/App/Build/Products/Release-iphonesimulator/SCNetworkKit/SCNetworkKit.framework/Headers/SCNetworkKit.h:14:9: fatal error: &apos;SCJSONUtil.h&apos; file not found - NOTE | xcodebuild: /var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/CocoaPods/Lint/App/main.m:3:9: fatal error: could not build module &apos;SCNetworkKit&apos; - NOTE | xcodebuild: clang: error: linker command failed with exit code 1 (use -v to see invocation) - NOTE | [iOS] xcodebuild: fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can&apos;t open input file: /var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/CocoaPods/Lint/DerivedData/App/Build/Intermediates/App.build/Release-iphonesimulator/App.build/Objects-normal/i386/App (No such file or directory) 原因是 demo 里有个 SCJSONUtil.h 文件，我不小心把他导入到 SCNetworkKit.h 里了，但是 pods 检查是不会去下载 demo，所以根本找不到这个 SCJSONUtil.h 这个头文件！！！于是我删了这个头文件，接着 push 到了 github，并且修改了 tag 号！ 再次检查后发现还是这个错误，试了几次都是，我觉得不对劲，是不是走了缓存了？沿着这个思路去检查，发现果真不是每次检查都会重新下载代码的，而是读了缓存了！！！因此我删掉了缓存的代码，再次验证就通过了！ 删除之后，发现在 Copy 之前会重新下载！ 123456789101112131415161718192021222324Downloading dependencies-&gt; Installing SCNetworkKit (1.0.0) &gt; Git download &gt; Git download $ /usr/bin/git clone https://github.com/debugly/SCNetworkKit.git /var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/d20170720-43460-137oplc --template= --single-branch --depth 1 --branch 1.0.0 Cloning into &apos;/var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/d20170720-43460-137oplc&apos;... Note: checking out &apos;733b52034ca83c8ced0fb709e40bec8e3ccde344&apos;. You are in &apos;detached HEAD&apos; state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt;&gt; Copying SCNetworkKit from `/Users/crown/Library/Caches/CocoaPods/Pods/External/SCNetworkKit/d91c7ff7dcd08eaf54117a932c0d41d7-2e598` to `../../../../private/var/folders/2z/l7ftfgd54lv0_nvq7pnr_zbw0000gn/T/CocoaPods/Lint/Pods/SCNetworkKit` - Running pre install hooks 这个过程可能会遇到各种错误，只要耐心看打印的日志，一般都能解决的，可能需要反复验证，需要有些耐心！ 通过后会打印: 1234567** BUILD SUCCEEDED ** -&gt; SCNetworkKit (1.0.0)Analyzed 1 podspec.SCNetworkKit.podspec passed validation. 创建账户发布之前需要创建一个 CocoaPods 的账户，如果你有多个电脑，那么你可以注册多次，以邮箱地址为唯一标识，一个邮箱地址可以在多台电脑上注册！ pod trunk register youar@email.com &#39;nickName’ 通过这个命令注册后，你的邮箱很快就会收到 CocoaPods 发来的验证链接，点击即可激活，名称无法修改哦！激活之后，我们返回到终端继续往下操作即可，使用 pod trunk me 查看个人信息： 12345678pod trunk me - Name: Matt Reach - Email: qianlongxu@gmail.com - Since: July 20th, 02:05 - Pods: - SCNetworkKit - Sessions: - July 20th, 02:05 - November 25th, 04:34. IP: 125.35.217.43 发布 podspec将刚才已经验证通过的 podspec push 到 cocoapods 的仓库里，这样别人就能通过 pods 搜索到你的库了，从而使用你的库了； 1234567891011121314151617181920212223242526272829pod trunk push SCNetworkKit.podspec Updating spec repo `master`CocoaPods 1.3.0.beta.2 is available.To update use: `sudo gem install cocoapods --pre`[!] This is a test version we&apos;d love you to try.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.0.beta.2Validating podspec -&gt; SCNetworkKit (1.0.0)Updating spec repo `master`CocoaPods 1.3.0.beta.2 is available.To update use: `sudo gem install cocoapods --pre`[!] This is a test version we&apos;d love you to try.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.0.beta.2-------------------------------------------------------------------------------- 🎉 Congrats 🚀 SCNetworkKit (1.0.0) successfully published 📅 July 20th, 02:58 🌎 https://cocoapods.org/pods/SCNetworkKit 👍 Tell your friends!-------------------------------------------------------------------------------- 看到这个就表明已经 push 成功了！！ 🔍搜索是不是很高兴呢，Pods 库创建好了，我们试着搜下吧： pod search SCNetworkKit 结果是： 1[!] Unable to find a pod with name, author, summary, or description matching `SCNetworkKit` 好郁闷呢，明明已经成功发布了，为何就是搜索不到呢？这是因为再次之前我搜过别的库，CocoaPods 做了缓存了，因此我们找到他的搜索索引缓存，将它删除即可： rm -rf ~/Library/Caches/CocoaPods 再次搜索，会重新建立索引，这个过程大概需要片刻，耐心等待即可: 1234567891011pod search SCNetworkKitCreating search index for spec repo &apos;macdownapp&apos;.. Done!Creating search index for spec repo &apos;master&apos;.. Done!-&gt; SCNetworkKit (1.0.0) SCNetworkKit is a simple but powerful iOS network framework. pod &apos;SCNetworkKit&apos;, &apos;~&gt; 1.0.0&apos; - Homepage: http://debugly.cn/SCNetworkKit/ - Source: https://github.com/debugly/SCNetworkKit.git - Versions: 1.0.0 [master repo](END) 创建 demo为了方便别人使用，快速上手，最好创建一个 demo，和库放在同一个仓库就可以了. 首先创建一个干净的工程，然后为之编写 Podfile : 123456platform :ios, &apos;7.0&apos;target &apos;SCNDemo&apos; do pod &quot;SCNetworkKit&quot;, &apos;~&gt;1.0.3&apos; pod &apos;SCJSONUtil&apos;, &apos;~&gt;2.4.1&apos;end 接下来使用 pod update 安装pods库，（由于是新库，可能使用 pod install 会失败）； 最后在 demo 里写几个调用库的范例就 OK 了！ 当别人使用 pod try 的时候，就会把你这个 demo 下载到一个临时目录里，如果不提供 demo，别人就无法使用 pod try 尝试你的库！ 更新 pods 库版本你的开源库会越来越稳定，功能也更加的强大，这时就应该考虑升级下 pods 库的版本了，做法很简单： 首先给仓库打个新的标签，标签名就是 pods 库的版本号，比如我的网络库升级到了 1.0.1 了，就打个 1.0.1 的 tag，然后 push 到 github ; 把 podspec 文件里的版本号也更新为 1.0.1，然后推送到 cocoapods 仓库 : 1234567891011121314151617181920212223242526272829pod trunk push SCNetworkKit.podspec Updating spec repo `master`CocoaPods 1.3.0.beta.3 is available.To update use: `sudo gem install cocoapods --pre`[!] This is a test version we&apos;d love you to try.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.0.beta.3Validating podspec -&gt; SCNetworkKit (1.0.1)Updating spec repo `master`CocoaPods 1.3.0.beta.3 is available.To update use: `sudo gem install cocoapods --pre`[!] This is a test version we&apos;d love you to try.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.3.0.beta.3-------------------------------------------------------------------------------- 🎉 Congrats 🚀 SCNetworkKit (1.0.1) successfully published 📅 July 21st, 00:16 🌎 https://cocoapods.org/pods/SCNetworkKit 👍 Tell your friends!-------------------------------------------------------------------------------- 最后把 podspec 文件的更改提交到 github 仓库，不提也没有关系，只是为了方便下次修改而已，因为已经 push 到 cocoapods 仓库里了！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://debugly.cn/tags/CocoaPods/"}]},{"title":"macOS 上安装 CocoaPods","slug":"2017/07/19-install-cocoapods","date":"2017-07-19T02:32:12.000Z","updated":"2018-03-27T14:45:15.696Z","comments":true,"path":"2017/07/19/2017/07/19-install-cocoapods.html","link":"","permalink":"http://debugly.cn/2017/07/19/2017/07/19-install-cocoapods.html","excerpt":"","text":"前面的博客里简单的介绍过 Ruby，我们也知道了如何安装 Ruby 写的程序库，今天要安装的是大名鼎鼎的 CocoaPods ，他也是使用 Ruby 写的！ Install如果没接触过 ruby 的话，最好是先来看下这篇博客里的名词解释 : 使用 Rake 重写打包脚本 使用 gem 命令安装即可 ： sudo gem install cocoapods ；安装过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107Password:Fetching: i18n-0.8.6.gem (100%)Successfully installed i18n-0.8.6Fetching: thread_safe-0.3.6.gem (100%)Successfully installed thread_safe-0.3.6Fetching: tzinfo-1.2.3.gem (100%)Successfully installed tzinfo-1.2.3Fetching: activesupport-4.2.9.gem (100%)Successfully installed activesupport-4.2.9Fetching: nap-1.1.0.gem (100%)Successfully installed nap-1.1.0Fetching: fuzzy_match-2.0.4.gem (100%)Successfully installed fuzzy_match-2.0.4Fetching: cocoapods-core-1.2.1.gem (100%)Successfully installed cocoapods-core-1.2.1Fetching: claide-1.0.2.gem (100%)Successfully installed claide-1.0.2Fetching: cocoapods-deintegrate-1.0.1.gem (100%)Successfully installed cocoapods-deintegrate-1.0.1Fetching: cocoapods-downloader-1.1.3.gem (100%)Successfully installed cocoapods-downloader-1.1.3Fetching: cocoapods-plugins-1.0.0.gem (100%)Successfully installed cocoapods-plugins-1.0.0Fetching: cocoapods-search-1.0.0.gem (100%)Successfully installed cocoapods-search-1.0.0Fetching: cocoapods-stats-1.0.0.gem (100%)Successfully installed cocoapods-stats-1.0.0Fetching: netrc-0.7.8.gem (100%)Successfully installed netrc-0.7.8Fetching: cocoapods-trunk-1.2.0.gem (100%)Successfully installed cocoapods-trunk-1.2.0Fetching: cocoapods-try-1.1.0.gem (100%)Successfully installed cocoapods-try-1.1.0Fetching: molinillo-0.5.7.gem (100%)Successfully installed molinillo-0.5.7Fetching: CFPropertyList-2.3.5.gem (100%)Successfully installed CFPropertyList-2.3.5Fetching: colored2-3.1.2.gem (100%)Successfully installed colored2-3.1.2Fetching: nanaimo-0.2.3.gem (100%)Successfully installed nanaimo-0.2.3Fetching: xcodeproj-1.5.1.gem (100%)Successfully installed xcodeproj-1.5.1Fetching: escape-0.0.4.gem (100%)Successfully installed escape-0.0.4Fetching: fourflusher-2.0.1.gem (100%)Successfully installed fourflusher-2.0.1Fetching: gh_inspector-1.0.3.gem (100%)Successfully installed gh_inspector-1.0.3Fetching: ruby-macho-1.1.0.gem (100%)Successfully installed ruby-macho-1.1.0Fetching: cocoapods-1.2.1.gem (100%)Successfully installed cocoapods-1.2.1Parsing documentation for i18n-0.8.6Installing ri documentation for i18n-0.8.6Parsing documentation for thread_safe-0.3.6Installing ri documentation for thread_safe-0.3.6Parsing documentation for tzinfo-1.2.3Installing ri documentation for tzinfo-1.2.3Parsing documentation for activesupport-4.2.9Installing ri documentation for activesupport-4.2.9Parsing documentation for nap-1.1.0Installing ri documentation for nap-1.1.0Parsing documentation for fuzzy_match-2.0.4Installing ri documentation for fuzzy_match-2.0.4Parsing documentation for cocoapods-core-1.2.1Installing ri documentation for cocoapods-core-1.2.1Parsing documentation for claide-1.0.2Installing ri documentation for claide-1.0.2Parsing documentation for cocoapods-deintegrate-1.0.1Installing ri documentation for cocoapods-deintegrate-1.0.1Parsing documentation for cocoapods-downloader-1.1.3Installing ri documentation for cocoapods-downloader-1.1.3Parsing documentation for cocoapods-plugins-1.0.0Installing ri documentation for cocoapods-plugins-1.0.0Parsing documentation for cocoapods-search-1.0.0Installing ri documentation for cocoapods-search-1.0.0Parsing documentation for cocoapods-stats-1.0.0Installing ri documentation for cocoapods-stats-1.0.0Parsing documentation for netrc-0.7.8Installing ri documentation for netrc-0.7.8Parsing documentation for cocoapods-trunk-1.2.0Installing ri documentation for cocoapods-trunk-1.2.0Parsing documentation for cocoapods-try-1.1.0Installing ri documentation for cocoapods-try-1.1.0Parsing documentation for molinillo-0.5.7Installing ri documentation for molinillo-0.5.7Parsing documentation for CFPropertyList-2.3.5Installing ri documentation for CFPropertyList-2.3.5Parsing documentation for colored2-3.1.2Installing ri documentation for colored2-3.1.2Parsing documentation for nanaimo-0.2.3Installing ri documentation for nanaimo-0.2.3Parsing documentation for xcodeproj-1.5.1Installing ri documentation for xcodeproj-1.5.1Parsing documentation for escape-0.0.4Installing ri documentation for escape-0.0.4Parsing documentation for fourflusher-2.0.1Installing ri documentation for fourflusher-2.0.1Parsing documentation for gh_inspector-1.0.3Installing ri documentation for gh_inspector-1.0.3Parsing documentation for ruby-macho-1.1.0Installing ri documentation for ruby-macho-1.1.0Parsing documentation for cocoapods-1.2.1Installing ri documentation for cocoapods-1.2.1Done installing documentation for i18n, thread_safe, tzinfo, activesupport, nap, fuzzy_match, cocoapods-core, claide, cocoapods-deintegrate, cocoapods-downloader, cocoapods-plugins, cocoapods-search, cocoapods-stats, netrc, cocoapods-trunk, cocoapods-try, molinillo, CFPropertyList, colored2, nanaimo, xcodeproj, escape, fourflusher, gh_inspector, ruby-macho, cocoapods after 16 seconds26 gems installed 如遇到问题，很能是源的问题，可以开启 VPN ，或者替换为下面的源地址： Ruby 社区的 Gem 托管服务: RubyGems.org RubyGems 镜像 gems.ruby-china.org RubyGems 镜像 ruby.taobao.org 查看当前源 ： 123gem sources -l*** CURRENT SOURCES ***https://rubygems.org/ 将官方 rubygems.org 修改为国内的 gems.ruby-china.org 源地址 ： 1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 安装完毕后最好是 pod setup 下，作用是把 CocoaPods 仓库 clone 到本地。 Try可以尝试玩下： 版本 ： pod –version 搜索 ： pod search SCNetworkKit 尝试demo ： pod try SCNetworkKit 更多命令 ： 12345678910111213141516171819+ cache Manipulate the CocoaPods cache+ deintegrate Deintegrate CocoaPods from your project+ env Display pod environment+ init Generate a Podfile for the current directory+ install Install project dependencies according to versions from a Podfile.lock+ ipc Inter-process communication+ lib Develop pods+ list List pods+ outdated Show outdated project dependencies+ plugins Show available CocoaPods plugins+ repo Manage spec-repositories+ search Search for pods+ setup Setup the CocoaPods environment+ spec Manage pod specs+ trunk Interact with the CocoaPods API (e.g. publishing new specs)+ try Try a Pod!+ update Update outdated project dependencies and create new Podfile.lock 可选参数 ： 12345--silent Show nothing--version Show the version of the tool--verbose Show more debugging information--no-ansi Show output without ANSI codes--help Show help banner of specified command","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://debugly.cn/tags/CocoaPods/"}]},{"title":"源码分析 weak 对象自动置空原理","slug":"2017/07/17-objc-weak-obj-imp","date":"2017-07-17T23:40:28.000Z","updated":"2018-03-27T14:45:15.695Z","comments":true,"path":"2017/07/18/2017/07/17-objc-weak-obj-imp.html","link":"","permalink":"http://debugly.cn/2017/07/18/2017/07/17-objc-weak-obj-imp.html","excerpt":"","text":"我们都知道 weak 修饰的变量，在对象释放后，会自动置为 nil，这一机制减少了大量的野指针崩溃；我们还知道在 dealloc 里不要 weak 修饰 self 对象，否则当对象 dealloc 时就会崩溃掉；一起看下源码实现吧! 下载源码虽然 iOS 不是开源的，但是 OBJC 这部分代码是 Open的，下载地址 : objc4-709.tar.gz 。这是第二次阅读 objc 源码，第一次是分析关联引用实现原理时阅读的 : 深入理解关联引用;我猜测 weak 的实现和关联对象应该是大同小异的，思路上应该是相同的，应该也是在创建后存表，dealloc 时置空，然后从表里移除掉。 注册 weak 变量初始化一个 weak 指针时会走 objc_initWeak 函数: 123456789101112131415161718192021222324252627/** * Initialize a fresh weak pointer to some object location. * It would be used for code like: * * (The nil case) * __weak id weakPtr; * (The non-nil case) * NSObject *o = ...; * __weak id weakPtr = o; * * This function IS NOT thread-safe with respect to concurrent * modifications to the weak variable. (Concurrent weak clear is safe.) * * @param location Address of __weak ptr. * @param newObj Object ptr. */ id objc_initWeak(id *location, id newObj)&#123; if (!newObj) &#123; *location = nil; return nil; &#125; return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);&#125; 内部会走 objc_storeWeak 方法来存储你声明的 weak 变量 : 123456789101112131415/** * This function stores a new value into a __weak variable. It would * be used anywhere a __weak variable is the target of an assignment. * * @param location The address of the weak pointer itself * @param newObj The new object this weak ptr should now point to * * @return newObj */id objc_storeWeak(id *location, id newObj)&#123; return storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object *)newObj);&#125; 内部则调用了 storeWeak 这个函数，其实这个注释已经说的很明白了，如果 CrashIfDeallocating 是 true 的话，当 newObj 正在 dealloc 或者 newObj 不支持 weak 就会崩溃！调用的时候传的是枚举值 DoCrashIfDeallocating，正是 true ！所以上一篇博客里提到的在 dealloc 里使用 weak self 会崩溃，立即 传送 ！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// Update a weak variable.// If HaveOld is true, the variable has an existing value // that needs to be cleaned up. This value might be nil.// If HaveNew is true, there is a new value that needs to be // assigned into the variable. This value might be nil.// If CrashIfDeallocating is true, the process is halted if newObj is // deallocating or newObj's class does not support weak references. // If CrashIfDeallocating is false, nil is stored instead.enum CrashIfDeallocating &#123; DontCrashIfDeallocating = false, DoCrashIfDeallocating = true&#125;;template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt; static id storeWeak(id *location, objc_object *newObj)&#123; assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: if (haveOld) &#123; oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); if (haveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; &#125; // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (haveNew &amp;&amp; newObj) &#123; Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. previouslyInitializedClass = cls; goto retry; &#125; &#125; // Clean up old value, if any. if (haveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // Assign new value, if any. if (haveNew) &#123; newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj; &#125; else &#123; // No new value. The storage is not changed. &#125; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 内部调用 weak_register_no_lock 注册一个 weak指针和对象的键值对，然后返回；如果注册的时候发现该对象正在 dealloc 则会崩溃，并且通过 _objc_fatal 方法留了遗言！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Registers a new (object, weak pointer) pair. Creates a new weak * object entry if it does not exist. * * @param weak_table The global weak table. * @param referent The object pointed to by the weak reference. * @param referrer The weak pointer address. */id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); &#125; if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; else &#123; weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; 这里只能猜测 runtime 是通过引用计数是否为 0 来判断一个对象是否是处于 deallocing 状态的，因为 SEL_allowsWeakReference 这个函数的定义是找不到的！但是我们从源码上可以确切的了解到，如果对象正在 deallocing 不能让他使用 weak 修饰！否者就崩溃掉了！！ 12345678910if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal(&quot;Cannot form weak reference to instance (%p) of &quot; &quot;class %s. It is possible that this object was &quot; &quot;over-released, or is in the process of deallocation.&quot;, (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125;&#125; objc 里封装了 _objc_fatal 这个函数用于停止程序，并且搞个遗言，内部则是调用了 _objc_fatalv 12345678void _objc_fatal(const char *fmt, ...)&#123; va_list ap; va_start(ap,fmt); _objc_fatalv(OBJC_EXIT_REASON_UNSPECIFIED, OS_REASON_FLAG_ONE_TIME_FAILURE, fmt, ap);&#125; _objc_fatalv 属于内部私有方法，可以正常 exit，也可以 abort，取决于 DebugDontCrash 12345678910111213141516171819void _objc_fatalv(uint64_t reason, uint64_t flags, const char *fmt, va_list ap)&#123; char *buf1; vasprintf(&amp;buf1, fmt, ap); char *buf2; asprintf(&amp;buf2, \"objc[%d]: %s\\n\", getpid(), buf1); _objc_syslog(buf2); if (DebugDontCrash) &#123; char *buf3; asprintf(&amp;buf3, \"objc[%d]: HALTED\\n\", getpid()); _objc_syslog(buf3); _Exit(1); &#125; else &#123; abort_with_reason(OS_REASON_OBJC, reason, buf1, flags); &#125;&#125; 上面的流程大致是将 weak 描述的变量存起来的过程，我们再挖掘下对象释放后，weak 变量自动置空的逻辑: dealloc 时清理掉 weak 变量既然我们知道了结论，那么就直接从 dealloc 开始看方法调用吧: 123456789101112131415161718192021222324252627282930313233343536- (void)dealloc &#123; _objc_rootDealloc(self);&#125;void _objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125;inline void objc_object::rootDealloc()&#123; if (isTaggedPointer()) return; object_dispose((id)this);&#125;id object_dispose(id obj) &#123; return (*_dealloc)(obj); &#125;///注意 _dealloc 其实就是 _object_disposeid (*_dealloc)(id) = _object_dispose;static id _object_dispose(id anObject) &#123; if (anObject==nil) return nil; objc_destructInstance(anObject); anObject-&gt;initIsa(_objc_getFreedObjectClass ()); free(anObject); return nil;&#125; 看注释可以知道，这个方法是干清理的工作的，不释放对象的内存；具体是清理关联应用的对象和存储的 weak 指针 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory. * Calls C++ destructors.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.* CoreFoundation and other clients do call this under GC.**********************************************************************/void *objc_destructInstance(id obj) &#123; if (obj) &#123; Class isa = obj-&gt;getIsa(); if (isa-&gt;hasCxxDtor()) &#123; object_cxxDestruct(obj); &#125; ///之前看关联引用的时候，已经看过这个方法 if (isa-&gt;instancesHaveAssociatedObjects()) &#123; _object_remove_assocations(obj); &#125; ///今天来看下清理 weak 指针的方法吧 objc_clear_deallocating(obj); &#125; return obj;&#125;void objc_clear_deallocating(id obj) &#123; assert(obj); if (obj-&gt;isTaggedPointer()) return; obj-&gt;clearDeallocating();&#125;inline void objc_object::clearDeallocating()&#123; sidetable_clearDeallocating();&#125;void objc_object::sidetable_clearDeallocating()&#123; SideTable&amp; table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; if (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; table.refcnts.erase(it); &#125; table.unlock();&#125;/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn&apos;t happen, but does with mismatched CF/objc //printf(&quot;XXX no entry for clear deallocating %p\\n&quot;, referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot; &quot;This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\\n&quot;, referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 找了半天，我们想看到的代码无非是在dealloc里执行置空和从table里移除： 1234if (*referrer == referent) &#123; *referrer = nil;&#125;weak_entry_remove(weak_table, entry); 截止到今日，了解了对象 dealloc 时系统框架到底做了什么，清楚的知道了关联引用对象的生命周期和 weak 变量置空的原理，对于日后修改一些问题，实现某些特性的逻辑(网络库里的自动取消就是通过关联引用做的，利用了对象释放时，自动释放关联对象这一特性)，就更加有把握了！ 注：objc 的源码是一直在更新的，如果你看的不是 objc4-709.tar.gz 这个包的话，可能源码与我贴的有差异！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"在 dealloc 里使用 weak self 引起崩溃？","slug":"2017/07/17-weakself-in-dealloc-cause-crash","date":"2017-07-17T06:43:15.000Z","updated":"2018-03-27T14:45:15.695Z","comments":true,"path":"2017/07/17/2017/07/17-weakself-in-dealloc-cause-crash.html","link":"","permalink":"http://debugly.cn/2017/07/17/2017/07/17-weakself-in-dealloc-cause-crash.html","excerpt":"","text":"我们都知道 weak 修饰的变量，在对象释放后，会自动置为 nil，这一机制减少了大量的野指针崩溃；可是如果你在对象的 dealloc 里使用 weak 修饰 self 会如何呢 ？答案是崩溃 ~_~ 最近我们 SDK 在集成到某个 App 之后，就遇到了这样的问题，一起看下吧！ 先看下解析后的崩溃日志吧： 12345678910111213141516Thread 0 Crashed:0 libsystem_kernel.dylib 0x0000000182c1987c __terminate_with_payload + 81 libsystem_kernel.dylib 0x0000000182c144f0 abort_with_payload + 02 libsystem_kernel.dylib 0x0000000182c1446c abort_with_payload_wrapper_internal + 03 libobjc.A.dylib 0x000000018267fea4 _objc_fatalv(unsigned long long, unsigned long long, char const*, char*) + 1124 libobjc.A.dylib 0x000000018267fdfc __objc_error + 05 libobjc.A.dylib 0x0000000182693edc weak_entry_insert(weak_table_t*, weak_entry_t*) + 06 libobjc.A.dylib 0x000000018269c3ac objc_storeWeak + 3327 SOHUVideo 0x00000001004b5ba0 -[SharePopView setDelegate:] (SharePopView.h:31)8 SOHUVideo 0x00000001003ce7c8 -[ShareViewController shareView] (ShareViewController.m:70)9 SOHUVideo 0x00000001003ce2a0 -[ShareViewController dealloc] (ShareViewController.m:43)10 UIKit 0x000000018a0a5960 -[UIPresentationController .cxx_destruct] + 31211 libobjc.A.dylib 0x000000018267ef00 object_cxxDestructFromClass(objc_object*, objc_class*) + 14812 libobjc.A.dylib 0x000000018268c334 objc_destructInstance + 9213 libobjc.A.dylib 0x000000018268c398 object_dispose + 2814 UIKit 0x000000018a0a1348 -[UIPresentationController dealloc] + 64 如果连着线直接 debug 的话，可能控制台只输出了这样一句话，并且代码定位到使用 weak self 那一行，此时可以使用 bt 打印堆栈信息，打出来跟上面是一样: 1objc[78013]: Cannot form weak reference to instance (0x7fbc9287e840) of class ShareViewController. It is possible that this object was over-released, or is in the process of deallocation. 接下来我们一行一行的分析崩溃日志，然后确定问题，这是函数调用栈，因此先走的方法在下面，最上面的是最后走的方法，因此我们倒着来看，从第 9 行看就好了： 1234567899 : ShareViewController 的 dealloc 走了8 : 访问了 ShareViewController 对象的属性 shareView7 : 给 shareView 设置了代理对象6 : 看库名知道这是走到了 objc 底层了，看方法名知道这个操作应该是要存储一个 weak 修饰的对象5 : 将 weak entry 插入到 table 里4 : 遇到了错误3 : 处理致命错误2 : 代码继续往下走，objc 交给了 system 处理1 : 系统终结了你的程序 底层的错误肯定是上层调用错误引起的，因此我们只看 App 层最后一个方法调用，那就是 [SharePopView setDelegate:]，源码是这样写的: 1234567891011121314151617181920- (void)dealloc &#123; self.shareView.delegate = nil; self.shareView = nil;&#125;- (SharePopView *)shareView &#123; if (!_shareView) &#123; CGFloat height = titleHeight + ShareIconViewHeightForSL * 2 + bottomTitleHeight + cancelButtonHeight; _shareView = [[SharePopView alloc] initWithFrame:CGRectMake(0, DeviceHeight - height, DeviceWidth, height)]; _shareView.delegate = self;///连着线调试时，崩溃后定位到了这一行！！！ &#125; return _shareView;&#125;@interface SharePopView : UIView////这里使用的是 weak 修饰的@property (nonatomic, weak) id&lt;SharePopupViewDelegate&gt; delegate;@end 我看到这个代码的第一反应是，dealloc 不应该使用 self 打点访问懒加载的属性，我也经常重写 get 方法来懒加载，因此我对于这个很敏感，因为对象正在释放，没有创建相关属性的必要了，这里之所以崩溃，是因为创建对象之后，立马指定了 self 为代理，并且是 weak 的，从崩溃堆栈信息也能看出，设置了weak修饰的代理后，objc 底层对 self 进行了处理，在处理的时候，发现不对劲，然后就 abort 了！！ ps : 不管是使用 weak 修饰的属性，还是使用 __weak 修饰的变量，objc 都会对这个变量处理，也只有这样才能让修饰对象在释放之后，自动置空！ 看到源码问题就好解决了，加个判断就行了，不要懒加载去创建，而是判断下，如果创建过就将代理置空，这样就避免了在 dealloc 里使用 weak 修饰 self 对象！ 123456- (void)dealloc &#123; if(_shareView)&#123; _shareView.delegate = nil; _shareView = nil; &#125;&#125; 问题是解决了，可是还没搞明白底层 objc 的处理流程呢，有兴趣的话接着往下看吧：源码分析 weak 对象置空原理.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"macOS 上安装 Jekyll","slug":"2017/06/21-install-jekyll-macos","date":"2017-06-21T13:31:49.000Z","updated":"2018-03-27T14:45:15.695Z","comments":true,"path":"2017/06/21/2017/06/21-install-jekyll-macos.html","link":"","permalink":"http://debugly.cn/2017/06/21/2017/06/21-install-jekyll-macos.html","excerpt":"","text":"我的 MBP 重装回 macOS Sierra 之后，博客系统也就需要重新搭建了，因此趁这个机会，顺便整理下在 macOS 上安装 Jekyll 的详细过程。 检查 Ruby 版本因为 Jekyll 是使用 Rake 编写的，所以最 Ruby 版本是有要求的，最新 3.5 则需要 Ruby 2.1.0 以上版本才行！ ruby -v 12///我刚升级的2.2.6ruby 2.2.6p396 (2016-11-15 revision 56800) [x86_64-darwin16] 如果你的版本是 2.1.0 之前的，可参看我的这篇博客《使用 RVM 更新 Ruby 版本》，先升级下 Ruby，再来往下看。 检查 Command Line Tools可以说要想在 Mac 使用终端，搞开发相关的东西，不装 Command Line Tools 是不可能的，使用命令 xcode-select -p 检查： 123/Applications/Xcode.app/Contents/Developer或者/Library/Developer/CommandLineTools 如果看到这两个其中一个就表示已经安装了，无需再装；如果不安装 Command Line Tools，就直接装 Jekyll 的话，会报如下错误： 123456789101112131415161718192021222324252627282930gem install jekyll bundlerPassword:Fetching: public_suffix-2.0.5.gem (100%)Successfully installed public_suffix-2.0.5Fetching: addressable-2.5.1.gem (100%)Successfully installed addressable-2.5.1Fetching: colorator-1.1.0.gem (100%)Successfully installed colorator-1.1.0Fetching: sass-3.4.24.gem (100%)Successfully installed sass-3.4.24Fetching: jekyll-sass-converter-1.5.0.gem (100%)Successfully installed jekyll-sass-converter-1.5.0Fetching: rb-fsevent-0.9.8.gem (100%)Successfully installed rb-fsevent-0.9.8Fetching: ffi-1.9.18.gem (100%)Building native extensions. This could take a while...ERROR: Error installing jekyll: ERROR: Failed to build gem native extension. /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rbmkmf.rb can't find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/include/ruby.hGem files will remain installed in /Library/Ruby/Gems/2.0.0/gems/ffi-1.9.18 for inspection.Results logged to /Library/Ruby/Gems/2.0.0/gems/ffi-1.9.18/ext/ffi_c/gem_make.outFetching: bundler-1.15.1.gem (100%)Successfully installed bundler-1.15.1Parsing documentation for bundler-1.15.1Installing ri documentation for bundler-1.15.11 gem installed 在 OS X 10.9 之后有两种方法可选，一种是安装 Xcode，一种是单独安装 Command Line Tools，这个玩意之前是捆绑在 Xcode 里的！由于我日后需要使用 Xcode 开发，因此我选择安装 Xcode，让我纳闷的是，我移动硬盘里有 Xcode 7.3.1 的安装文件，直接安装后，仍旧报错： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Building native extensions. This could take a while...ERROR: Error installing jekyll: ERROR: Failed to build gem native extension. /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rbchecking for ffi.h... *** extconf.rb failed ***Could not create Makefile due to some reason, probably lack of necessarylibraries and/or headers. Check the mkmf.log file for more details. You mayneed configuration options.Provided configuration options: --with-opt-dir --without-opt-dir --with-opt-include --without-opt-include=$&#123;opt-dir&#125;/include --with-opt-lib --without-opt-lib=$&#123;opt-dir&#125;/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby --with-ffi_c-dir --without-ffi_c-dir --with-ffi_c-include --without-ffi_c-include=$&#123;ffi_c-dir&#125;/include --with-ffi_c-lib --without-ffi_c-lib=$&#123;ffi_c-dir&#125;/ --with-libffi-config --without-libffi-config --with-pkg-config --without-pkg-config/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:434:in `try_do': The compiler failed to generate an executable file. (RuntimeError)You have to install development tools first. from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:549:in `block in try_compile' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:502:in `with_werror' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:549:in `try_compile' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:1038:in `block in have_header' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:889:in `block in checking_for' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:340:in `block (2 levels) in postpone' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:310:in `open' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:340:in `block in postpone' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:310:in `open' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:336:in `postpone' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:888:in `checking_for' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/mkmf.rb:1037:in `have_header' from extconf.rb:16:in `&lt;main&gt;'Gem files will remain installed in /Library/Ruby/Gems/2.0.0/gems/ffi-1.9.18 for inspection.Results logged to /Library/Ruby/Gems/2.0.0/gems/ffi-1.9.18/ext/ffi_c/gem_make.outSuccessfully installed bundler-1.15.1Parsing documentation for bundler-1.15.11 gem installed 不过这次报错，可以明确找到原因：(RuntimeError) You have to install development tools first. 所以接下来老老实实地去安装 Command Line Tools 吧！ 安装 Command Line Tools在终端执行 xcode-select --install 后会弹出界面： 我选择了获取 Xcode，然后就自动打开了 AppStore ，然后点击下载安装就行了，只不过需要等上二十分钟了就 OK 了，Xcode安装成功后，记得启动下，因为启动后还会加载一些东西，确保万无一失，最好启动下，然后到 Xcdoe -&gt; Perferences -&gt; Locations 查看下 … 我查了下网上也有人遇到过类似的错误： https://stackoverflow.com/questions/27768420/gem-installation-error-you-have-to-install-development-tools-first https://github.com/ffi/ffi/issues/286 https://kevinpotgieter.wordpress.com/2012/12/06/ruby-gem-install-mkmf-rb-cant-find-header-files-for-ruby-problem/ 安装 Jekyll如果你的 Ruby 版本小于 2.1.0 的话，就会报如下错误了： 123456789101112131415161718bogon:~ xuqianlong$ sudo gem install jekyll bundlerPassword:Building native extensions. This could take a while...Successfully installed ffi-1.9.18Fetching: rb-inotify-0.9.10.gem (100%)Successfully installed rb-inotify-0.9.10Fetching: listen-3.0.8.gem (100%)Successfully installed listen-3.0.8Fetching: jekyll-watch-1.5.0.gem (100%)Successfully installed jekyll-watch-1.5.0Fetching: kramdown-1.13.2.gem (100%)Successfully installed kramdown-1.13.2Fetching: liquid-4.0.0.gem (100%)ERROR: Error installing jekyll: liquid requires Ruby version &gt;= 2.1.0.Successfully installed bundler-1.15.1Parsing documentation for bundler-1.15.11 gem installed 如果是按照上述步骤来的，那么你应该能够正常的安装： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Last login: Tue Jun 20 22:21:06 on ttys000bogon:~ xuqianlong$ gem install jekyll bundlerFetching: public_suffix-2.0.5.gem (100%)Successfully installed public_suffix-2.0.5Fetching: addressable-2.5.1.gem (100%)Successfully installed addressable-2.5.1Fetching: colorator-1.1.0.gem (100%)Successfully installed colorator-1.1.0Fetching: sass-3.4.24.gem (100%)Successfully installed sass-3.4.24Fetching: jekyll-sass-converter-1.5.0.gem (100%)Successfully installed jekyll-sass-converter-1.5.0Fetching: rb-fsevent-0.9.8.gem (100%)Successfully installed rb-fsevent-0.9.8Fetching: ffi-1.9.18.gem (100%)Building native extensions. This could take a while...Successfully installed ffi-1.9.18Fetching: rb-inotify-0.9.10.gem (100%)Successfully installed rb-inotify-0.9.10Fetching: listen-3.0.8.gem (100%)Successfully installed listen-3.0.8Fetching: jekyll-watch-1.5.0.gem (100%)Successfully installed jekyll-watch-1.5.0Fetching: kramdown-1.13.2.gem (100%)Successfully installed kramdown-1.13.2Fetching: liquid-4.0.0.gem (100%)Successfully installed liquid-4.0.0Fetching: mercenary-0.3.6.gem (100%)Successfully installed mercenary-0.3.6Fetching: forwardable-extended-2.6.0.gem (100%)Successfully installed forwardable-extended-2.6.0Fetching: pathutil-0.14.0.gem (100%)Successfully installed pathutil-0.14.0Fetching: rouge-1.11.1.gem (100%)Successfully installed rouge-1.11.1Fetching: safe_yaml-1.0.4.gem (100%)Successfully installed safe_yaml-1.0.4Fetching: jekyll-3.5.0.gem (100%)Successfully installed jekyll-3.5.0Parsing documentation for public_suffix-2.0.5Installing ri documentation for public_suffix-2.0.5Parsing documentation for addressable-2.5.1Installing ri documentation for addressable-2.5.1Parsing documentation for colorator-1.1.0Installing ri documentation for colorator-1.1.0Parsing documentation for sass-3.4.24Installing ri documentation for sass-3.4.24Parsing documentation for jekyll-sass-converter-1.5.0Installing ri documentation for jekyll-sass-converter-1.5.0Parsing documentation for rb-fsevent-0.9.8Installing ri documentation for rb-fsevent-0.9.8Parsing documentation for ffi-1.9.18Installing ri documentation for ffi-1.9.18Parsing documentation for rb-inotify-0.9.10Installing ri documentation for rb-inotify-0.9.10Parsing documentation for listen-3.0.8Installing ri documentation for listen-3.0.8Parsing documentation for jekyll-watch-1.5.0Installing ri documentation for jekyll-watch-1.5.0Parsing documentation for kramdown-1.13.2Installing ri documentation for kramdown-1.13.2Parsing documentation for liquid-4.0.0Installing ri documentation for liquid-4.0.0Parsing documentation for mercenary-0.3.6Installing ri documentation for mercenary-0.3.6Parsing documentation for forwardable-extended-2.6.0Installing ri documentation for forwardable-extended-2.6.0Parsing documentation for pathutil-0.14.0Installing ri documentation for pathutil-0.14.0Parsing documentation for rouge-1.11.1Installing ri documentation for rouge-1.11.1Parsing documentation for safe_yaml-1.0.4Installing ri documentation for safe_yaml-1.0.4Parsing documentation for jekyll-3.5.0Installing ri documentation for jekyll-3.5.0Done installing documentation for public_suffix, addressable, colorator, sass, jekyll-sass-converter, rb-fsevent, ffi, rb-inotify, listen, jekyll-watch, kramdown, liquid, mercenary, forwardable-extended, pathutil, rouge, safe_yaml, jekyll after 30 secondsFetching: bundler-1.15.1.gem (100%)Successfully installed bundler-1.15.1Parsing documentation for bundler-1.15.1Installing ri documentation for bundler-1.15.1Done installing documentation for bundler after 5 seconds19 gems installed 检查 Jekyll 是否安装成功jekyll -v 终端会输出版本号：jekyll 3.5.0，接下来就可以创建自己的博客站点了！ 123jekyll new my-awesome-site~ $ cd my-awesome-site~/my-awesome-site $ bundle exec jekyll serve 这些操作我开了 VPN，如果不开的话，可能会出现不能安装某些gem的问题，这个需要换下 RubyGems 源，具体可查看淘宝的源 https://ruby.taobao.org/ Good Luck …","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"},{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"使用 RVM 更新 Ruby 版本","slug":"2017/06/20-update-ruby-use-rvm","date":"2017-06-20T14:31:19.000Z","updated":"2018-03-27T14:45:15.694Z","comments":true,"path":"2017/06/20/2017/06/20-update-ruby-use-rvm.html","link":"","permalink":"http://debugly.cn/2017/06/20/2017/06/20-update-ruby-use-rvm.html","excerpt":"","text":"我的 MBP 重装回 macOS Sierra 之后，系统自带的 Ruby 环境为 ruby 2.0.0p648 (2015-12-16 revision 53162)，我要安装 Jekyll，其中一个 gem 对 Ruby 版本有要求，必须是 2.1.0 以后版本才行！（liquid requires Ruby version &gt;= 2.1.0.）我选择了 RVM 管理 Ruby 版本。 安装 RVM简单理解下：RVM 管理 Ruby 版本的工具，具体 Ruby 版本通过 homebrew 去下载获取。接下来安装 RVM： \\curl -sSL https://get.rvm.io | bash -s stable 安装过程： 123456789101112131415161718192021Downloading https://github.com/rvm/rvm/archive/1.29.1.tar.gzDownloading https://github.com/rvm/rvm/releases/download/1.29.1/1.29.1.tar.gz.ascFound PGP signature at: 'https://github.com/rvm/rvm/releases/download/1.29.1/1.29.1.tar.gz.asc',but no GPG software exists to validate it, skipping.Installing RVM to /Users/xuqianlong/.rvm/ Adding rvm PATH line to /Users/xuqianlong/.profile /Users/xuqianlong/.mkshrc /Users/xuqianlong/.bashrc /Users/xuqianlong/.zshrc. Adding rvm loading line to /Users/xuqianlong/.profile /Users/xuqianlong/.bash_profile /Users/xuqianlong/.zlogin.Installation of RVM in /Users/xuqianlong/.rvm/ is almost complete: * To start using RVM you need to run `source /Users/xuqianlong/.rvm/scripts/rvm` in all your open shell windows, in rare cases you need to reopen all shell windows.# xuqianlong,## Thank you for using RVM!# We sincerely hope that RVM helps to make your life easier and more enjoyable!!!## ~Wayne, Michal &amp; team.In case of problems: https://rvm.io/help and https://twitter.com/rvm_io 更新 Ruby安装好 RVM 之后，path 还没有生效，因此直接执行： rvm list known 可能会报错： -bash: rvm: command not found 这时重新开个新的终端窗口即可；这次执行结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bogon:~ xuqianlong$ rvm list known# MRI Rubies[ruby-]1.8.6[-p420][ruby-]1.8.7[-head] # security released on head[ruby-]1.9.1[-p431][ruby-]1.9.2[-p330][ruby-]1.9.3[-p551][ruby-]2.0.0[-p648][ruby-]2.1[.10][ruby-]2.2[.6][ruby-]2.3[.3][ruby-]2.4[.0]ruby-head# for forks use: rvm install ruby-head-&lt;name&gt; --url https://github.com/github/ruby.git --branch 2.2# JRubyjruby-1.6[.8]jruby-1.7[.26]jruby[-9.1.7.0]jruby-head# Rubiniusrbx-1[.4.3]rbx-2.3[.0]rbx-2.4[.1]rbx-2[.5.8]rbx[-3.71]rbx-head# Opalopal# Minimalistic ruby implementation - ISO 30170:2012mruby-1.0.0mruby-1.1.0mruby-1[.2.0]mruby[-head]# Ruby Enterprise Editionree-1.8.6ree[-1.8.7][-2012.02]# Topaztopaz# MagLevmaglev[-head]maglev-1.0.0# Mac OS X Snow Leopard Or Newermacruby-0.10macruby-0.11macruby[-0.12]macruby-nightlymacruby-head# IronRubyironruby[-1.1.3]ironruby-head 我不想安装那么新的版本，日后也要安装 CocoPods，他的最低要求版本是 2.2，所以我选择安装 2.2.6 版本: bogon:~ xuqianlong$ rvm install ruby-2.2.6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161Searching for binary rubies, this might take some time.No binary rubies available for: osx/10.12/x86_64/ruby-2.2.6.Continuing with compilation. Please read 'rvm help mount' to get more information on binary rubies.Checking requirements for osx.About to install Homebrew, press `Enter` for default installation in `/usr/local`,type new path if you wish custom Homebrew installation (the path needs to be writable for user):==&gt; This script will install:/usr/local/bin/brew/usr/local/share/doc/homebrew/usr/local/share/man/man1/brew.1/usr/local/share/zsh/site-functions/_brew/usr/local/etc/bash_completion.d/brew/usr/local/Homebrew==&gt; The following existing directories will be made group writable:/usr/local/bin==&gt; The following existing directories will have their owner set to xuqianlong:/usr/local/bin==&gt; The following existing directories will have their group set to admin:/usr/local/bin==&gt; The following new directories will be created:/usr/local/Cellar/usr/local/Homebrew/usr/local/Frameworks/usr/local/etc/usr/local/include/usr/local/lib/usr/local/opt/usr/local/sbin/usr/local/share/usr/local/share/zsh/usr/local/share/zsh/site-functions/usr/local/varPress RETURN to continue or any other key to abort==&gt; /usr/bin/sudo /bin/chmod u+rwx /usr/local/binPassword:==&gt; /usr/bin/sudo /bin/chmod g+rwx /usr/local/bin==&gt; /usr/bin/sudo /usr/sbin/chown xuqianlong /usr/local/bin==&gt; /usr/bin/sudo /usr/bin/chgrp admin /usr/local/bin==&gt; /usr/bin/sudo /bin/mkdir -p /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/var==&gt; /usr/bin/sudo /bin/chmod g+rwx /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/var==&gt; /usr/bin/sudo /bin/chmod 755 /usr/local/share/zsh /usr/local/share/zsh/site-functions==&gt; /usr/bin/sudo /usr/sbin/chown xuqianlong /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/var==&gt; /usr/bin/sudo /usr/bin/chgrp admin /usr/local/Cellar /usr/local/Homebrew /usr/local/Frameworks /usr/local/etc /usr/local/include /usr/local/lib /usr/local/opt /usr/local/sbin /usr/local/share /usr/local/share/zsh /usr/local/share/zsh/site-functions /usr/local/var==&gt; /usr/bin/sudo /bin/mkdir -p /Users/xuqianlong/Library/Caches/Homebrew==&gt; /usr/bin/sudo /bin/chmod g+rwx /Users/xuqianlong/Library/Caches/Homebrew==&gt; /usr/bin/sudo /usr/sbin/chown xuqianlong /Users/xuqianlong/Library/Caches/Homebrew==&gt; /usr/bin/sudo /bin/mkdir -p /Library/Caches/Homebrew==&gt; /usr/bin/sudo /bin/chmod g+rwx /Library/Caches/Homebrew==&gt; /usr/bin/sudo /usr/sbin/chown xuqianlong /Library/Caches/Homebrew==&gt; Downloading and installing Homebrew...remote: Counting objects: 6463, done.remote: Compressing objects: 100% (3911/3911), done.remote: Total 6463 (delta 3738), reused 4283 (delta 2347), pack-reused 0Receiving objects: 100% (6463/6463), 3.58 MiB | 231.00 KiB/s, done.Resolving deltas: 100% (3738/3738), done.From https://github.com/Homebrew/brew * [new branch] master -&gt; origin/master * [new tag] 0.1 -&gt; 0.1 * [new tag] 0.2 -&gt; 0.2 * [new tag] 0.3 -&gt; 0.3 * [new tag] 0.4 -&gt; 0.4 * [new tag] 0.5 -&gt; 0.5 * [new tag] 0.6 -&gt; 0.6 * [new tag] 0.7 -&gt; 0.7 * [new tag] 0.7.1 -&gt; 0.7.1 * [new tag] 0.8 -&gt; 0.8 * [new tag] 0.8.1 -&gt; 0.8.1 * [new tag] 0.9 -&gt; 0.9 * [new tag] 0.9.1 -&gt; 0.9.1 * [new tag] 0.9.2 -&gt; 0.9.2 * [new tag] 0.9.3 -&gt; 0.9.3 * [new tag] 0.9.4 -&gt; 0.9.4 * [new tag] 0.9.5 -&gt; 0.9.5 * [new tag] 0.9.8 -&gt; 0.9.8 * [new tag] 0.9.9 -&gt; 0.9.9 * [new tag] 1.0.0 -&gt; 1.0.0 * [new tag] 1.0.1 -&gt; 1.0.1 * [new tag] 1.0.2 -&gt; 1.0.2 * [new tag] 1.0.3 -&gt; 1.0.3 * [new tag] 1.0.4 -&gt; 1.0.4 * [new tag] 1.0.5 -&gt; 1.0.5 * [new tag] 1.0.6 -&gt; 1.0.6 * [new tag] 1.0.7 -&gt; 1.0.7 * [new tag] 1.0.8 -&gt; 1.0.8 * [new tag] 1.0.9 -&gt; 1.0.9 * [new tag] 1.1.0 -&gt; 1.1.0 * [new tag] 1.1.1 -&gt; 1.1.1 * [new tag] 1.1.10 -&gt; 1.1.10 * [new tag] 1.1.11 -&gt; 1.1.11 * [new tag] 1.1.12 -&gt; 1.1.12 * [new tag] 1.1.13 -&gt; 1.1.13 * [new tag] 1.1.2 -&gt; 1.1.2 * [new tag] 1.1.3 -&gt; 1.1.3 * [new tag] 1.1.4 -&gt; 1.1.4 * [new tag] 1.1.5 -&gt; 1.1.5 * [new tag] 1.1.6 -&gt; 1.1.6 * [new tag] 1.1.7 -&gt; 1.1.7 * [new tag] 1.1.8 -&gt; 1.1.8 * [new tag] 1.1.9 -&gt; 1.1.9 * [new tag] 1.2.0 -&gt; 1.2.0 * [new tag] 1.2.1 -&gt; 1.2.1 * [new tag] 1.2.2 -&gt; 1.2.2 * [new tag] 1.2.3 -&gt; 1.2.3HEAD is now at 80ce43d Merge pull request #2776 from GauthamGoli/audit_checksum_rubocop_fix==&gt; Tapping homebrew/coreCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core'...remote: Counting objects: 4444, done.remote: Compressing objects: 100% (4245/4245), done.remote: Total 4444 (delta 35), reused 463 (delta 13), pack-reused 0Receiving objects: 100% (4444/4444), 3.53 MiB | 93.00 KiB/s, done.Resolving deltas: 100% (35/35), done.Tapped 4243 formulae (4,487 files, 11MB)==&gt; Cleaning up /Library/Caches/Homebrew...==&gt; Migrating /Library/Caches/Homebrew to /Users/xuqianlong/Library/Caches/Homeb==&gt; Deleting /Library/Caches/Homebrew...Already up-to-date.==&gt; Installation successful!==&gt; Homebrew has enabled anonymous aggregate user behaviour analytics.Read the analytics documentation (and how to opt-out) here: http://docs.brew.sh/Analytics.html==&gt; Next steps:- Run `brew help` to get started- Further documentation: http://docs.brew.shInstalling requirements for osx.Updating system.........Installing required packages: autoconf, automake, libtool, pkg-config, coreutils, libyaml, readline, libksba, openssl..........Certificates in '/usr/local/etc/openssl/cert.pem' are already up to date.Requirements installation successful.Installing Ruby from source to: /Users/xuqianlong/.rvm/rubies/ruby-2.2.6, this may take a while depending on your cpu(s)...ruby-2.2.6 - #downloading ruby-2.2.6, this may take a while depending on your connection... % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 12.7M 100 12.7M 0 0 4958k 0 0:00:02 0:00:02 --:--:-- 4958kruby-2.2.6 - #extracting ruby-2.2.6 to /Users/xuqianlong/.rvm/src/ruby-2.2.6...-ruby-2.2.6 - #configuring......................................................-ruby-2.2.6 - #post-configuration.ruby-2.2.6 - #compiling........................................................-ruby-2.2.6 - #installing..........ruby-2.2.6 - #making binaries executable..ruby-2.2.6 - #downloading rubygems-2.6.12 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 749k 100 749k 0 0 858k 0 --:--:-- --:--:-- --:--:-- 858kNo checksum for downloaded archive, recording checksum in user configuration.ruby-2.2.6 - #extracting rubygems-2.6.12....ruby-2.2.6 - #removing old rubygems.........ruby-2.2.6 - #installing rubygems-2.6.12.........................ruby-2.2.6 - #gemset created /Users/xuqianlong/.rvm/gems/ruby-2.2.6@globalruby-2.2.6 - #importing gemset /Users/xuqianlong/.rvm/gemsets/global.gems......|ruby-2.2.6 - #generating global wrappers........ruby-2.2.6 - #gemset created /Users/xuqianlong/.rvm/gems/ruby-2.2.6ruby-2.2.6 - #importing gemsetfile /Users/xuqianlong/.rvm/gemsets/default.gems evaluated to empty gem listruby-2.2.6 - #generating default wrappers........ruby-2.2.6 - #adjusting #shebangs for (gem irb erb ri rdoc testrb rake).Install of ruby-2.2.6 - #completeRuby was built without documentation, to build it run: rvm docs generate-ri 查看版本： 12bogon:~ xuqianlong$ ruby -vruby 2.2.6p396 (2016-11-15 revision 56800) Ruby 版本已经成功升级，接下来就可以安装 Jekyll, CocoPods 这些库了。 可能出现的错误1、在执行 rvm install ruby-2.2.6 的过程中可能会出错，比如这个: 123456789101112131415161718192021222324Searching for binary rubies, this might take some time.No binary rubies available for: osx/10.12/x86_64/ruby-2.2.6.Continuing with compilation. Please read &apos;rvm help mount&apos; to get more information on binary rubies.Checking requirements for osx.Installing requirements for osx.Updating system...........Error running &apos;requirements_osx_brew_update_system ruby-2.2.6&apos;,showing last 15 lines of /Users/qianlongxu/.rvm/log/1503014778_ruby-2.2.6/update_system.log https://github.com/Homebrew/homebrew/wiki/Common-Issuesand make sure `brew update` works before continuing.&apos;++ rvm_pretty_print stderr++ case &quot;$&#123;rvm_pretty_print_flag:=auto&#125;&quot; in++ case &quot;$&#123;TERM:-dumb&#125;&quot; in++ case &quot;$1&quot; in++ [[ -t 2 ]]++ return 1++ printf %b &apos;Failed to update Homebrew, follow instructions here: https://github.com/Homebrew/homebrew/wiki/Common-Issuesand make sure `brew update` works before continuing.\\n&apos;Failed to update Homebrew, follow instructions here: https://github.com/Homebrew/homebrew/wiki/Common-Issuesand make sure `brew update` works before continuing.++ return 1Requirements installation failed with status: 1. 发生这个错误的原因是: Failed to update Homebrew !于是我就尝试执行: brew update 123Error: /usr/local is not writable. You should change the ownershipand permissions of /usr/local back to your user account: sudo chown -R $(whoami) /usr/local 这个问题是老版本的 Homwbrew 需要 /usr/local 目录的 ownership，因此执行下 sudo chown -R $(whoami) /usr/local 就可以继续了； brew 更新完毕后有这样一个提示: 12345==&gt; Migrating HOMEBREW_REPOSITORY (please wait)...==&gt; Migrated HOMEBREW_REPOSITORY to /usr/local/Homebrew!Homebrew no longer needs to have ownership of /usr/local. If you wish you canreturn /usr/local to its default ownership with: sudo chown root:wheel /usr/local 于是更新完毕后，我又把权限修改回去了：sudo chown root:wheel /usr/local. 2、安装成功后，查看 ruby 版本还是系统自动的 2.0.0，使用rvm看的话，确实已经安装了，这是怎么回事？ 1234567891011qianlongxu:~ qianlongxu$ ruby -vruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin16]qianlongxu:~ qianlongxu$ rvm listrvm rubies=* ruby-2.2.6 [ x86_64 ]# =&gt; - current# =* - current &amp;&amp; default# * - default rvm 可以切换 ruby 版本的，使用 rvm use，只要是 rvm list 列出来的，都可以切换，切换时直接跟上版本号就行了： 123456789101112131415qianlongxu:~ qianlongxu$ rvm use 2.2.6RVM is not a function, selecting rubies with &apos;rvm use ...&apos; will not work.You need to change your terminal emulator preferences to allow login shell.Sometimes it is required to use `/bin/bash --login` as the command.Please visit https://rvm.io/integration/gnome-terminal/ for an example.qianlongxu:~ qianlongxu$ rvm use &apos;2.2.6&apos;RVM is not a function, selecting rubies with &apos;rvm use ...&apos; will not work.You need to change your terminal emulator preferences to allow login shell.Sometimes it is required to use `/bin/bash --login` as the command.Please visit https://rvm.io/integration/gnome-terminal/ for an example. 再次遇到问题，rvm use 不是个命令！不要急继续往下看，问题是由于 shell 的执行环境不对，修改下登录shell即可： 12345qianlongxu:~ qianlongxu$ /bin/bash --loginqianlongxu:~ qianlongxu$ rvm use 2.2.6Using /Users/qianlongxu/.rvm/gems/ruby-2.2.6qianlongxu:~ qianlongxu$ ruby -vruby 2.2.6p396 (2016-11-15 revision 56800) [x86_64-darwin16] 3、如果你遇到了第二个问题的话，你可能会发现，关闭终端后再次打开，ruby的版本又变成系统的2.0.0了！ 原因可能是，你在设置-用户与群组-高级选项里-登录shell里设置了其他shell导致的，改为 /bin/bash 即可。 以上问题是我切换 Mac 用户名之后导致的，一般情况下应该不会遇到的。 参考链接 How to update Ruby Version 2.0.0 to the latest version in Mac OSX Yosemite https://ruby-china.org/wiki/rvm-guide http://rvm.io/rubies/default https://stackoverflow.com/questions/23963018/rvm-is-not-a-function-selecting-rubies-with-rvm-use-will-not-work","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"}]},{"title":"使用 U 盘安装 macOS Sierra","slug":"2017/06/19-install-sierra","date":"2017-06-19T08:57:32.000Z","updated":"2018-03-27T14:45:15.694Z","comments":true,"path":"2017/06/19/2017/06/19-install-sierra.html","link":"","permalink":"http://debugly.cn/2017/06/19/2017/06/19-install-sierra.html","excerpt":"","text":"由于 Mac 无法进入系统，已经分析出了原因 — 磁盘爆满的缘故，因此就想通过进入 PE 的方式，删除掉无用的文件，这样理论上就应该能够顺利进入系统了！ 刻盘进 PE在大学时期曾用 PE 装过 Windows，只不过几年不弄过了，于是就去网上下了 大白菜 PE，然后刻成启动盘，然后开始进入 PE 啦！在 Window 上进 PE 要按下 delete，然后选择从 U 盘启动，而 macOS 则是开机时按下 Option 键，然后就会出现选择启动盘 : 开机前插上 U 盘 按住 Option 开机 PE 是 Win8 系统 可惜进入后无法识别苹果分区 安装识别苹果分区软件 然并卵，高版本的系统都是逻辑分区，所以无法识别！！ Mac PE网上继续搜寻了一番，发现还有个办法可行，那就是搞个 Mac PE 来识别苹果分区，因为 Mac PE 是使用 macOS 做出来的，所以天然性的就具备识别苹果分区的能力了！啥也不说了，开始装 Mac PE 了: 首先下载镜像文件，google 才能找到官网，百度根本找不到，唉，不说了，去下载吧: FireWolf OS X PE V7.0 Download Center Mac 上使用磁盘工具恢复到 U 盘就行了！同样的开机按住 Option 选择 FireWolf 盘符就行了，当时没拍照，直接看下进去后的情况吧 : 启动后我也傻眼了，妈的磁盘是加密的，虽然识别了，但都是加密的文件，备份了也没啥用。新亏我摸索到了方法，找到磁盘实用工具，选择 从 Time Machine 恢复 一步步往下走就行了，走着走着会提示输入密码，因为解密磁盘需要权限，解密后会去搜索备份，结果当然搜不出来了，不过这时文件已经全部解密了！看后面的文件夹名字 : xuqianlong 这下以为总算可以了呢，唉，fuck 了，文件是只读的，不能删除！！！好吧，能解密就谢天谢地了，我用移动硬盘copy下资料吧！资料备份后我就放心了，实现是没别的办法了，我选择了重做系统！ 刻盘装 Mac 系统若是刻录一个 Windows 的启动盘很简单，很容易就能下到 ios 镜像文件，可是由于苹果官方现在只提供了 macOS Sierra 的升级程序，而没提供完整的镜像，想要全新安装的话，只能自己去制作一个 macOS Sierra 的 U 盘启动盘/安装盘了。没有别的办法先下载安装器吧，然后再想办法恢复到 U 盘，这是 macOS Sierra 下载地址，打开 AppStore 下载即可 共 4.96GB，网速慢的话，需要等一阵子了，下载完毕后，你会发现 Launchpad 多出一个 安装 macOS Sierra。 然后插上 U 盘，最好是 3.0 的，这样会快些，打开磁盘工具，将其抹掉，格式化为 Mac OS 扩展 （日志式） ，命名为 Sierra，然后打开终端执行以下命令 : 1sudo /Applications/Install\\ macOS\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --application /Applications/Install\\ macOS\\ Sierra.app --nointeraction 前面是安装器执行文件路径，通过 volume 参数指定安装路径，这里指定 U 盘 : /Volumes/Sierra，通过 application 参数指定安装程序，在输入以上命令后，执行过程如下 : 1234567Erasing Disk: 0%... 10%... 20%... 30%...100%...Copying installer files to disk... //这一步会执行好长时间Copy complete.Making disk bootable...Copying boot files...Copy complete.Done. 看到 Done 之后，就可以了，你会发现 U 盘名称变为了 Install macOS Sierra，种种迹象表明 U 盘刻录成功了，可以去装机了，按住 Option 开机吧 : 哇咔咔，选择从 Install macOS Sierra 启动！ 等待这个进度条走完 好不激动么，选择简体中文 选择安装 macOS 继续吧 选择 MBP 的硬盘 不行，没空间了，所以返回去，找到磁盘工具，格式化硬盘 抹掉就行了 这些可干净了，啥也没了 继续安装 说是7分钟，实际要长些，主要是我 U 盘不是 3.0 的，拷贝文件速度慢 还有 1 分钟 重启是正常的，看来就快好了 选择中国 选择 WiFi 不用传输了 设置下 iCloud 选择时区 哇咔咔，进来了！！！好熟悉的桌面-内华达山脉 刚格式化的时候可用空间是 249G，现在是 239G，看来系统占用了 10G。 完使用 U 盘安装系统或者安装 Mac PE 的前提都是要有个 Mac 才行，这样才能做出启动盘来，这对于很多用户而言是不太容易满足的，所以最好别让我们的 Mac 挂掉，省得如此麻烦，特别建议和我一样使用 256 G 磁盘的用户，多给系统预留一些空间，至少 20G 左右，最好是买个移动做下日常硬盘备份，才不会出现我今天的悲剧! 当磁盘空间小时，Mac 经常弹出来一个提示让我清理，我没有去深度清理，我记得我好像剩下 13G 左右，现在想来还挺后悔的，要不然就不用在这折腾了！","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"Fuck，Mac 关机后再也无法启动","slug":"2017/06/18-my-mbp-adversity","date":"2017-06-18T13:46:27.000Z","updated":"2018-03-27T14:45:15.693Z","comments":true,"path":"2017/06/18/2017/06/18-my-mbp-adversity.html","link":"","permalink":"http://debugly.cn/2017/06/18/2017/06/18-my-mbp-adversity.html","excerpt":"","text":"今天擦桌子的时候顺便擦了下我的 MBP，为了不在擦的时候按下键盘误操作，所以在擦之前我把 Mac 关机了。等到下午没事开机时却遇到了个大大的问题：进度条走到百分之八十左右的时候卡住，卡一会之后就关机了！接着又试了好几次，还是不行，我有点慌了，此本追随我快三年了，可不能有个三长两短啊，于是赶忙开始在网上查找解决方法。 Rest查找了好多的文章，总结起来就是以下三种方法 重置 SMC 重置 NVRAM 重装系统 接下来我给简单介绍下，以及哪些场景适合使用。 What’s SMC ？SMC : System Manager Controller 基于 Intel 的 Mac 上的 系统管理控制器 ，简单理解就是用于管理电源，风扇，键盘灯，屏幕背光等等，以下是官方介绍： 在基于 Intel 的 Mac 电脑上，SMC 负责管理以下及其他低级功能： 对按下电源按钮的操作做出响应 对 Mac 笔记本电脑上显示器屏幕盖的开合做出响应 电池管理 热能管理 SMS（突发移动感应器） 环境光度感应 键盘背光 状态指示灯 (SIL) 管理 电池状态指示灯 为某些 iMac 显示器选择外部（而非内部）视频来源 何时需要重置 SMC这个管理系统也会出问题，等出了问题后可以重置下，一切从新开始，那么何时需要重置呢？这是官网罗列的情况： 尽管电脑工作负荷不重且通风良好，但电脑风扇依然高速旋转。 键盘背光灯行为有些异常。 状态指示灯 (SIL) 行为有些异常。 电池指示灯（如果有的话）行为有些异常（在配有不可拆卸电池的 Mac 笔记本电脑上）。 显示器背光灯不能对环境光线变化做出正确响应。 电脑不能在电源按钮按下时做出正确响应。 Mac 笔记本电脑不能对屏幕盖的开合做出正确响应。 电脑意外进入睡眠状态或关机。 电池不能正常充电。 MagSafe 电源适配器的 LED 指示灯不能正确地指示活动状态。 尽管电脑的 CPU 利用率并不是非常高，但运行速度异常缓慢。 应用程序打开时，其图标可能会在 Dock 中“弹跳”较长一段时间。 应用程序打开后，可能无法正常工作或停止响应。 支持目标显示器模式的电脑无法正常进入或退出目标显示器模式，或意外地进入或退出目标显示器模式。 移动电脑时，Mac Pro（2013 年末）上的 I/O 端口周围的背光灯未激活。 起初我的 MBP 并没有些问题之一，后来一直折腾的时候遇到了两个问题： 开机之后 CPU 风扇立马疯狂高速旋转 插上电源后，电源指示灯不亮 反复按住电源键强制关机几次后，仍然如此，然后我试着重置 SMC，结果确实解决了上面两个问题！ 如何重置 SMC带 Touch ID 的 2016 新款 MacBook Pro，则 Touch ID 按钮就是电源按钮。 将 Mac 关机，不能正常关，就强制关掉 拔下电源适配器 同时按下 左侧Shift + Control + Option + 电源键 ，按住这些按键和电源按钮 10 秒后松开 重新连接电源适配器后重启 点击查看官网对 SMC 的介绍。 What’s NVRAM ？NVRAM : Non-Volatile RAM 非易失性随机访问存储器,其实就是一小部分特殊的内存，Mac 利用这些部分内存来储存某些设置从而实现更加快速的访问！这些设置可能包括 : 音量、显示屏分辨率、启动磁盘选择、时区，以及最近的内核崩溃信息等。 何时需要重置 NVRAM如果上面说的那些设置出现问题后，就可以考虑重置 NVRAM 了。例如， Mac 并非从“启动磁盘”偏好设置中选定的磁盘启动，或者在 Mac 启动前短暂地显示了一个问号图标，则可能需要重置 NVRAM。 如何重置 NVRAM 将 Mac 关机 重新开机后立即同时按下 Option + Command + P + R 不要松手，电脑会自动重启，至少重启两次后就可以松开了 松手后进入系统即可 不过进入系统后，可能之前设置的音量、分辨率、启动磁盘、时区等会被重置，可以在系统偏好设置里修改。 台式机需要电池供电每次断开 Mac 电源后，下次启动后发现音量或时区等设置均会重置时，就需要更换 Mac 中的电池了。这个小电池在主板上卡着，为的是断开电源后帮助 NVRAM 保存设置。读到这你是不是想起了 CMOS 呢？感觉 Mac 上这个 NVRAM 跟 CMOS 很像呢。 点击查看官网对 SMC 的介绍。 Commad + R我的 MBP 不能开启并非以上问题导致的，我在网上查到一个 实用工具模式，进入方式： 按下 Commad + R一直不动 按一下开机键松开 等个几秒看到进度条后松开 Commad + R即可 如图： 选择 磁盘工具 Fuck ！磁盘空间是 0KB ！！！ 为何会这样，我记得明明有好几个 G 的可用空间的啊，我怀疑是苹果给我下载了系统更新，重新开机会会解压然后然后，结果解压后导致我的空间没了，所以每次都是卡在百分之八十左右的地方，卡一会之后系统就自动关机了！看到这个就大概知道是怎么回事了，自然也能想到解决的办法 — 进PE，删除无用文件，腾出来一些空间给系统用！ 接下来的事情更是曲折，还是再写一篇文章来介绍（吐槽）吧！","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"使用 Rake 重写打包脚本","slug":"2017/06/04-use-rake","date":"2017-06-04T06:04:59.000Z","updated":"2018-03-27T14:45:15.693Z","comments":true,"path":"2017/06/04/2017/06/04-use-rake.html","link":"","permalink":"http://debugly.cn/2017/06/04/2017/06/04-use-rake.html","excerpt":"","text":"我最初的博客系统使用的是 Octopress，创建博客或者预览博客都是使用的 rake 命令，感觉很是方便，现在虽然直接使用了 Jekyll，但是这套命令还是被我移植过来继续使用着。之前我用 Shell 编写过一套打包的脚本，现在接触了 Ruby 脚本，对比之下感觉 Shell 这门语言太不友好了，编程效率很低，于是前天晚上开始学习 rake，边写边学边查资料，一步步的重写了这套打包脚本，故趁热打铁写下这篇博客记录用到的知识点。 Ruby 语言的图标: 名词解释学习 Ruby 之前先捋顺下相关的名词吧 Ruby: 是一门纯粹的面向对象编程语言，她语法简洁优美，简单易学，兼具函数式编程和命令式编程特色，由日本的松本行弘创建，松本行弘被称为 Matz 。这是 Ruby 中文官网: http://www.ruby-lang.org/zh_cn/ RVM: 用来管理 Ruby 版本及相关插件，方便切换版本环境。 Ruby on Rails: 开发 web 应用的框架。 Gem: 组织 Ruby 程序或者代码类库的包，每个 Ruby 应用程序就是一个 gem 包。 RubyGems: 方便而强大的 Ruby 程序包管理器，用来管理 gem 的，类似 RedHat 的 RPM；Ruby环境里已经包含了 RubyGems 了，无需额外安装。 Ruby 社区的 Gem 托管服务: RubyGems.org RubyGems 镜像 gems.ruby-china.org RubyGems 镜像 ruby.taobao.org 使用 gem list 可查看已经安装的 gem 包 Rake: 如果你已经查看了所有安装的 gem 包的话，你会发现其中一个就是 rake (10.5.0, 10.4.2)，这个是很重要的一个 gem。跟 Make 类似，是一个 DSL 构建语言，Rails 有很多任务常用 rake 来完成。 Rakefile: 使用 Ruby 语言按照 DSL 格式编写的文件，定义了 Rake 的执行过程。 Ruby 基础知识编写 Rakefile 必须知道 Ruby 的语法才行，简单学习下吧： 特殊变量的命名规则 常量: 以大写字母开头的变量，如: Jekyll，为方便起见常量全部大写 全局变量: 以”$”开头的变量，如: $jekyll 实例变量: 以”@”开头的变量，如: @jekyll 类变量: 以”@@”开头的变量，如: @@jekyll 我最初不知道大写字母开头的是常量，原本想的是使用全局变量的，结果改变了常量的值，执行时发现了警告：warning: already initialized constant JEKYLL所以最好不要修改常量的值！ __FILE__: 当前源文件的名称(含路径) __LINE__: 当前行在源代码中的编号 注释 单行注释: ‘#单行注释’ 多行注释: 12345=begin多行注释多行注释多行注释=end 输出日志: puts “log something”，跟 printf 类似 数组 1234567891011ary = [\"abc\",19,3.14,\"This is my pubby\"]# 等同于arr = Array.newarr[0] = \"abc\"arr[1] = 19arr[2] = 3.14arr[3] = \"This is my pubby\"# 遍历数组ary.each do |i| puts iend Hash，OC 里叫字典 12345colors = &#123;\"red\" =&gt; 0xff0000, \"green\" =&gt; 0x00ff00,\"blue\" =&gt; 0x0000ff&#125;# 遍历 Hashcolors.each do |key,value| print key,\" is \",value, \"\\n\"end Sequence 序列 1234seq = (10..15)seq.each do |n| print n,' 'end 字符串: “Hello World” 特殊语句块 1234567BEGIN&#123; puts \"【执行其他代码前，先执行BEGIN块里的语句！】\"&#125;END&#123; puts \"【执行完其他所有代码后，再执行END块里的语句！】\"&#125; 方法 123def test(content) puts \"### \" + contentend Rake 入门 Rakefile 先创建名为 Rakefile 的文件，然后就可以按照格式写了: 1234desc \"task 说明\"task :test do puts \"I'm a task\"end 在 Rakefile 目录打开终端并执行: rake test，你会发现测试语句输出了；这就是 Rake 的模板，可以通过 rake -T 查看定义的所有 task，desc 会作为文档显示出来: 1234xuqianlong$ rake testI'm a taskxuqianlong$ rake -Trake test # task 说明 namespace 你可能会定义多个 task，这样一来可能会不好命名或者冲突，辛好可以通过 namespace 来解决，如果有命名空间的话，执行的时候带上才行，比如： 12345678910111213# 添加到 Rakefile 里namespace :TestNamespace do desc \"test namespace 说明\" task :test do puts \"I have a namespace.\" endend# 命令行继续执行xuqianlong$ rake -Trake TestNamespace:test # test namespace 说明rake test # task 说明xuqianlong$ rake TestNamespace:testI have a namespace. default task 可以在 Rakefile 里指定默认的 task，然后执行时就不用带上 task 名字了 12345# 添加到 Rakefile 里task :default =&gt; [:test]# 调用xuqianlong$ rakeI'm a task import 为了减轻 Rakefile 的压力，可以把代码分散到不同的 rake 文件里，然后使用 import 导入即可，可以包含 task 任务，也可以包含 ruby 代码哦； buildConfig.rake 里放了打包的先关配置信息，放在config目录下，这样导入就行了： 1import(\"config/buildConfig.rake\") invoke 一个 task 可以调用别的 task，代码如下: 12# PackageSDK 是命名空间, prepareBuildFolder 是 task 的名字Rake::Task[\"PackageSDK:prepareBuildFolder\"].invoke Call Shell打包的命令是 Shell 命令，所以要想办法让 ruby 去调用才行，查到了一下方法: 反引号 (Backticks) : `cmd` 123# 可以获取到命令的返回值xcversion = `xcodebuild -version`puts xcversion system “cmd” 12345# Hi 会被直接输出到命令行system \"echo Hi\"# 可以通过 $? 获取子进程 pid 和执行结果pid 48526 exit 0# 可以 $?.to_i 获取执行结果，如果是 0 这说明正常执行 YAML在 Ruby 的世界里，他使用很广泛，可读性很好，用来取代 XML 标记语言，比 XML 更有优势；一般用作配置文件，因此之前用 shell 写的配置文件就改为 .yml 文件了: 1234DESC: \"SohuLiveSDK for Video\"SCHEME_NAME_ARR: [\"SohuCoreFoundation\",\"SohuOneSDK\",\"SohuGameSDK\",\"SohuLiveSDK-Video\"]PLIST_INFO: \"SohuLiveSDK/SohuLiveSDK/video-info.plist\"CATEGORY_NAME: \"千帆SDK-Video\" 读取配置文件内容: 12# 读出来后是 HASH 类型，很方便使用config = YAML::load(File.read(cfgdir, cfgname))) 使用前需要导入库哦: 1require 'yaml' STDIN所有的打包渠道都放在 PLACE_CONF_ARR 数组中，使用者需要选择打哪个渠道，因此须要求输入 1 ~ N 之间的数字，其中 N = PLACE_CONF_ARR.size，代表打包渠道数组长度，代码如下 12345input = 0until (input &gt; 0) &amp;&amp; (input &lt;= PLACE_CONF_ARR.size) puts \"请输入1~\" + PLACE_CONF_ARR.size.to_s + \"之间的数字:\" input = $stdin.gets.chomp().to_iend Installed xx Gem ?我使用了 xcpretty 将 xcodebuild 的输出信息格式化，但是同事的电脑可能没装 xcpretty，因此要判断出来是否安装了，如果没安装就不使用，这样程序才算健壮，逻辑为： 12345678910111213141516171819202122#定义一个全局变量$g_xcpretty = false# 判断下是否安装了 xcprettyisInstalled = `gem list -i xcpretty`# 去掉末尾的换行符isInstalled = isInstalled.chomp();# 如果是 \"true\" 则表明安装了if isInstalled == \"true\" $g_xcpretty = trueend# ...# 剩下的逻辑通过 $g_xcpretty 全局变量判断即可def build_sdk_scheme(sdk,scheme) puts \"========== Build #&#123;scheme&#125; On #&#123;sdk&#125; Platform ==========\" if $g_xcpretty system \"/usr/bin/xcodebuild -workspace #&#123;wksp&#125; -scheme #&#123;scheme&#125; -configuration #&#123;CONFIGURATION&#125; -sdk #&#123;sdk&#125; BUILD_DIR=#&#123;build_dir&#125;\" | xcpretty else system \"/usr/bin/xcodebuild -workspace #&#123;wksp&#125; -scheme #&#123;scheme&#125; -configuration #&#123;CONFIGURATION&#125; -sdk #&#123;sdk&#125; BUILD_DIR=#&#123;build_dir&#125;\" endend","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"}]},{"title":"iOS Framework 瘦身实战","slug":"2017/06/01-reduce-framework-weight","date":"2017-06-01T05:30:02.000Z","updated":"2018-03-27T14:45:15.693Z","comments":true,"path":"2017/06/01/2017/06/01-reduce-framework-weight.html","link":"","permalink":"http://debugly.cn/2017/06/01/2017/06/01-reduce-framework-weight.html","excerpt":"","text":"近来业务增多，对应的 Framework 也越做越多，提供给搜狐视频的就多达 5个，物理包大小当然也越来越大了，因此查阅了资料，对 framework 进行瘦身！ 工程配置 调试符号(Generate Debug Sysmbols) 这个是控制是否生成调试符号的，因此 debug 模式下保持使用 YES，release改为 NO；也就说我们平时调试还生成调试信息，但是打包发布时不需要生成，如果 debug下也改为 NO 的话，会导致没有断点，你设置了断点，但是代码走到那之后不会停下来让你调试！经过试验，我从 97M 减到了 61M，减少了 37 % cpu 架构(Architectures) 基本上每多支持一种架构，包大小就会翻一倍！目前而言，Architectures 设置为 armv7，arm64 就可以了，下面是架构对应的机型 armv6 : iPhone,iPhone2,iPhone3G, iPhone3GS armv7 : iPhone4,iPhone4S; armv7s: iPhone5,iPhone5C; arm64 : iPhone5S,iPhoneSE,iPhone6(plus)(S),iPhone7(plus)(S) 压缩等级（Optimization Level） 使用默认值就行了 release : Fastest,Smallest[-Os] debug : None,[-O0] 不可能执行到的代码 (Dead Code Stripping) 使用默认值就行了 设置为 YES 资源图片 必要的资源图片，比如按钮的背景图，Loading 图标等，均可进行无损压缩；可以使用 ImageOptim 这款开源软件！ 除了必要的资源图片外，像礼物图片，大动画资源图片等，都可采用动态下载的方式，这样做除了减少包大小外，也能做到及时更新，满足产品需求！ ipa 瘦身由于主要精力在 SDK 开发上，所以我暂无实际经验，这是网上找的一篇 文章 。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"},{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"常用 Shell 命令汇总","slug":"2017/05/26-my-shell","date":"2017-05-26T13:03:36.000Z","updated":"2018-03-27T14:52:07.281Z","comments":true,"path":"2017/05/26/2017/05/26-my-shell.html","link":"","permalink":"http://debugly.cn/2017/05/26/2017/05/26-my-shell.html","excerpt":"","text":"日常工作中，特别是我搭建远程打包环境的过程中用到了不少 Shell 命令，这里记录下，省得以后再去查询，浪费时间。 内置变量以下结果来自 Mac OS 10.12，提示：这些内置变量是以美元符号开头的哈,因为这些都是变量，在 Shell 脚本里面取变量的值需要以美元符号开头； $SHELL : 查看终端使用是哪种 shell，shell 也不止一种哦: /bin/bash $HOME : 登陆用户主目录: /Users/xuqianlong $PATH : 截取一小段来看下: /opt/local/bin:/opt/local/sbin,分号是分隔符;在终端输入命令就能执行的原理其实是，遍历设置的PATH路径，直到找到该命令如果找不到就输出：-bash: ee: command not found 学习过 Java 的同学肯定都知道 Path 的概念。 $USER : 当前登陆用户名称: xuqianlong $OSTYPE : 操作系统类型: darwin16 $MACHTYPE : CPU架构及系统类型: x86_64-apple-darwin16 $LANG : 语言类型: zh_CN.UTF-8 命令 env 查看所有的环境变量，这个命令太厉害了，上面提到的好多内置变量的值都包括了： 12345678910111213141516171819202122232425262728293031323334353637MANPATH=/Users/xuqianlong/.nvm/versions/node/v4.0.0/share/man:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/man:/usr/local/share/man:/usr/share/man:/opt/X11/share/man:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/usr/share/man:/Applications/Xcode.app/Contents/Developer/usr/share/man:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/share/manNVM_IOJS_ORG_VERSION_LISTING=https://iojs.org/dist/index.tabrvm_bin_path=/Users/xuqianlong/.rvm/binTERM_PROGRAM=Apple_TerminalSHELL=/bin/bashTERM=xterm-256colorTMPDIR=/var/folders/d2/bt0v98895vd53lcx9w_spzdw0000gn/T/NVM_PATH=/Users/xuqianlong/.nvm/versions/node/v4.0.0/lib/nodeApple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.f7R2BOD9jj/RenderTERM_PROGRAM_VERSION=377TERM_SESSION_ID=75991873-8124-4503-8BA0-F10EB73C0D84NVM_DIR=/Users/xuqianlong/.nvmUSER=xuqianlong_system_type=Darwinrvm_path=/Users/xuqianlong/.rvmSSH_AUTH_SOCK=/private/tmp/com.apple.launchd.SZQYe5MXKe/Listeners__CF_USER_TEXT_ENCODING=0x1F5:0x19:0x34rvm_prefix=/Users/xuqianlongPATH=/Library/Frameworks/Python.framework/Versions/3.5/bin:/opt/local/bin:/opt/local/sbin:/Users/xuqianlong/.nvm/versions/node/v4.0.0/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Users/xuqianlong/libwebp-0.5.1-mac-10.9/bin:/Users/xuqianlong/bin:/Users/xuqianlong/.rvm/binNVM_NODEJS_ORG_MIRROR=https://nodejs.org/distPWD=/Users/xuqianlongJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/HomeLANG=zh_CN.UTF-8_system_arch=x86_64XPC_FLAGS=0x0_system_version=10.12XPC_SERVICE_NAME=0rvm_version=1.27.0 (latest)SHLVL=1HOME=/Users/xuqianlongLOGNAME=xuqianlongNVM_BIN=/Users/xuqianlong/.nvm/versions/node/v4.0.0/binNVM_IOJS_ORG_MIRROR=https://iojs.org/distDISPLAY=/private/tmp/com.apple.launchd.0jBYczqYJG/org.macosforge.xquartz:0SECURITYSESSIONID=186a6_system_name=OSX_=/usr/bin/env cat 查看文本内容，比如查看下机器上安装了几种 shell：cat /etc/shells 12345678910# List of acceptable shells for chpass(1).# Ftpd will not allow users to connect who are not using# one of these shells./bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh ls /bin/*sh ，结果跟上面是一样的 hostname -s 主机名称: debugly tar -czf sdk.tar.gz *.framework : 先将目录里所有后缀名为 framework 的文件打包成 sdk.tar，然后用 gzip 压缩，生成 sdk.tar.gz 压缩的压缩包 ps用 ps 命令可以查看进程相关信息，哪些进程正在运行和运行状态、进程是否结束、进程有没有僵死、哪些进程占用了过多地资源等等。 1234567891011121314151617181920212223242526272829303132333435363738qianlongxu:~ qianlongxu$ ps PID TTY TIME CMD 2771 ttys000 0:00.07 -bash 2836 ttys001 0:00.06 -bash 1398 ttys004 0:00.10 -bashqianlongxu:~ qianlongxu$ echo $$2771qianlongxu:~ qianlongxu$ ps -f UID PID PPID C STIME TTY TIME CMD 501 2771 2770 0 8:45上午 ttys000 0:00.07 -bash 501 2836 2835 0 8:45上午 ttys001 0:00.06 -bash 501 1398 1397 0 3:55下午 ttys004 0:00.10 -bashqianlongxu:~ qianlongxu$ ps -e PID TTY TIME CMD 1 ?? 0:51.90 /sbin/launchd 51 ?? 0:04.78 /usr/libexec/UserEventAgent (System) ///此处省略好多行 2770 ttys000 0:00.04 login -pf qianlongxu 2771 ttys000 0:00.07 -bash 2900 ttys000 0:00.00 ps -e 2835 ttys001 0:00.01 login -pf qianlongxu 2836 ttys001 0:00.06 -bash 1397 ttys004 0:00.02 login -pf qianlongxu 1398 ttys004 0:00.10 -bash///查看进程关系qianlongxu:~ qianlongxu$ ps -f UID PID PPID C STIME TTY TIME CMD 501 2987 2986 0 9:00上午 ttys000 0:00.06 -bashqianlongxu:~ qianlongxu$ zshqianlongxu% qianlongxu% ps -f UID PID PPID C STIME TTY TIME CMD 501 2987 2986 0 9:00上午 ttys000 0:00.07 -bash 501 3102 2987 0 9:04上午 ttys000 0:00.03 zsh 重定向使用重定向，可以轻松的提供输入，改变输出； 输出重定向： “&gt;” 覆盖文本 12345echo \"abc\" &gt; \"aa.txt\"echo \"abc\" &gt; \"aa.txt\"echo \"abc\" &gt; \"aa.txt\"//查看 aa.txt 文件，内容是：abc “&gt;&gt;” 追加文本 1234567echo \"abc\" &gt;&gt; \"aa.txt\"echo \"abc\" &gt;&gt; \"aa.txt\"echo \"abc\" &gt;&gt; \"aa.txt\"//查看 aa.txt 文件，内容是：abcabcabc 输入重定向： 1234///读取 aa.txt 文件的第一行，然后打印read line &lt; aa.txt;echo $line///结果是：abc 管道这是一个强大的 shell 命令，可将输出结果作为另一个程序的输入，符号 : “|“ ，比如查看当前目录，并且按字母顺序排列： 12345678910111213141516ls | sortApplicationsDesktopDocumentsDownloadsGitBookLibraryMoviesMusicPicturesPublicapache-tomcat-7.0.64bincstudycworkspace 可以看出先排大写字母，后排小写字母，原因是大写字母的 ASCLL 比小写的小了 32，即：A + 32 = a ,A = 65. scp 本机复制到远程服务器 文件 1scp /Users/qianlongxu/Downloads/id_rsa.pub crown@10.7.40.176:~/id_rsa.pub 文件夹 12//在远程服务器game下创建qr-code，copy qr-code 下的所有文件scp -r /Users/Shared/Jenkins/Home/xql/qr-code root@10.10.194.16:/opt/www/html/game 从远程服务器下载到本地 12345scp jenkins@10.7.40.195:/Users/Shared/Jenkins/Home/workspace/hall-ios/builds/20180317/game56hall-inhouse.ipa ~/Desktop/game56hall-inhouse.ipa scp jenkins@10.7.40.195:/Users/Shared/Jenkins/Home/workspace/hall-android/build/jsb-default/frameworks/runtime-src/proj.android-studio/app/build/outputs/apk/release/app-release.apk ~/Desktop/app-release.apk 下载文件夹加上 -r 即可；可以看出 scp 的第一个参数其实就是源文件，第二个参数是目的地，这样比较好记些。 ssh 登陆远程服务器: 123ssh crown@10.7.40.176///输入密码sohuxxx 免密码登录 可以把客户机的公钥填充到远程打包机器上的authorized_keys文件中，实现自动验证，无需泄露服务器密码 1234///将公钥追加到这个服务器~/.ssh/authorized_keys文件末尾 ssh-copy-id -i jenkins@10.7.40.195///输入密码sohuxxx 执行命令 删除掉远程服务器桌面上的 xx 目录： 12Remote_dir='~/Desktop/xx'ssh root@12.11.193.18 \"rm -rf $&#123;Remote_dir&#125;\" kill jekyll server我修改 Rakefile 的时候，修改不当导致没能处理INT，后果就是我们按下 ctrl + c 的时候没有将该子线程杀死，然后再次启动服务时就会报错: 1jekyll 3.3.0 | Error: Address already in use - bind(2) for 127.0.0.1:4000 为了解决这个问题就需要找到当前占用 4000 端口的进程，然后将其杀死；步骤是： 123456# 先查下占用 4000 端口的进程 idxuqianlong$ lsof -i tcp:4000COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEruby 49753 xuqianlong 10u IPv4 0xebc4350e453a6ff 0t0 TCP localhost:terabase (LISTEN)# 然后杀死该进程xuqianlong$ kill 49753 curl功能强大的网络工具，支持的协议众多，包括：DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP。最简单的是 GET 请求： 1curl http://debugly.cn/dist/json/test.json 使用 HEADER 请求，仅返回 http 头部信息： 12345678910111213141516171819202122curl -I http://debugly.cn/dist/json/test.jsonHTTP/1.1 200 OKServer: GitHub.comContent-Type: application/json; charset=utf-8Last-Modified: Thu, 03 Aug 2017 15:36:20 GMTAccess-Control-Allow-Origin: *Expires: Sat, 05 Aug 2017 08:58:43 GMTCache-Control: max-age=600X-GitHub-Request-Id: C99E:118EE:5EABC0:656C5C:5985866BContent-Length: 6257Accept-Ranges: bytesDate: Sat, 05 Aug 2017 08:51:00 GMTVia: 1.1 varnishAge: 136Connection: keep-aliveX-Served-By: cache-nrt6126-NRTX-Cache: HITX-Cache-Hits: 1X-Timer: S1501923060.014934,VS0,VE1Vary: Accept-EncodingX-Fastly-Request-ID: 0dc32470ef01fa9b0672d3d38edc904b9836debc 这个文档有详细的介绍：https://curl.haxx.se/download.html chown更新软件包的时候可能没有权限，需要修改权限，可使用 chown 给用户添加 ownership 权限； sudo chown -R $(whoami) /usr/local 1234qianlongxu:myblog qianlongxu$ brew updateError: /usr/local is not writable. You should change the ownershipand permissions of /usr/local back to your user account: sudo chown -R $(whoami) /usr/local git git log 12345678910111213141516171819qianlongxu$ git log -3commit 8e8c188d3fc8c3b8937e213d3ae7bd45cdc55c69 (HEAD -&gt; source, origin/source)Author: qianlongxu &lt;qianlongxu@sohu-inc.com&gt;Date: Sat Mar 24 09:49:51 2018 +0800 add postcommit eb3e9419a4a6cc736808ac40b7cf2908b7998c56Merge: e851655 6755480Author: qianlongxu &lt;qianlongxu@sohu-inc.com&gt;Date: Sat Mar 24 09:49:08 2018 +0800 Merge branch 'source' of https://github.com/debugly/debugly.github.io into sourcecommit 67554800909e91430231da8c34887933a4160649Author: qianlongxu &lt;qianglongxu@home.mbp&gt;Date: Thu Mar 22 22:17:08 2018 +0800 add tag git log –date=format 12345678910111213141516171819qianlongxu$ git log --date=format:'%Y-%m-%d %H:%M:%S' -3commit 8e8c188d3fc8c3b8937e213d3ae7bd45cdc55c69 (HEAD -&gt; source, origin/source)Author: qianlongxu &lt;qianlongxu@sohu-inc.com&gt;Date: 2018-03-24 09:49:51 add postcommit eb3e9419a4a6cc736808ac40b7cf2908b7998c56Merge: e851655 6755480Author: qianlongxu &lt;qianlongxu@sohu-inc.com&gt;Date: 2018-03-24 09:49:08 Merge branch 'source' of https://github.com/debugly/debugly.github.io into sourcecommit 67554800909e91430231da8c34887933a4160649Author: qianlongxu &lt;qianglongxu@home.mbp&gt;Date: 2018-03-22 22:17:08 add tag git log –date=format 1234qianlongxu$ git log --date=format:'%a|%A|%b|%B|%c|%d|%H|%I|%j|%m|%M|%p|%S|%U|%w|%W|%x|%X|%y|%Y|%z' --pretty=format:'%cd' -3Sat|Saturday|Mar|March|Sat Mar 24 09:49:51 2018|24|09|09|083|03|49|AM|51|11|6|12|03/24/18|09:49:51|18|2018|+0800Sat|Saturday|Mar|March|Sat Mar 24 09:49:08 2018|24|09|09|083|03|49|AM|08|11|6|12|03/24/18|09:49:08|18|2018|+0800Thu|Thursday|Mar|March|Thu Mar 22 22:17:08 2018|22|22|10|081|03|17|PM|08|11|4|12|03/22/18|22:17:08|18|2018|+0800 git log –after 12345678910111213 qianlongxu$ git log --date=format:'%Y-%m-%d %H:%M:%S' --after='2018-03-23 20:44:06'commit 8e8c188d3fc8c3b8937e213d3ae7bd45cdc55c69 (HEAD -&gt; source, origin/source)Author: qianlongxu &lt;qianlongxu@sohu-inc.com&gt;Date: 2018-03-24 09:49:51 add postcommit eb3e9419a4a6cc736808ac40b7cf2908b7998c56Merge: e851655 6755480Author: qianlongxu &lt;qianlongxu@sohu-inc.com&gt;Date: 2018-03-24 09:49:08 Merge branch 'source' of https://github.com/debugly/debugly.github.io into source 获取最后一次提交时间秒数，然后加1 12last_commit_sec=$(git log --date=format:'%S' --pretty=format:'%cd' -1)last_commit_sec=`expr $last_commit_sec + 1` 查看此次拉取远程之后，都有哪些提交记录 12345last_commit_datestamp=$(git log --date=raw --pretty=format:'%cd' -1)last_commit_date=$&#123;last_commit_datestamp% *&#125;last_commit_date=`expr $last_commit_date + 1`git pullgit log --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'&lt;tr&gt;&lt;td&gt;%an&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%cd&lt;/td&gt;&lt;/tr&gt;' --after \"'$last_commit_date'\" -n 200 Git-基础-查看提交历史 git修改user.name和user.email 12345///查看git config --list///修改git config --global user.name \"name\"git config --global user.email \"email\" git clone 123git clone -b $branch $repos $WORKSPACEgit branch --set-upstream-to=origin/$branch $branchgit submodule update --init --recursive du 获取文件大小 : IPA_Size=$(du -sm $IPA_Path | awk &#39;{print $1}&#39;) 文件（夹）是否存在 文件是否存在 123456if [ -f $last_commit_date_txt ];then last_commit_datestamp=$(cat $last_commit_date_txt) echo 'xql last_commit_datestamp:'$last_commit_datestamp last_commit_date=$&#123;last_commit_datestamp% *&#125; last_commit_date=`expr $last_commit_date + 1`fi 文件夹是否存在 123if [ -d $last_commit_folder ];thenfi 文件内容是否为空 12345if [ `cat $commit_info_txt |wc -m` -eq 0 ];then echo 'file is empty.'else echo 'file is not empty!'fi iOS build 号自增123456789# info.plist路径project_infoplist_path=&quot;/proj.ios_mac/ios/game-inhouse.plist&quot;#取版本号appVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)#取build号#buildNO=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)#加1buildNO=$(($buildNO+1))/usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion $BUILD_NUMBER&quot; &quot;$project_infoplist_path&quot; Shell 参数含有空格12ps=\"xxx zzz\"./build.sh \"'$ps'\" Shell 算术运算1234///使用 expr 外部程式a=12;b=19;result=`expr $a + $b` Shell 字符串截取123str=\"1234444 +8000\"///str1=\"1234444\"str1=$&#123;str% *&#125; https://www.cnblogs.com/zwgblog/p/6031256.html","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"}]},{"title":"初识 Liquid 模板语言","slug":"2017/05/21-liquid","date":"2017-05-21T08:37:51.000Z","updated":"2018-03-27T14:45:15.692Z","comments":true,"path":"2017/05/21/2017/05/21-liquid.html","link":"","permalink":"http://debugly.cn/2017/05/21/2017/05/21-liquid.html","excerpt":"","text":"去年 11 月，我开始使用 Jekyll 搭建静态博客系统，由于默认的主题过于简陋，因此我为自己定制了主题，Jekyll 使用 Liquid 模板标记语言作为模板引擎，所以要定制主题，就不得不去学习下 Liquid 这个标记语言，如果你点进去看的话，你会发现我的主题跟这个惊人的相似… 我没有足够的时间去学习，或者说我觉得也不需要去系统的掌握，简单入门后，用到哪里查哪里就行了，写这篇博客的目的是记录下我用过的语法，方便以后查阅。 Liquid 是一门标记语言，所以不要跟 C，Java 这些高级语言相比，她的功能是比较简单的，不过她也有自己的特色，是 C，Java 这些高级语言所不具备的，往下看吧，你会见识到的！ 基础语法Liquid 代码可以分为三类：对象，标记，过滤器； 1、对象 Object取出对象的值: 1&#123;&#123; page.title &#125;&#125; 比如，我们现在有一个模板页面，需要把博客标题当做 HTML 页面的 title，也就是说这块需要动态替换，只需这么写： 1&lt;title&gt;&#123;&#123; page.title &#125;&#125;&lt;/title&gt; 当生成 HTML 静态页面时，就会取出博客里定义的 title 值，然后放到 &lt;title&gt; 标签里，这就是一个最简单的模板！ 标记用来处理逻辑，经常用的有声明变量，包含文件，if else 分支语句，for 循环等；比如： 1234567&lt;title&gt; &#123;% if page.title %&#125; &#123;&#123; page.title &#125;&#125; &#123;% else %&#125; &#123;&#123; site.title &#125;&#125; &#123;% endif %&#125;&lt;/title&gt; 这些逻辑代码是不会显示到页面上的，最后得到就是取出的对象值。下面是我首页的代码，意思是取最近发布的 5 篇博文： 1234567891011121314151617&#123;% for post in site.posts limit:5 %&#125; &lt;div id=\"post-li\"&gt; &lt;div class=\"cardheader\"&gt; ///文章标题 &lt;a href=\"&#123;&#123; post.url &#125;&#125;#0\"&gt; &#123;&#123; post.title &#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"cardcontent\"&gt; &lt;span&gt;///文章简介，最多120字 &#123;% if post.excerpt %&#125;&#123;&#123; post.excerpt | strip_html | strip_newlines | truncate: 120 &#125;&#125;&#123;% endif %&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"cardfooter\"&gt;///发布日期 &lt;span&gt; &#123;&#123; post.date | date: \"%m月%d日 %y年\" &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endfor %&#125; 可以将相同的页面抽取出来，然后使用 include 标记包含，比如首页包含了导航： 1&#123;% include navigation.html %&#125; 有的时候，确实是要按照你写的原封不动的输出，而不是让 Liquid 去处理，怎么办？可以使用 raw 标签解决，其实上面这个 inlcude 例子的代码就是通过 raw 标签实现了，否则 Liquid 就真的会将这个页面导入了！我是这么写的： 12345&lt;div class=\"language-html highlighter-rouge\"&gt;&lt;pre class=\"highlight\"&gt;&lt;code&gt;&amp;#123;&amp;#23;&amp;#37; raw &amp;#37;&amp;#125; &amp;#123;&amp;#37; include navigation.html &amp;#37;&amp;#125; &amp;#123;&amp;#37; endraw &amp;#37;&amp;#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt; 如果除去样式的话，这就是首页博客列表的全部核心代码了，怎么样简单吧！ 3、过滤器 Filter其实上面已经用到了过滤器了，不得不说确实很强大，有点 Shell 管道的意思，连符号也和管道一样 “|“ ，其作用是将对象的值在输出之前做个处理，并且可以连续使用多个过滤器，从左到右一个个的处理！比如： 12//将日期对象进行格式化后再输出：05月21日 17年&#123;&#123; post.date | date: \"%m月%d日 %y年\" &#125;&#125; 这就是最基础的语法了，所以接下来就可以开始写模板了，现在看下我的归档页面核心代码吧： 123456789101112131415161718192021222324252627282930//使用 assign 标记，给变量赋值，变量没有具体类型，跟js一个样&#123;% assign year = false %&#125;//遍历所有文章&#123;% for post in site.posts %&#125; //取出这篇文章的发表时间，使用过滤器获得年份，比如：2017 &#123;% assign pyear = post.date | date:'%Y' %&#125; //如果和外面那个year变量不相等，则将改年份显示为标题，并且重新记录该年份，直到出现别的年份时再次显示为标题，重新赋值，一直重复这个逻辑 &#123;% if pyear != year %&#125; &#123;% assign year = pyear %&#125; &lt;h1 class=\"year p-header\"&gt; &#123;&#123;year&#125;&#125; 年&lt;/h1&gt; &#123;% endif %&#125; &lt;ul class=\"post-list\"&gt; &lt;li&gt; &lt;div class=\"row\" &gt; //显示该文章的标题和时间 &lt;div class=\"col-md-2\"&gt; &lt;span class=\"meta-date\"&gt;&#123;&#123; post.date | date:\"%m月%d日\"&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-md-10\"&gt; &lt;a class=\"meta-title\" href=\"&#123;&#123; post.url &#125;&#125;#1\"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; //遍历该文章的所属的分类，一一显示出来 &#123;% for category in post.categories %&#125; //点击分类进入该类的列表页面，url_encode作用是进行url编码这个地址 &lt;a class=\"meta-category\" href=\"/categories/&#123;&#123; category | url_encode &#125;&#125;/index.html\"&gt;[&#123;&#123; category &#125;&#125;]&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&#123;% endfor %&#125; 常用过滤器汇总： date : 格式化日期 first : 取数组第一个元素 last : 取数组最后一个元素 sort : 对数组元素排序 size : 字符串、数组的长度 url_encode : url 编码字符串 minus : 做减法运算，在计算两个日期间隔时，我使用过 strip : 去掉前后空格，tabs，换行 more filters Jekyll 内置对象学习了这几个案例之后，是不是就可以开始写自己的模板了，按理来说是的，因为你已经入门了，但是现在还有个问题，如何知道可使用哪些 Liquid 对象呢？以上案例中的 post.title , site.posts , post.categories 对象都是哪里来的？ 这个问题可以在 Jekyll 的官网找到答案：Liquid Variables，Jekyll 已经为你内置了很多对象了，你可以去查询。我列举下我的博客用到的对象，方便读者快速的上手： site 对象 : 整个站点抽象出来的对象 categories 属性，整个站点的所有分类[category] 每个分类category是个数组[name,posts]，第一个元素是该分类的名称，第二个元素是所有属于该分类的文章，可以通过 first、last 过滤器快速的取出来 posts 属性，整个站点的所有文章[post] post 对象 : 对应一篇博客 date : 发布日期，常用过滤器 : date:”%y年%m月%d日” title : 博客标题 excerpt : 简介 page 对象 : 代表当前页面 date : 页面对应博客的发布日期 previous : 该篇文章的上一篇博客 title : 标题 url : 地址 next : title : 标题 url : 地址 content 对象 : 文章的内容，解析后的HTML，并非 Markdown 哦 问：post 和 page 对象的属性差不多，该如何选择 ？我最初也有些糊涂，已经有 post 对象了，干嘛还搞个 page 对像呢？其实是这样的，post 是 site 的属性，想要获取 post 必须要通过 site 对象！当写一个归档页面，或者分类页面模板时非常有用！但是当你写博客正文的模板时，还使用post对象的话，就显得很费劲了，你可能都不知道该怎么从 posts 数组里获取到当前博客对应的 ‘post’ ！因此，这时就是 page 对象展现魅力的大好时刻，page 对象就是当前页面的抽象，你可以轻松地获取到标题，时间等，除此之外还能获取到前一页和后一页呢！ 学习地址: shopify.github.io liquid.bootcss.com 完Liquid 标记语言的使用方法，Jekyll 内置对象就先介绍到这里，接下来你可以尝试去写属于自己的博客模板了，有问题的话，可以留言交流！","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"}]},{"title":"使用 WorkSpace 管理共享代码","slug":"2017/05/19-use-workspace-share-code","date":"2017-05-19T14:47:32.000Z","updated":"2018-03-27T14:45:15.692Z","comments":true,"path":"2017/05/19/2017/05/19-use-workspace-share-code.html","link":"","permalink":"http://debugly.cn/2017/05/19/2017/05/19-use-workspace-share-code.html","excerpt":"","text":"在上篇博客中提到可以把通用代码打成静态库，然后多个项目可使用多个 Framework 包裹这些静态库的方式共享通用代码，详见最后的思维导图！这个方案的确是可行的，但是只用了两天就被干掉了！原因是太不方便了！程序刚好崩溃到打到静态库中的方法了，没法搞断点去一步步 debug ，降低了开发的效率！这种方案也不是完全没有用武之地，比如现在有几和后台商议好的加密算法，一般不需要人人都知道，省得泄漏出去，这时就可以把加密算法打成库，然后需要用的时候把库加到自己的 Framework 里就行了！ 因此需要继续摸索共享代码的方式，既要满足需求，又要方便调试！方便调试的话没办法，只能开放源码了，所以我想到了 Workspace ，其实我早该想到的，不知道为何我先想到的是使用 Framework 包裹 静态库的方式，按道理我应该先想到使用 Workspace 共享才对，因为从一开始我就是使用 Workspace 管理的工程！ 简单说下 Workspace 和 Project 的关系，一般情况下一个项目对应一个工程（Project)，有时候为了方便管理就把几个工程都放在一起，这时就要使用 Workspace 了，因为这是 Project 是平级的关系，不是包含的关系，当然 Project 也可以包含，今天不说包含的事哈，既然是平级的，那总得来个管事的吧，这就是今天的主角— Workspace ！说得直白些就是她管理了 N 个 Project ，实质上就是记录了 Project 的索引而已，最常见的是使用 Pods 的工程，会自动生成一个 Workspace，包含了原来的 Project 和 名为 Pods 的 Project ！ 思考是有局限性的，或者说之前的考虑是陷入了一个胡同里了，觉得搞成静态库后者框架才能共享，其实不用，比如现在的工程目录结构是这样的： workspace projectA libCC projectB 其实 B 工程是可以直接添加 A 工程里的代码的，对于 B 而言就把 projectA 当做一个文件夹就好了，不要考虑太多，加入的时候不要选择 copy 就行了，这样其实就是共享了！为了凸显 libCC 是通用的，因此我们整理下工程目录： workspace libCC projectA projectB 这样从结构上就能一目了然了，接下来 A 、B 都添加下 libCC 到工程，都不要 copy !!! 即只添加引用，文件仍旧在 libCC 目录；由于实体文件仍在 libCC 里面，所以无论 A 、B 谁修改了源码，对方都可以立马更新，如果添加新的文件，则需要再次添加下哦！ libCC 可以到 Workspace 里和 A、B 同级，也可以不添加，我就没添加，感觉是多余的，因为没其他的用途，不会因为没有在 Workspace 里添加索引就导致 A、B找不到 libCC 了。 其实，共享 libCC 跟 Workspace 没多大关系，只不过 A、B 是 由 Workspace 管理的，如果你不用 Workspace 的话，直接创建个 libCC 的文件夹也能共享，只要不 copy 就行了！这才是重点！！ 比起包裹静态库而言，这种方式才是我想要的呢！","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"使用 Framework 包裹静态库共享代码","slug":"2017/05/17-sharecode-framework-wrap-static-library","date":"2017-05-17T14:19:28.000Z","updated":"2018-03-27T14:45:15.692Z","comments":true,"path":"2017/05/17/2017/05/17-sharecode-framework-wrap-static-library.html","link":"","permalink":"http://debugly.cn/2017/05/17/2017/05/17-sharecode-framework-wrap-static-library.html","excerpt":"","text":"正如上篇博客介绍的，提取公共 Framework 确实能够让多个 SDK 共享基础代码 ！这毋庸置疑，我们已经实践了好几个项目了，但是随着业务的发展，发现这个粒度有时还不够细，换句话说 SCF 包含的东西多了些，对于某些项目而言不需要用这么多的功能，SCF 显得有些臃肿了，这要怎么办？ 背景去年的这个时候，我来到了这个团队之后，开始做千帆直播 SDK ，经过一年的时间已经迭代到了线上 2.4 版本，而现在我又接到任务做开放平台的点播 SDK，且称之为 SohuVideoFoundation。这只是个巧合，但时间上的重合挺有趣的。 准备开搞开始做之前，我都会去思考下架构上的问题，这次又遇到了新的问题了： SohuVideoFoundation 是需要对外公开的，目前只需要用到网络库，解析库，这些库已经包含在 SCF 里了，不过 SCF 提供的功能不止这些，所以包的体积自然会大些，既然是对外公开，那就代表的是公司的技术水平，逼格自然要提升上去，我不禁心里一颤，因为我是第一次对外去做，之前面向的都是公司的兄弟部门，较为熟悉！ 基于以上的顾虑，因此我决定 SohuVideoFoundation 不依赖 SCF ，但是如何共享网络库和解析库呢？这是个新的问题，我也不愿意去 copy 代码，因为日后难以维护，给代码升级带来麻烦！ 为了方便，以下将 SohuVideoFoundation 简称为 SVF 。 寻找方案我最初的设想是，将网络库打成 Framework ，然后分别包含到 SCF 和 SVF 里，结果我失败了，得出的结论是： A.Framework 不能包裹 B.Framework ，即不能把 B 的可执行文件一并打 A 里面，或者说不能嵌套。 如果有办法的话，请联系我，谢谢！ 然后我就转向了使用静态库的方案，我将网络库打成了静态库，然后分别包含到 SCF 和 SVF 里，结果我成功了，得出的结论是： A.Framework 能包裹 B.a ，能把 B 的可执行文件一并打 A 里面，或者说 Framwork可以包裹静态库。还记得上一篇博客的总结吗？（Framwork包裹静态库时，也可以不copy可执行文件！） 所以，最终的方案就是：将需要在 Framework 之间共享的代码打成静态库，然后 Framework 包裹该静态库！ 思维导图这是调整后的工程框架结构图： 解释： SCNetworkKit.a : 最底层的共享网络库 SohuVideoFoundation.framework : 开放平台的播放器 SDK ，包裹了 SCNetworkKit SohuCoreFoundation.framework : 共享框架，包裹了 SCNetworkKit 为以下几个 SDK 提供服务 SohuLiveSDK.framework : 千帆直播SDK ，基于 SCF SohuOneSDK.framework : 千帆夺宝SDK ，基于 SCF SohuGameSDK.framework : 千帆小游戏SDK ，基于 SCF SohuEduSDK.framework : 搜狐课堂SDK ，基于 SCF 完到此为止，我们的目的已经达到了，怎么样？是不是感觉做 SDK 越来越有意思了呢？几乎每做一个项目都会引发一次对工程的结构的变革，这些变革也正是一次的尝试与思考的成果！","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"使用 Framewrok 管理共享代码","slug":"2017/05/16-sharecode-use-framework","date":"2017-05-16T11:43:28.000Z","updated":"2018-03-27T14:45:15.691Z","comments":true,"path":"2017/05/16/2017/05/16-sharecode-use-framework.html","link":"","permalink":"http://debugly.cn/2017/05/16/2017/05/16-sharecode-use-framework.html","excerpt":"","text":"这不是一篇讲解如何使用 Xcode 创建 Framework 的教程，而是代码共享的一个解决方案！ 背景今年 2 月刚迭代完千帆直播 SDK 之后，我们启动了 夺宝SDK 的开发工作，除了常规的产品需求外，有个特殊的要求： 作为千帆直播 SDK 的组成部分（集成到搜狐视频） 单独提供给千帆直播 App 思考听起来挺简单的，仔细考虑后，并不简单，原因如下： 时间有限，不可能重复造轮子，所以千帆直播SDK里的代码要共享 为了日后维护方便，相同的代码不能 copy 两份(这是我的原则) 夺宝 SDK 要具备单独提供的能力 夺宝 SDK 要具备组件的能力 为了更加简单的解决这个问题，我是这么思考的，先解决上面列举的前 3 条，先不考虑第 4 条；因此我需要考虑夺宝 SDK 如何共享 千帆直播SDK 的通用代码，我不喜欢 copy 代码，所以没有更好的办法，只能是将通用代码抽取出来了，可以使用静态库（.a），也可以使用框架（.framework），你会怎么选择 ？ 开搞我不喜欢静态库，因为使用的时候很不方面，他的可执行文件和头文件是分开的，甚至于使用的时候还要设置下 search path ！因此我毫不犹豫的选择了框架，框架的名字命名为 SohuLiveFoundation。 辛好千帆直播 SDK 工程的代码组织的还不错，所有通用的库均在 libs 文件下，接下来的工作几乎成为了搬运 libs 到 SohuLiveFoundation 工程，由于现在还没开始做，只是准备工作，因此只把网络库，解析库，缓存库，下载图片库等很通用的搬运下，日后用到哪些再具体分析决定是否搬运，如何搬运的问题。 接下来创建了夺宝 SDK 的工程，命名为 SohuOneSDK，为了使用通用库，所以要引用下 SohuLiveFoundation 库，然后随便写了个界面，发了个请求，简单模拟下，只要能用就行，然后再来到我的 Demo （模拟 千帆App），尝试在 Demo 里调用 SohuOneSDK 的功能，这里要注意的是： SohuOneSDK 只是引用了 SohuLiveFoundation，并不包含（copy）其可执行文件，这个从大小上可以看出来，SohuOneSDK 刚创建，文件比较少，很小的；而 SohuLiveFoundation 包含了的文件多，要大一些； 由于 SohuOneSDK 没有包含 SohuLiveFoundation 的可执行文件，那么在执行的时候就要保证能够找到对应的可执行文件！因此要在 demo 里导入 SohuLiveFoundation 和 SohuOneSDK ！ 假如 A.framework 使用了 B.framework ，在编译 A 的时候，并不需要找到 B 的可执行文件，只需要 B 库的头文件即可，从而避免编译报错，并且给调用 B 库的地方分配个相对的函数调用地址或者说是占位符，以后再具体填充；所以在集成 A 库的 App 里必须导入 B 库，而在 link 的时候也会把 A 库里的占位符换成 B 库的可执行地址.具体怎么换的我也不清楚，因为 App 里使用了 A 库，也需要把 A 库的占位符替换下，具体按照什么循序来的，我也不确定。 搞定组件化到目前为止，已经实现了前 3 条了，我们再回过头来看下第 4 条 — 将夺宝 SDK 作为直播 SDK 的一部分；由上面提到的理论大家很容易想到，可将 SohuOneSDK 引用到 SohuLiveSDK（千帆直播SDK），而 SohuLiveFoundation 为 SohuOneSDK 和 SohuLiveSDK 提供基础支持，集成到视频的时候，将这三个 framework 一并提供集成即可，这里需要说明的是，SohuOneSDK 和 SohuLiveSDK 均不包含 SohuLiveFoundation 的可执行文件，好处就是避免符号重复定义！！！ 最初的时候感觉不好实现呢，现在看来貌似这倒是成了简单的事情了，O(∩_∩)O哈哈~。接下来的事情，就是在 SohuLiveSDK 里完成对 SohuOneSDK 的调用封装，我们不希望视频 App 去调用 SohuOneSDK 的任何功能，毕竟他只是个组成部分而已，况且入口都在 SohuLiveSDK 里面！ 事实证明，这个方案是可行的，确实满足了单独提供和作为组件的需求！ 经过试验，如果 A.framework 里使用了 b.a 的话，你也可以只导入 b 库的头文件，而在 A 集成的 App 里添加下 b 库的可执行文件！道理是一样的，毕竟 framework 可以简单的等同于一个包含了可执行文件和头文件的 bundle(文件夹). 思维导图 集成到视频 集成到千帆App SLF -&gt; SCF随着时间的推移，我们做了更多的项目，包括 搜狐课堂 和几款 千帆小游戏，我们在做搜狐课堂的时候发现 SohuLiveFoundation 这个名字不太合理，里面包含有直播字眼，透漏出的是直播相关的内容，课堂是个单独的项目，虽然也要集成到搜狐视频了，但跟千帆直播SDK 没关系，最初共用于夺宝 SDK 还没问题，但是这时我们发现 SohuLiveFoundation 这个名字已经不合时宜了，我们是个最求完美的团队，哪怕是个名字也要完美！ 因此我们在开启搜狐课堂的开发之前，就将 SohuLiveFoundation 重命名为 SohuCoreFoundation 了！并且这也作为我们的新纪元，开始了 Foundation 的 2.0 版本，内部简称 SCF ！ 随后的项目—搜狐课堂，千帆小游戏均是构建在 SCF 的基础之上。","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"Mac 上配置 Apache 服务器","slug":"2017/04/17-apache-vhost","date":"2017-04-17T14:58:19.000Z","updated":"2018-03-27T14:45:15.691Z","comments":true,"path":"2017/04/17/2017/04/17-apache-vhost.html","link":"","permalink":"http://debugly.cn/2017/04/17/2017/04/17-apache-vhost.html","excerpt":"","text":"我在业余时间搭建了一个博客式 SDK 分发服务器，用于公司内部分发 SDK 到其他部门，挺方便的，提交完代码，一键远程打包，打完自动上传到服务器，生成下载地址，不影响本地工作…因此用到了一些 Apache 的知识，日后也会着重介绍下我的分发服务器… 如何控制ApacheApache 要启动一个系统服务，可能没有权限，一般 sudo 即可； 检查Mac 系统自带的有 Apache，不用自己去下载的，除非你觉得不适合你；查看下版本信息： 1234apachectl -v///正常会输出类似以下的信息Server version: Apache/2.4.23 (Unix)Server built: Aug 8 2016 16:31:34 看到这个就 OK 啦，你可以启动啦 ！ 启动 sudo apachectl start 启动后浏览器访问：localhost 就会看到 It workes. 重启 sudo apachectl restart 关闭 sudo apachectl stop Apache 目录下重要的配置文件 /etc/apache2/ : 是 Apache 的相关目录 etc/apache2/httpd.conf : 是 Apache 最重要的配置文件了；操作前千万要记得备份，万一搞坏了可以还原！！！我就吃了大亏了，害得我后面搞虚拟主机花费了好长时间。。。 1sudo cp /etc/apache2/httpd.conf /etc/apache2/httpd.conf~backup etc/apache2/extra/httpd-vhosts.conf : Apache 是模块化的，配置虚拟主机的话最好是在这个配置文件里做，不要直接写在 httpd.conf 里，当然你就是想写再 httpd.conf 里也会生效的，这个配置文件最好也备份下。 配置 Virtual Hosts虚拟主机有多种，可基于 host，IP，port；我需要用的是在本机配置，因此我采用同一 IP 不同 port 的方式； 没有备份的话，上面提到的两个配置文件快去备下份！ 启动Apache，看到 It works. 保证你的Apache是好用的。 找到 httpd.confg 文件，使用 vi 或者 Atom 之类的文本编辑器编辑； 想好你的端口号了吗？没的话就随便想个吧；搜索 80 ，大概在 52 行，你接着写要监听的端口号： 123Listen 80Listen 8000Listen 9000 除了默认的80端口之外，我还配置了 8000 和 9000，端口不要太小，太小的端口可能会被别的服务占用！ 搜索 vhost，大概在 160 行左右，找到 1#LoadModule vhost_alias_module libexec/apache2/mod_vhost_alias.so 去掉前面的 #,这个 # 表示注释，我们要使用虚拟主机功能，因此让 Apache 加载对应的 so 模块！ 继续搜索，大概在 500 行左右，找到 1#Include /private/etc/apache2/extra/httpd-vhosts.conf 也是去掉前面的 #，为的是让 Apache 加载 httpd-vhosts.conf 配置文件！ 接下来关闭并保存 httpd.confg 文件，打开 httpd-vhosts.conf 配置文件；就可以配置虚拟主机了，比如： 1234567891011121314151617181920212223242526272829&lt;VirtualHost *:80&gt; DocumentRoot &quot;/Users/xuqianlong/websites/apache&quot; &lt;Directory &quot;/Users/xuqianlong/websites/apache&quot;&gt; Options FollowSymLinks Multiviews Indexes MultiviewsMatch Any AllowOverride None Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost *:8000&gt; DocumentRoot &quot;/Users/xuqianlong/websites/apache/aa&quot; &lt;Directory &quot;/Users/xuqianlong/websites/apache/aa&quot;&gt; Options FollowSymLinks Multiviews Indexes MultiviewsMatch Any AllowOverride None Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost *:9000&gt; DocumentRoot &quot;/Users/xuqianlong/websites/apache/bb&quot; &lt;Directory &quot;/Users/xuqianlong/websites/apache/bb&quot;&gt; Options FollowSymLinks Multiviews Indexes MultiviewsMatch Any AllowOverride None Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 我配置了 3 个端口号，分别指向不同的目录，并且配置了目录的访问权限；接下来可以测试了，浏览器输入： 123localhost ///对应 /Users/xuqianlong/websites/apache 目录下的内容localhost:8000 ///对应 /Users/xuqianlong/websites/apache/aa 目录下的内容localhost:9000 ///对应 /Users/xuqianlong/websites/apache/bb 目录下的内容 这里也有个坑，就是你可能会遇到 403 的情况，我就遇到了，搞了半天才解决，原因是 DocumentRoot 目录不能在 /Users/xuqianlong/Documents 目录下，也就是不能在个人用户的文稿目录下！！！ 困惑如果你仔细看 httpd.conf 配置文件的话，你会发现大概235行处也有DocumentRoot 和 Directory 的配置： 12DocumentRoot &quot;/Library/WebServer/Documents&quot;&lt;Directory &quot;/Library/WebServer/Documents&quot;&gt; 这和 httpd-vhosts.conf 里的差不多，他们有什么关系呢？老实说这个我现在还没搞明白，不过这个一般别改，要么就是不配置虚拟主机，直接把这个改为你自己的服务器目录，也是能访问的，我试过，可如果你既修改这个又在 httpd-vhosts.conf 里配置就很容易出问题，我就出了问题了，后来找的备份，重新搞的，所以我在前面开始操作前就再三提醒大家要备份！！！ TODO打包服务器还不支持 iOS OTA，主要是没有 SSL 证书，购买的话不划算，太贵了！准备自签一个，然后配置下 https，为搭建 OTA 做好准备！","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"Block 使用方式由浅入深","slug":"2017/02/12-fuckblocksyntaxtoo","date":"2017-02-12T13:29:57.000Z","updated":"2018-03-27T14:45:15.690Z","comments":true,"path":"2017/02/12/2017/02/12-fuckblocksyntaxtoo.html","link":"","permalink":"http://debugly.cn/2017/02/12/2017/02/12-fuckblocksyntaxtoo.html","excerpt":"","text":"Objective-C 语言一直以来由苹果公司维护着，为其增加了不少更加现代化的语法，其中 block （其他语言一般都称闭包）语法就是在 iOS 4 发布的，与此同时还提供了抽象程度极高的GCD 技术，用于简化线程的操作！所以今天说的 block 并不是新的技术，但它恐怕是最难记忆的的语法了，并且使用形式很是灵活，因此总结一下我平时使用的几种类型，供大家参考。 特为此写了个 demo 来帮助理解。 1.描述为属性这是最为常见的用法了，一般都是先赋值，当触发某个逻辑时进行回调； 123@property (nonatomic, copy) returnType (^blockName)(parameterTypes);self.blockName = ...;//赋值一个blockself.blcokName(parameters);//调用 2.作为形参(parameter)，做回调a.经常和属性配合使用；一般场景是方法内部有异步执行的任务，执行完毕后通过这个block参数回调到调用处； 12345- (void)doSomeThingWithCompletion:(retunType (^)(parameterTypes))blockName&#123;async(...&#123; blockName(parameters);&#125;);&#125; b.相当于写个 setter 方法，给 block 属性赋值，直接给属性赋值的话需要手写实现 block ，不容易记，这其实是为了方便调用者而已。 1234 - (void)registerXXXHandler:(void (^)(float))handler&#123; self.xxxHandler = handler;&#125; 3.作为实参(argument)，实现block调用一个带有 block 参数的方法时，就需要实现这个 block 了，其实这个不用手写，IDE 会提示的，直接回车即可； 123[self doSomeThingWithCompletion: ^retunType(parameters)&#123;//...&#125;]; 4. typedef 出”新类型”以上使用一点也不友好，所以基本上我们都会使用 typedef 定义一个类型出来； 1234typedef returnType(^ TypeName)(parameterTypes)//以上用法可改为：@property (nonatomic, copy) TypeName blockName;- (void)doSomeThingWithCompletion:(TypeName)blockName; 5.方法内部当局部变量使用如果一段代码里有很多个 if else 分支，某些分支的处理完全一样时，可将他们封装到一个block块里面；可以省去写相同代码的麻烦，也不必开辟一个新的方法； 123returnType (^blcokNmae)(parameterTypes) = ^returnType(parameters)&#123; ... &#125;;//调用：returnType result = blcokNmae(parameters); 6.方法返回值这种情况不太多，比如可用于实现链式编程； 123456789//声明- (returnType (^) parameterTypes) method;//实现- (returnType (^) parameterTypes) method&#123; return ^ returnType (parameters)&#123; //... return obj;//obj 是 returnType 类型 &#125;;&#125; 举个例子： 12345678910///设置url- (SLNetworkRequest *(^)(NSString *url))c_URL;- (SLNetworkRequest *(^)(NSString *url))c_URL&#123; return ^ SLNetworkRequest * (NSString *url)&#123; self.urlString = url; return self; &#125;;&#125; 7.高阶 Block : 作为另一个Block的参数这种情况用的不是太多，但是一旦有需要双向交互的场景时，优势就很明显了！具体可看 demo 实现的 3G 网络询问用户是否下载的场景： 12typedef returnType(^ Block1)(parameterTypes)typedef returnType(^ Block2)(parameterTypes, Block1) //Block1作为Block2的参数部分 可实现双向通信，比如： 123456789101112131415161718192021222324- (void)doSomeThingWithCompletion:(Block2)blockName&#123; async(...&#123; Block1 block1 = ^(isOk)&#123; if(isOK)&#123; //start download... &#125;else&#123; //cancel something... &#125; &#125;; blockName(parameters, block1); &#125;);&#125;调用：[self doSomeThingWithCompletion: ^ returnType(parameters, block1)&#123; //内部处理完毕后，回调到此； //根据结果（parameters）做相应的逻辑，然后将处理结果再次回调到方法内部 if(parameters)&#123; block1(NO);//通过block1再次回调回去告知可以进行下一步了 &#125;else&#123; block1(YES);//通过block1再次回调回去告知不能继续 &#125;&#125;]; 最近我制定了 H5-Native 的交互方案，编写交互需要注入的 js 脚本，通信 API 也是双向的，其原理就是 block (闭包)的嵌套使用；API 出来后 H5 和 Native 的开发同事们都很 Happy 呢！ 如果你有其他有趣的使用方法，请提供给我吧！ 前五个算是翻译，不过也确实是工作中经常用的，原文地址 : http://fuckingblocksyntax.com","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"致炫收音机改为家用音响","slug":"2017/01/10-household-zhixuan-radio","date":"2017-01-10T12:55:16.000Z","updated":"2018-03-27T14:45:15.690Z","comments":true,"path":"2017/01/10/2017/01/10-household-zhixuan-radio.html","link":"","permalink":"http://debugly.cn/2017/01/10/2017/01/10-household-zhixuan-radio.html","excerpt":"","text":"最近买了辆小车—丰田-致炫，不是高配的，所以没有导航，雷达，倒车影像等，只有一个收音机，CD 都不带… 上周六去汽配城装了导航和倒车影像，原车的收音机就被毫不客气的抛到后备箱里了，作为一个 Geeker ，不可能把他扔掉或者当破烂卖了，即使卖也是白菜价(论坛里有人出20大洋，呵呵)，这些对于一个电子爱好者来说都是宝贝啊！必须改装，为我所用才是王道… 先睹为快放在客厅的电视柜旁边，貌似违和感不强哈： 功能简介 原电脑电源键开关机 可以听广播 可以当做音响 双 USB 5V 输出 双耳机插孔，可接入更多🔈 TODO： 大喇叭周围加上闪灯（大学用三极管做过一个三个灯循环闪烁的，可以拿来用） 原理 电脑电源为收音机主机提供稳定的 12V 电源，和 5V 的 USB 电源； 喇叭装在箱子里才会更响，因此充分利用了空间足够大的机箱； 电脑电源不是插上就会输出的，这里刚好可以装个开关，具体往下看哈 改装过程准备 12V 电源原本收音机使用的是车上 12V 蓄电池的直流电，家用的话就必须找到一个稳定可靠的 12V 直流电源，常见的有台式电脑电源，或者显示器适配器的电源也行；使用台式电脑电源的好处的输出功率大，电压多，可以做些别的事情；适配器的比较容易些，插上就会输出，直接用就好了，电脑电源稍微复杂一些，需要略懂电路。 这是我在网上找的一个图： 要想启动电源必须将绿色线和黑色线短路，绿色线很好找，全局唯一，就一根！（如果色盲，就麻烦了，绿色老多了） 可以看到，提供的电压有 -12V,3.3V,5V,12V,挺丰富的。下面这个是具体的从电源输出插在主板上的接线头： 这台老台式机是老乡送给我的，可以开机，就是慢的不行，我也没啥用，因此就牺牲他吧，我将绿色 和邻近的黑色 GND(其实就是 0V，平时说的 5V是相对于 GND 的) 剪断，可以先试试下电源是否正常，插上电之后，将绿色线和 GND 短路，你会发现电源风扇开始转了，这表明电源应该是正常的！ 接下来说下 12V 电源，你可以按照上图所标识的黄色线，我并没有使用这个，是因为我发现除了这个还有好几根也是黄色的，供硬盘或者 DVD 使用，这个线比较长，更刚才那个插到主板的不是一条，很方便，因此我使用的是硬盘电源线。 为收音机接输出线收音机是个盒子，没有一根线，需要接线，如果怕麻烦可以直接去网上购买，我查了下只需 10 个大洋，还带了天线；由于我等不及了，所以直接拆开用烙铁焊接输出线；这是电源和音频输出： 我将原来的接线柱一一去掉了，然后焊接线，这里需要注意的是，ACC（12V 正极）需要按照下图所示，将3个接线柱短路，黑色是 GND，其他四个颜色是对应的前后4个喇叭： 这是天线，需要接个线出来，否则收音机收不到信号📶： 连接这两根（一根也行）就行了： 最终接线效果： 准备大喇叭，USB，电源键这个喇叭是我大学时在校园里捡到的（坏了的广播），一不小心默默跟随我好几年，今日终于排上了用场！ 刚好这里有几个面板（原本是为DVD预留的）可以拆掉，省去了不少力气呢，出门在外没有更多东西选择，用红绳绑吧： 原来的 USB 插孔坏了一个，我把路由器上的换过来了，然后线路需要改下，没拍照就不细说了； 电源这里需要换个开关 ：因为机箱上这个开关是没锁的，意思是只有按下时是连通的，松开手就是断路了!还记得我们前面说过的如何启动电脑电源吧，需要持续短路绿线和GND，短路一下可不行！ 要想找到一个一样的开关可是不容易，我差点就放弃了，好在我又找到了一个大学做的LM386电路（简易小功放），上面刚好有一个这样的开关，甚是高兴，毫不犹豫牺牲他吧，实话说，这个 LM386 效果真是差得很，就是练手试下，基本没用过，可惜忘记拍照了，这个是去掉开关后的： ps:红色灯是电源指示灯；黄蓝绿是上面我提到的循环闪烁灯，等有时间了把这个拆掉，装到喇叭周围去；原本用来指示硬盘读取情况的蓝色灯，这里用来指示音量的高低，音量高时会亮，音量一般都是起伏的，所以会闪，不过单纯的依赖喇叭的电源差点亮LED，还是有点挑战的，所以声音小的时候不会亮… 接线收工 电脑电源黄色线接收音机红色线，黑色GND相接； USB 接 5V 橙色线，注意正负极； 大喇叭接在耳机插孔那里，耳机插孔其实也是带开关的，不插入耳机时播放大喇叭，插入口断开，没有拍照就不详细介绍了; 电源指示灯，接 3.3V ，注意需要配个电阻哈； 音量指示灯，我直接接到大喇叭上了，音量调到40以后才会闪烁，效果不佳，技术有限，也不知道如何改进… 换导航场景 After Word这是一种乐趣，恐怕也只有同为 Geeker 的你才能了解吧，你可能不能理解，工作的时候，几乎都是蹲着，电烙铁烧到手指也无所谓，可能昨晚刚装好，今天又要拆开；等我连续搞了3个晚上完工后，发现还不错，物有所用，之前积攒了几年的东西，终于用武之地！ 每天早晨起来可以听个新闻了，声音清晰够大，整个屋子都可以听到，仿佛回到了老家的生活方式，我能告诉你，老家还有个与之类似的收音机么…","categories":[],"tags":[{"name":"生活中的欢乐","slug":"生活中的欢乐","permalink":"http://debugly.cn/tags/生活中的欢乐/"}]},{"title":"我的 2016","slug":"2016/12/31-my2016","date":"2016-12-31T11:52:32.000Z","updated":"2018-03-27T14:45:15.690Z","comments":true,"path":"2016/12/31/2016/12/31-my2016.html","link":"","permalink":"http://debugly.cn/2016/12/31/2016/12/31-my2016.html","excerpt":"","text":"要和 2016 说再见了，是时候对今年做个总结了，今年是不平凡的一年，因为发生了几件人生重大的事情，还是按照时间顺序来说吧，这样简单些。 三亚4 月 — 也就是刚过完年不久，天还有些冷的时候，我和未婚妻去了趟三亚，目的不是去旅行，而是去拍婚纱照。 8 号，我们乘坐地铁从丰台东大街出发到东直门换乘机场线，然后到达北京首都国际机T2航站楼。找到自助机器办理值机、领取登机牌，一般很快不需要排队，找到对应的航空公司的机器就行了；飞机上比较严格，跟坐火车不一样，因此带东西要谨慎，否则就要办理行李托运，这一般都需要排队，并且下了飞机后还要等一会才能拿到自己的行李；我们乘坐的是南方航空的CZ6712次航班，好像挺准时的，登机就坐后会引导关闭手机等设备，飞机起飞前会在跑道上兜几圈，具体我也不知道是为何，是在等点么？起飞时心里还是蛮紧张的，升空后一直斜着往上爬，会有超重的感觉，脑袋稍微有些晕，有孩子的话，这时估计孩子会哭声一片，大概过上一二十分钟，经过两三次之后，飞机就趋于稳定了，固定在 10000 米左右的高空，飞行速度大概是600~700Km/h; 然后就会有空姐过来送免费的午饭和饮料，一般搭配的会有蔬菜盒和咸菜小面包等，吃起来还行。经过四个小时的飞行，我们顺利抵达了三亚凤凰国际机场，第一感觉就是热！毕竟我们是从大北方而来。婚纱店包含了接机的，然后坐着他们找的车就到了酒店，确实如他们所说是真海景房，在阳台上就能看海，很是兴奋，然后去了让婚纱店，毕竟这是正事，挑选了明天的礼服，然后迫不及待去海边了，光着脚丫踩在柔软的沙滩上，任凭海浪一个接着一个拍打，晚上找了个地方去吃了海鲜，期待着明天的拍照！ 南海观音像 酒店对面的大海 9 号先去了大小洞天景区拍摄了一套白色的婚纱，主要是海边和椰子树下拍，由于是 4 月，还没到旅游的旺季，人不是很多，方便拍摄取景，这一张是我用手机拍的 然后换了套衣服去了海天一线拍，海天一线分为两部分，前面是一个游泳池，后面便是大海，拍出来的效果就是人都在水面上，除了水便是天，摄影师在游泳池这头拍摄，新人们站在游泳池的对面岸上，之间有几十米的距离，说话听不清楚，所以要和摄影师配合默契些才行！要想拍的效果好些，要放松，别拘着，多想一些开心的事情。 接下来离开了景点换了套衣服，去了海上的大游艇上拍，我挺喜欢她的这套衣服的，也留了不少的照片，甚至于现在的电脑桌面也是这套衣服的。 这是自拍的 接下来就到了傍晚了，在海边拍些夕阳之类的，然后就到了晚上了，到了婚纱店所在园区内又拍了套，一共是拍了 5 套衣服。拍了一天挺累的，也拍完了，所以找个地方去“让”人家宰吧。 10 号先是去了西岛，然后是天涯海角 此次去三亚，不枉此行，因为创造了 N 个第一次，和她留下了不少美好的回忆！包括第一次去这么远的地方，第一次一起坐飞机。第一次到海边… 新团队5 月 初我加入了现在的团队（同属于视频，做的业务变了，老大换了），不再从事 App 的开发，而是开启了 千帆直播 SDK 的开发工作，事情是这样的，我们旗下的 56 视频去年开始做直播了，为了快速的导流，打造出搜狐的直播品牌，高层决定做 SDK ，将直播接入流量更大的搜狐视频等核心 App 中，因此就需要人来做这个 SDK ，正好我本身就在搜狐视频 iOS 团队，加上有些技术功底，就毛遂自荐了。事实证明，我来做 SDK 是很合适的，技术上可独挡一面，不会延误工期，对接上，我本来就是那个团队的，人比较熟悉，事情好办些，沟通效率高。因此结果就是 SDK 快速迭代，App 集成简单，一般只是换包即可，有需要我就出差去当面对接，配合得很默契，大家合作都挺愉快的！ 我喜欢自己当老大的感觉，这也是我选择来做 SDK 的原因之一，感觉好像回到了 2015 年我在创业公司的那段时间，那时也是我一个人呢，代码架构任凭我设计，想怎么搞都行，但我也是有原则的人，不会把代码搞得乱七八糟的！一个人的好处是高效，因为我自己跟产品和安卓的同事沟通就 OK 了，剩下的是技术实现，我是个喜欢写代码的人，我可以加班几点的赶项目进度，刚去的前两个月几乎是每天 10 点才多打车回家，度过了那段孤军奋战的岁月之后，7月多陆续补上了两个同事，队伍壮到了 3 人，我不再孤单，代码上也丝毫不敢随意，因为我同事很喜欢整理代码，也有强迫症，我们有个共同的特点 — 最求完美！哪里不合适他会及时提出，和我商议后决定是否要改下，我承认之前一个人有些地方是不太合理的，随着业务的发展，有些问题开始显露出来，不过还好，没有很大的坑，毕竟代码才几个月，我这个作者还在，一切都好改！ 今年我们 千帆直播 SDK 提供给视频和新闻的版本迭代了 8 次，截止目前基础功能已经处于完备了，剩下的是想出些好玩的点子，让用户有粘性，更加的活跃！另外接到通知要做 夺宝 SDK 了，类似于网易一元夺宝，夺宝需要好好架构，有些挑战性！因为她可以作为 千帆直播 SDK 的一部分，集成到视频，也可以单独输出到千帆直播使用，因此需要设计一个架构出来才行，目前已经有了思路了，日后实现后再共享出来吧。 这是SDK的入口之一 竖屏模式 横屏模式 看到这张图，顺便提下横竖屏这块还是蛮有技术含量的，其他的UI还好些，直播流的处理挺麻烦的，需求是这样的： PC直播间：竖屏是半屏显示，转为横屏时要全屏 手机直播间：横竖屏都是全屏的，但是直播流的方向始终不变，因为有的可能会横屏开播，如果做的更 PC 一样流跟随屏幕自动旋转的话，会导致你看的时候总是跟你相差 90 度，你不得不歪着头看。 手机和 PC 可以随时切换 下播之后随时可以开播 实现方案，以后有时间了，我准备写个 demo 出来。 天津前面说了，我是 5 月份加入了新团队，其中有个福利是，解决天津户口，老实说这是吸引我加入的一个重要因素，所以在 8 月 12 日做好了搬家的准备，那天我的同事 — 老头子的故事（衫哥）开车从北京出发，送我们到天津。路上还下了点雨，到达后基本不下了，开始搬东西到楼上，结果差点吓坏我，我们搬着东西到了 22 层，开了半天开不开门了，一个陌生的城市，瞬间感觉被骗了，房子是我一星期前定下的，房租都交了呢！接着就开始敲门，突然门开了，彻底懵逼了，人家直接问我们是干啥的，为啥开他家的门，我赶紧拿合同去看，结果是租的是楼下 21 层的…. 哎，可能是看欢乐颂看得了吧，脑袋里残留了 22 这个记忆，好在有惊无险！ 天津的生活还好，租的房子离家很近，中午还能回家吃个饭，这在北京确实没想过。滨海新区也不限号，外地车确实很多，这里离市区挺远的，一般也不去市里面逛，打算明年暖和了开车去附件多转转，现在该过年了，我需要多熟悉下车，过年准备开车回去。 结婚9 月 18 日我们领证了，22 日在老家举办了婚礼，感谢家人的忙碌，亲戚朋友的捧场，感谢我的同学能够去参加，也帮了不少的忙！ 广州10 月 去了趟广州，目的是确定下支付相关方案，千帆直播 SDK 要接内购，去了没闲着，早晨去玩，晚上约朋友，白天在 56 忙工作，生活很惬意，广州的环境真是好，若是能多呆几天就好了… 华南理工 海珠湖公园，湿地 广州塔 天河公园，突然下大雨我和郑哥被困近一个小时o(╯□╰)o 越秀公园，五羊雕像 买车12 月 24 日是平安夜，这天我收到了爱人给我的一个大礼包，我们买车了，这天她和哥哥从郑州开到了天津，而我在加班。在这里我想感谢下我的老婆和大舅哥，替我操了不少心，让我少了些奔波，节省下时间去安安静静地工作。下图是后来补上的，17年春节回家拍的： 总结今年是不平凡的一年，也是丰收的一年！ 办了人生中的大事，娶到了梦寐以求的老婆，婚后生活很幸福，这就够了！ 工作上换了团队，换了地点，发生了很大的变化，不过领导对我是满意，这就够了！ 技术上也有了很大进步，积累了不少的做 SDK 的架构经验，这就够了！ 2015 年曾经说要在今年多看开源代码的，做的不好，没怎么看，不过网络这块经过几次重构后，感觉已经很不错了，日后准备开源！ 2016 就这样了… 2017 你想怎样 ？试着去努力吧，你就能怎样 ！","categories":[],"tags":[{"name":"个人总结","slug":"个人总结","permalink":"http://debugly.cn/tags/个人总结/"}]},{"title":"千帆 SDK Refactor: 优雅的处理聊天数据源","slug":"2016/12/03-qfsdk-refactor-chat","date":"2016-12-03T04:04:20.000Z","updated":"2018-03-27T14:45:15.690Z","comments":true,"path":"2016/12/03/2016/12/03-qfsdk-refactor-chat.html","link":"","permalink":"http://debugly.cn/2016/12/03/2016/12/03-qfsdk-refactor-chat.html","excerpt":"","text":"以下讨论基于的前提思想是：Cell 和 Model 是绑定的，一一对应的；Cell 是数据源所决定的，Cell 要做的就是展示数据源而已，或者说是先确定的数据源而不是 Cell，因此我们今天以讨论 Model 为主。简单的概括这次重构是为 Cell 建立一个CellModel，他有个实现构建协议的属性，展示前通过协议方法构建 Cell需要的数据并且存储到 CellModel 里，这样的好处是随便一个Model都可以作为数据源使用，只需实现必要的协议，Cell也不必关心数据源到底是谁提供的！ 基于协议的CellModel现状：Cell 绑定 SLLiveRoomModel千帆 SDK 直播间的聊天是通过 UITableview 展示的，今天就来聊一聊如何优雅的处理 UITableview 数据源问题。既然这篇文章属于重构篇，因此我要说出重构的理由哈，这次重构的导火线是聊天区域要展示用户送给主播的千帆盛典票。 聊天是从 Chat 、BC等通道返回的，特点是数据结构类似，最重要的是每个通道只有一种事件（一种 JOSN 结构，没有类型而言）需要处理，因此抽取了一个父类SLLiveRoomModel 采用了工厂的形式去解析，通过增加一个枚举属性来区分开 Model，每个枚举都对应了一个子类，父类的 modelWithSocketJSON 方法里根据 route 字段选择出一个合适的子类，并且确定一个枚举值; 盛典票的 JSON 数据是从 RC 通道返回的，这个通道的有个type字段，用于标识类型，盛典票的type是47(以后简称为 RC47)，不同类型对应不同的业务，目前已经处理了三种类型，这三种类型并不牵涉显示到聊天区，目前的做法是抽取一个 RCBaseModel 父类（相当于工场）用于统一解析JSON为Model； 简单了解了现状和需求之后，我们看下遇到的问题：RC47需要显示到聊天区，而聊天区的数据都是 SLLiveRoomModel 类的子类，RC47 却是 RCBaseModel 的子类，这块无法做到统一！对此我想了两个改动比较小的方案： 将 RC47 继承 SLLiveRoomModel 类; 带来的问题是需要在 RC 通道根据 type 进行不同的解析，就会出现分支，原本应该是 RCBaseModel 的子类，现在却搞成了 SLLiveRoomModel 的子类，Model 解析时不再是统一！如果以后再出现 RC47 的类似情况，分支更多，时间久了逻辑就会碎片化！ 将 Cell 数据源改为 id ,内部通过判断 class 去解决；带来的问题是 Cell 内部的处理显得不够优雅，久而久之也会碎片化！ 改进：Cell 绑定 SLLiveRoomCellModel以上两种方法都是权宜之计，于是我和同事进行了一番讨论了之后，采用我 15 年在创业公司的做法，并且做了个升级(基于协议)，更加优秀了！下面说下 16 版的哈： 基于协议的，将 Cell 需要的数据协议化，Cell 不依赖于真正的数据源（model），而是拥有一个通用的数据源（cellModel），这样的好处就是 Cell 不会对数据源（model）产生依赖，数据源可以是任意类型； 数据源的构建很灵活，不同的数据源仍旧可以使用各自的父类的通用解析方式； 数据源可注册点击事件的 block，不注册意味着不需要点击事件，顶级后无反应； 从实际出发，我的 Cell 需要的展示一个属性字符串，获取到行高而已，因此制订的协议如下： 12345@protocol SLLiveRoomCellModelBuitProtocol &lt;NSObject&gt;@required;- (float)heightForCell;- (NSAttributedString *)attributedStringForCell;@end 再根据需要制订 CellModel，需要的是存储属性字符串、行高、真正的数据源model，如下： 123456789@interface SLLiveRoomCellModel : NSObject@property (nonatomic, assign) float cellHeight;@property (nonatomic, strong) NSAttributedString * attributedText;@property (nonatomic, strong) id&lt;SLLiveRoomCellModelBuitProtocol&gt;model;//真正的数据支撑///构建cellModel必须的行高和显示的属性字符串- (void)buildit;@end 因此任意modle如果想要作为 cell 的真正数据源，只要实现必要的方法才行了，别如 RC47Model、SLLiveRoomModel 等。 整理解析Cell 数据源这块已经整理好了，接下来梳理下从 Socket 通道接收到 JSON 数据到构建出 SLLiveRoomCellModel 的过程： Parser JOSN-&gt;Model 1234- (SLCommonRCBaseModel *)parserCommRCJSON:(id)json&#123; return [SLCommonRCBaseModel modelWithSocketJSON:json];&#125; Build Model-&gt;CellModel 1234567- (SLLiveRoomCellModel *)buildCellModelFromCommRC47Model:(SLComRC47Model *)rcModel&#123; SLLiveRoomCellModel *model = [[SLLiveRoomCellModel alloc] init]; model.model = rcModel; [model buildit];//前面加过注释的，会调用协议方法用于构建； return model;&#125; Show RC47 JSON-&gt;Cell 123456789- (void)append2ChatListWithCommRC47Model:(SLComRC47Model *)model&#123; if (model) &#123; SLLiveRoomCellModel *cellModel = [self buildCellModelFromCommRC47Model:model]; if(cellModel)&#123; [self append2ChatCellModel:cellModel]; &#125; &#125;&#125; 这是整个过程，现在合起来看下RC处理的整个过程： 处理通用组播 123456789101112131415161718192021222324252627- (void)handleComRCEvent:(NSDictionary *)json&#123; SLCommonRCBaseModel *baseModel = [self parserCommRCJSON:json]; switch (baseModel.rcType) &#123; case SLCommonRCType28: &#123; //不需要显示到聊天区，自有别的处理逻辑... &#125; break; case SLCommonRCType32: &#123; //不需要显示到聊天区，自有别的处理逻辑... &#125; break; case SLCommonRCType53: &#123; //不需要显示到聊天区，自有别的处理逻辑... &#125; break; case SLCommonRCType47: &#123; SLComRC47Model *rc47 = (SLComRC47Model *)baseModel; [self append2ChatListWithCommRC47Model:rc47]; &#125; break; &#125;&#125; 可以看出，RC的处理流程是统一的，先解析为Model，然后根据 type 做不同的处理，对于之前的聊天通道的数据处理方式比这个更简单，就不再粘贴代码了，因为那些通道没有 type，比较单一，处理起来更简单！ 整理点击处理逻辑把点击事件的处理跟构建CellModel的逻辑放在一块！这是我的同事给我提的建议，我觉得很好，于是就为 CellModel 加了如下方法，以便于支持注册 Block 处理点击事件： 123typedef void(^SLLiveRoomCellHandler)(SLLiveRoomCellModel *model);- (void)registerHandler:(SLLiveRoomCellHandler)handler;- (void)invokeHandler; 配合点击的代理方法实现 block 回调： 1234567- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; [tableView deselectRowAtIndexPath:indexPath animated:NO]; SLLiveRoomCellModel *cellModel = [self.dataSource objectOrNilAtIndex:indexPath.row]; [cellModel invokeHandler];//回调block；&#125; 看下使用吧： 1234567891011121314- (SLLiveRoomCellModel *)buildCellModelFromChatModel:(SLLiveRoomModel *)cModel&#123; SLLiveRoomCellModel *model = [[SLLiveRoomCellModel alloc]init]; model.model = cModel; [model buildit]; ///只有这种类型才去注册点击事件； if (cModel &amp;&amp; SLLiveRoomMessageTypeBC == cModel.messageType) &#123; [model registerHandler:^(SLLiveRoomCellModel *model) &#123; ///处理点击事件逻辑... &#125;]; &#125; return model;&#125; 看起来不错呢，逻辑很紧凑，构建和点击事件的处理都放在一块了，检查代码，或者把这一块逻辑封装为一个方法等都很方便。 结束语到此，这次数据源和解析的重构就结束了，确实做到了分离，各有自己的继承体系，没有耦合；这次重构很适合直播间的业务逻辑，对于别的业务还是要具体分析才行，不可死搬硬套哈！ 有个细节我想提下，就是从 Socket 通道接受到数据开始均为异步的，直到构建完 CellModel，展示到 Cell 上时才回到主线程，所以即使直播间火爆，一直刷屏也不会因为聊天解析导致卡顿，这个是经过测试的呢！","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"SLNetwork 支持链式编程","slug":"2016/12/02-network-support-chain","date":"2016-12-02T14:00:59.000Z","updated":"2018-03-27T14:45:15.690Z","comments":true,"path":"2016/12/02/2016/12/02-network-support-chain.html","link":"","permalink":"http://debugly.cn/2016/12/02/2016/12/02-network-support-chain.html","excerpt":"","text":"之前用 Masonry 写过一阵子自动布局，感觉很是方便，最大的特点是：使用block，在block块内编写约束即可，方便 update 约束，并且支持链式编程，于是我研究了下如何链式编程后，为我的网络请求也加了这个功能… 思考如何才能做到链式必须满足的一个条件肯定是调用方法之后，方法的返回值调用者本身啦；如何优雅地返回自身对象呢，最简单的方式是这样？ 12345- (SLNetworkRequest *)c_setResponseParser:(id&lt;SLNHTTPResponseParser&gt;)responseParser&#123; [self setResponseParser:responseParser]; return self;&#125; 这样的话，你会发现不行，因为调用的时候太不方便了啊，你得使用中括号的方式调用，点语法也不行了，因为使用点语法的话需要有等号啊！ 为了解决这个问题，我们需要解决的是： 能够支持打点调用；括号不方便! 不能有参数，否则造成调用的时候传参要用等号！ 必须有返回值；返回自身对象； 能够带参数，这样才实用； 基于前 3 点可以写如下方法： 1234- (self)test;//调用self.test; 接下来需要做的是第4点解决传参问题，这根第2点是矛盾的！这个方法是不能支持参数的，可不支持参数方法就会显得很不实用！接下来我陷入困境，貌似一个 OC 的普通方法是无法满足这样苛刻的条件啦，然后我去 github 找了下，索性这没能难住牛叉的前辈们，使用 block 来解决，我们知道 block 的回调形式是这样的： 1ablock(@\"parameter\"); 并且 block 是支持返回值的，我们要将block支持返回值和参数的特性充分利用起来；既然上面我们设计的链式编程的原型有了，所以接着改造吧，我们没有别的选择了，除了返回值之外，因为必须保证调用方式啊！于是乎 block 就有了这样一种奇特的用法，如果你是第一次见到，我觉得十有八九你会不理解的。 先看下方法声明： 1- (SLNetworkRequest *(^)(NSString *method))c_Method; 先不考虑实现，就调用下试试：SLNetworkRequest * req = self.c_Method(@”POST”);困惑吗？怎么传参数使用小括号了？思考下原来是这样：self.c_Method 的作用是获取了一个block，其实就是回调 block(@”POST”);到此外部调用已经通了，我们看下怎么实现这个方法吧： 1234567- (SLNetworkRequest *(^)(NSString *method))c_Method&#123; return ^ SLNetworkRequest * (NSString *method)&#123; self.httpMethod = method; return self; &#125;;&#125; 创建了一个 block ，block 的参数直接给当前对象使用，然后把当前对象作为这个 block 的返回值；block 的调用时机很巧妙，你传参的同时其实就是回调 block ！这到底是谁先想起来的呢？超赞！ 效果于是我干了一会的体力活，最后的结果给大家看下： 有木有很赞？当然也有缺点，block 后面的参数 Xcode 不会自动提示！","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"千帆 SDK Issue: TimeStamp","slug":"2016/11/30-qfsdk-issue-timestamp","date":"2016-11-30T13:03:04.000Z","updated":"2018-03-27T14:45:15.689Z","comments":true,"path":"2016/11/30/2016/11/30-qfsdk-issue-timestamp.html","link":"","permalink":"http://debugly.cn/2016/11/30/2016/11/30-qfsdk-issue-timestamp.html","excerpt":"","text":"简介去年我写过这么一篇文章 《小心 unsigned 数据类型埋下坑》 主要说明了一个问题，一定要小心不能将一个小于 0 的值赋给 unsigned 类型！今天要说的我们经常会给服务传个时间戳，客户端最好不要使用 int 类型来接受，因为很可能程序只能正常运行到 2038 年。 时间戳服务器端需要一个以毫秒为单位的时间戳，同事是这么写的： 1NSInteger time = [[NSDate date] timeIntervalSince1970] * 1000; 结果测试就报了一个bug: ❌ iPhone 5 出现上接口返回参数校验错误… 你如果足够细心你会有个疑问，为何 iPhone5 躺枪了？5s、6s 怎么没事，是性能问题吧? 🙄我们来具体分析一下吧，这个 timeIntervalSince1970 方法获取的时间戳是 double 类型的，我写博客的时候是 1,480,511,599.854223;这是系统的方法，一般不会有问题，那么问题应该是 NSInteger 引起的，它不是一个新类型，是 typedef 出来的，我们查看它的定义： 1234567#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64typedef long NSInteger;typedef unsigned long NSUInteger;#elsetypedef int NSInteger;typedef unsigned int NSUInteger;#endif 简单的说就是跟你的设备有关系，设备的 CPU 字长是 64 位的话那么 NSInteger 是 long ,否则就是 int ; iOS 设备从 5s 开始以后都是 64 位的，所以测试用的 iPhone5 是32位的机器，NSInteger 其实就是 int ！我想问你天天用的 int 能够表示的最大范围是多少你知道吗？这个可以计算出来，不需要记忆的： int 在 iOS 里内存空间是 4 个字节，每个字节是 8 个二进制位，因此 int 类型的范围就是 2 的 32(4x8) 次幂减 1，能表示的最大值是: 4,294,967,295 所以问题就找到了，32 位机器上时间戳早就超出了 int 能够表示的最大值了，因为一直都是最大值 2147483648 ，即使使用 unsigned int 也不能放下！ 在 5s 等 64 位的机器上 NSInteger 是 long ，long 的最大范围比较大，因此不会出问题! 因此我们为毫秒级的时间戳找个合适的数据类型就行了，时间戳没有负值，因此使用 unsigned 比较合适，使用4个字节的类型不够用，需要使用8个字节的，所以我选择了 UInt64 ，它也是 typedef 出来的，不过不论什么机器，这个类型永远都是占 64 个二进制位! 1UInt64 ts = [[NSDate date] timeIntervalSince1970] * 1000; 总结 以秒为单位的时间戳如果使用 int 类型可以用到 2038 年，使用 unsigned int 类型可以用到 2106 年; 以毫秒为单位的时间戳不能使用 int 类型，必须使用 64 位的类型！ long 类型不同字长的机器上不同，因此选择 long long 或者 UInt64 最为妥当！64 位类型的范围很大，存储时间戳足够了，不使用 unsigned 类型也可以！ 下面是这个表是不同 CPU 字长各数据类型占用的长度： 类 型 （32位机器）长度 （64位机器）长度 Byte 1 1 char 1 1 short 2 2 int 4 4 long 4 8 long long 8 8 其实只有 long 这个数据类型有变化而已！","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"千帆 SDK Refactor: NetWork","slug":"2016/11/28-qfsdk-refactor-network","date":"2016-11-28T13:16:43.000Z","updated":"2018-03-27T14:45:15.689Z","comments":true,"path":"2016/11/28/2016/11/28-qfsdk-refactor-network.html","link":"","permalink":"http://debugly.cn/2016/11/28/2016/11/28-qfsdk-refactor-network.html","excerpt":"","text":"重构，不是说说而已，也不是不想看别人的烂代码自己重写一遍，而是真的遇到了会破坏当前架构的实际问题了，或者之前就没想那么多，继续往下写只会将业务逻辑搞得支离破碎，毫无条理而言，日后维护负担大，相同的逻辑写了多遍之时，才需要重构;我将会结合实际分享几篇SDK内关于重构的文章。 网络请求的现状重构要有合适的动机，不能出师无名，所以我们先来看看我为何决定要重构网络请求；目前SDK的所有（接口，除图片下载外的）请求均是由上层 Service 发起，底层调用 SLNetWork 完成，表现稳定，但 SLNetWork 为 Service 层提供的调用接口太多，将响应数据解析为 Model的处理逻辑糅合在 Service 层和底层，图片下载没有使用 SLNetWork 而是另外一套逻辑。 SLNetWork 库简介这个网络库是我今年 4 月份写的，用于搜狐视频的上传模块，那时候还没有千帆 SDK，我还是视频主线的一个新人，做这块业务的时候，主管说这块要写成一个单独的模块，日后可能会提供给别的部门用，于是就没有使用视频内部现有的网络库，而是重新造的轮子 SVPNetWork；后来我换了部门来做千帆SDK了，做 SDK 的过程中，我尽可能的减少对外部的依赖，减少宿主 App 的工作量，尽管千帆 SDK 目前仅提供给视频和新闻用，但是不依赖外部这个理念是始终萦绕在我的脑海，于是为了快速开发而又不造成依赖的情况下，我就把 SVPNetWork 库直接带了过来，用于担任直播间请求的底层。 这里有一点要说的是，SVPNetWork 库里所有的类都要改下前缀，因为OC没有命名空间！ 这样原本在视频里的 SVPNetWork 就成了千帆 SDK 里的 SLNetWork 了。 SLNetWork 库设计思路核心类有两个： SLNetworkService 负责发起，管理请求 内部处理与系统 NSURLSession 的交互（请求的代理处理） 不同的阶段，把 request 置为不同的状态，request 根据状态回调对应的 callback ； SLNetworkRequest 网络请求的抽象,包含了请求的相关部分 URL: 请求地址 Method: HTTP请求方式，GET，POST等 Headers: HTTP请求的Header，包含了Content-Type，Cookie，UA等信息 Progress: 上传进度，SDK暂时没用到 State: 请求的状态，比如Start是开始，Completed和Error时触发回调回调给上层等 Response: 响应数据，提供的便利方法有，获取string，获取JSON等 简单的说就是 SLNetworkService 管理 SLNetworkRequest，维持他的状态，SLNetworkRequest 根据状态做出相应的动作。坦白的说这个设计思路是从 MKNetWork 借鉴的。发起一个网络请求： 12345678910111213141516NSString *url = @\"your url\"SLNetworkRequest *request = [[SLNetworkRequest alloc]initWithURLString:url params:nil httpMethod:@\"GET\"];///set cookie NSMutableDictionary *cookieHeader = [NSMutableDictionary dictionary];if (cookieStr) &#123; [cookieHeader setObject:cookieStr forKey:@\"Cookie\"];&#125;[request addHeaders:cookieHeader];///添加请求完毕的处理，支持添加多个[request addCompletionHandler:^(SLNetworkRequest *request) &#123; NSDictionary *result = request.respAsJSON;&#125;];///start[[SLNetworkService alloc]startRequest:request]; SLNetWork 库增加便利方法一般请求均是 GET，POST，因此为了发送请求方便，所以在 SLNetworkService+Simple 类别里提供了一些便利的方法： 123456789//可设置自动取消- (SLNetworkRequest *) Post2:(NSString *)url params:(NSDictionary *)params cancelOwner:(id)owner completion:(SLNKHandler)chandler;- (SLNetworkRequest *) Post2:(NSString *)url params:(NSDictionary *)params completion:(SLNKHandler)chandler;//可设置自动取消- (SLNetworkRequest *) Get:(NSString *)url params:(NSDictionary *)params completion:(SLNKHandler)chandler;- (SLNetworkRequest *) Get:(NSString *)url completion:(SLNKHandler)chandler;- (SLNetworkRequest *) Get:(NSString *)url params:(NSDictionary *)params cancelOwner:(id)owner completion:(SLNKHandler)chandler;- (SLNetworkRequest *) Get:(NSString *)url cancelOwner:(id)owner completion:(SLNKHandler)chandler; 自动取消是指，可以将网络请求绑定到某个对象上，当该对象销毁时，自动取消该请求，在以后的博客里介绍吧。为了方便使用，甚至在 SLNetworkService 类里还提供了单利方法，这样普通的请求都是用这个单利就好了： 12///单利的，不过支持多实例！+ (instancetype)sharedService; 至此，SLNetWork 库的封装完毕。我们暂不讨论这么设计有什么缺点，因为好的架构不是吹出来的，评判的标准是看是否符合当前项目业务层的使用，业务层是否用着很爽，所以我们看完业务层在来做客观评价吧。 Service层的调用方式SLNetWork 提供了最基础的发起请求的方式，在业务层我们要根据业务和 SLNetWork 底层提供的方法，进行再次封装，由于底层没有提供将 JOSN 解析为 Model 的方法，那么这个工作就留给了业务层了，我是这么处理的： 123456789101112131415161718// Created on 16/5/13.// 网络请求服务层；基于 SLNetworkService 发送请求 和 SLJSONUtil 进行JOSN解析；// 更加上层，可以直接进行数据验证和JOSN解析为Model；方便业务逻辑调用；#import \"SLNetworkService.h\"#import \"SLNetworkService+Simple.h\"typedef void(^SLNetWorkHandler)(SLNetworkRequest *request,id result,NSError *err);@interface SLNetworkService (JSONParser)- (SLNetworkRequest *) Post2:(NSString *)url params:(NSDictionary *)params checkKeyPath:(NSString *)kp checkHandler:(BOOL (^)(id value))checkHandler modelKayPath:(NSString *)mkp modelName:(NSString *)mName completion:(SLNetWorkHandler)chandler;- (SLNetworkRequest *) Get:(NSString *)url params:(NSDictionary *)params checkKeyPath:(NSString *)kp checkHandler:(BOOL (^)(id value))checkHandler modelKayPath:(NSString *)mkp modelName:(NSString *)mName completion:(SLNetWorkHandler)chandler;- (SLNetworkRequest *) Get:(NSString *)url checkKeyPath:(NSString *)kp checkHandler:(BOOL (^)(id value))checkHandler modelKayPath:(NSString *)mkp modelName:(NSString *)mName completion:(SLNetWorkHandler)chandler;- (SLNetworkRequest *) Get:(NSString *)url checkKeyPath:(NSString *)kp checkHandler:(BOOL (^)(id value))checkHandler modelKayPath:(NSString *)mkp completion:(SLNetWorkHandler)chandler; 然后随便找一个业务层的接口看下如何使用JSONParser这一层（这里说层不严谨）： 1234567891011121314151617181920- (void)requestNeighborOnlineAnchorsWithRoomid:(NSString *)rid comp:(void(^)(id result,NSError *err))comp&#123; if (rid.length == 0 ) &#123; return; &#125; NSDictionary *param = @&#123;@\"roomid\":rid&#125;; NSString *url = @\"...\"; SLNetworkRequest *request = [[SLNetworkService sharedService] Get:url params:param checkKeyPath:@\"status\" checkHandler:^BOOL(id value) &#123; return ([value intValue] == 200); &#125; modelKayPath:@\"message\" modelName:@\"SLNeighborAnchorModel\" completion:^(SLNetworkRequest *request, id result, NSError *err) &#123; comp(result,err); &#125;]; [self addCancleRef:request];&#125; 根据服务器返回的数据，来解释 checkKeyPath、modelKayPath、modelName 这些参数都是干嘛用的： 123456789&#123; status:200, message: &#123; anchor:5006697, avator:http://img, nickName:么么哒 &#125;&#125; checkKeyPath: 需用该字段做接口检查，支持 keypath，比如:aa/status checkHandler: 内部返回通过 checkKeyPath 字段取出来的值，block 回调过来，然后返回是否检验通过；只有通过才能解析为 Model modelKayPath: 根据该参数去服务器返回的 json 数据里查找 目标 json，比如这个例子的目标就是message的内容 modelName: 将通过 modelKayPath 找到的 json 解析为类名为 modelName 的 model实例 completion: 网络请求的着陆点，判断下err，如果没有err，result 就是你想要的 model 了，这里回调给上层 至此，SDK 的网络库使用现状已经毫无保留的给大家介绍了。 网络请求改进方向知道了网路请求的现状后，我们才能有针对性的去改进他。我们可以看到主要的问题是： SLNetworkService 提供了太多的发送请求的便利方法，特别是支持 JSON 转 Model 之后，可能就是一个参数之差就需要增加一个方法，不方便之处也显而易见，Xcode 自动提示的时候，都他妈不能完全显示了，被省略了，这样反而降低了开发的效率呢！ 响应解析处理不够好，糅合在底层的上层之间，没有扩展性，比如我想把图片的请求也统一过来，目前来看很难做到！ 因此，接下来主要针对与调用方式和响应解析进行重构！ 重构请求响应处理逻辑目前优秀的开源库有可以借鉴的地方吗？有，比如最流行的 AFNetworking 的响应解析处理的很好呢，跟 SLNetwork 库的区别是不支持 JSON 转 Model，对于这个问题我觉得采用继承去解决比较合适，所以建立的下面的几个类： Model 继承自 JSON，JSON 继承自 HTTP； 这块完全模仿自 AFNetworking ，但还是多少有些创建之处，因为目前服务响应里都有个状态码，比如上面我举例接口中的 status 字段，当 status 等于 200 时，就是接口正常返回了数据，才能进行 Model 解析： 这个子类来处理 Model 解析的，为了方便，提供了 keypath 的概念： 这是处理逻辑，这个使用的是我之前写的 JOSN 转 Model 的小框架，使用方式可参考我的开源项目： 这里选择这个小框架是因为他是我自己写的，非常小众化，加上目前也没什么问题，最大的好处是 SDK 不会造成依赖！假如使用开源的 Mantle 的话就很容易和嵌入的 App造成冲突，不凑巧的是 App 修改了里面的逻辑，这就更糟糕了。 到此，解析响应数据这块就重构完了，好处是由底层完成，上层不必关系这个过程；还有扩展性比较强，未来注定还会有一次重构：将网络请求和图片请求统一！那时就可以再写个 SLNHTTPResponseParser 的子类处理图片就好了，想想都觉得不错呢！感谢 AFNetworking 作者提供的好思路！ 重构调用方式，减少不必要的方法这个问题是耐人寻味的，我的目标是写一个方法，就能够实现发送请求，而不是一个参数的差异就要为之写个方法，如果在加上普通请求的类型（GET，POST），方法数就要乘以 2 了！这简直是灾难，回想下我刚才举例那个请求吧，共有 6 个参数，我不能保证这 6 个必须的有几个，我也不想就提供一个带 6 个参数的方法，那样失去了灵活性! 解决这个问题的时候我是有灵感的，其实重构之前灵感就有了，否则我也不会去重构了；因为去年我就做过类似的事情，那个时候我还在创业公司做项目，这是使用的方式： 12345678910111213141516///Make 这个接口需要的参数，内部有签名NSDictionary *paramDic = MakeHttpParam(^(NSMutableDictionary *const make) &#123; [make setObject:phone forKey:@\"phone\"]; [make setObject:type forKey:@\"template\"]; &#125;);///传入签过名的参数，发送请求[self PostPath:@\"/mobile/sendmsg\" parems:paramDic SuccBlock:^(NSDictionary * json) &#123; if (succBlock) &#123; succBlock(); &#125;&#125; FailedBlock:^(NSError *error, id resultJson) &#123; if (errorBlock) &#123; errorBlock(error); &#125;&#125;]; 这里的 MakeHttpParam 是方便构建请求参数的，为何这么写？是因为方便，MakeHttpParam 内部会将参数按照规则进行一次签名，然后返回，因此 paramDic 就是处理好的参数字典，可直接用于网络请求！其实这么处理的思路也不是我凭空想象出来的，是我在使用 Masonry 的过程中，学习到的，稍微修改了下而已，这里也要感谢 Masonry 作者提供的好思路！ 我简单总结了下，只要满足这样一个条件就可以使用采用这个思路： block 里需要提供一个 maker，这个 maker 能够处理原本通过形参传递进来的参数！ 因此我们来看下 SLNetworkService 满足这个条件吗？哈哈，满足，因为 SLNetworkService 提供的这些方法的参数最终都传给了 SLNetworkRequest ！所以这个 maker 就找了，就是 SLNetworkRequest ！ 思路有了，剩下的都是体力活了，把之前的 Simple，JOSN 类别都删了，然后创建一个 Maker 的类别，同样为了方便使用额外提供了 GET 和 POST: 因此 Service 层的调用方式就改成了这样： 这样一来，就算是再多的参数，不管哪个参数有或者没有，都可以在这个 block 里完成，使用这中方式写了几个请求之后发现这统统这不都是对网络请求的配置么！不知道你有这个感觉没？ 本次对网络请求的重构就到这里啦，如有问题请留言给我。下次网络重构的内容可能是： 图片请求收入 SLNetwork 麾下，彻底实现网络请求大一统。","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"什么是千帆直播 SDK","slug":"2016/11/28-qf-sdk-introduction","date":"2016-11-28T04:11:01.000Z","updated":"2018-03-27T14:45:15.689Z","comments":true,"path":"2016/11/28/2016/11/28-qf-sdk-introduction.html","link":"","permalink":"http://debugly.cn/2016/11/28/2016/11/28-qf-sdk-introduction.html","excerpt":"","text":"千帆直播SDK简介 说起千帆直播SDK，他包含了两个信息，一个是 千帆直播，一个是 SDK ，下面我们就说下他们的关系吧。 千帆直播 是搜狐旗下的一个直播平台，提供了丰富的精彩的美女直播，主要属于秀场类，正在全力打造成一个品牌。开发团队在广州部门，前身是 56 视频 （14年10月被搜狐收购），千帆直播平台拥有独立的移动端(iOS，安卓的请到各渠道下载)和 PC端，拥有几千名签约主播。 千帆直播SDK 简称千帆SDK，是在共享千帆直播平台资源的情况下，由北京的开发团队负责的开发的一个SDK，提供给搜狐视频、新闻嵌入使用。于今年5月项目启动，我是这个团队的负责人（负责自己哈😢），做了2月后陆续补上了两个同事，这里感谢下他们，没有他们，我就不能在国庆前后休我的婚假了！经过几个月的迭代，我们开发了好几个版本，积累了很多做 SDK 的心得，还有我们自己封装的库，这些库也愈发合理，因为我们在重构他们！在后续的文章里，我会跟大家分享，敬请关注。 千帆SDK实现的功能我觉得使用表格的形式会更加好理解，就不写大段的文字去描述了，那样你看起来也很费劲；视频和新闻更新的功能有所差异，并且不包含优化，这里以视频为主： Version Update Note 1.0 1.观看直播和聊天 2.侧滑隐藏聊天 3.广播，点击推荐进入别的直播间 4.弹框提示安装或打开千帆App 5.可送5个千帆星 1.1 1.上下滑动切换直播间，左滑隐藏聊天信息，右滑退出直播间； 2.普通连击连送动画 3.组合礼物动画 4.礼物图片信息存储到本地 5.App失去Active时播放器不暂停 1.2 1.小图瀑布流列表 2.首页大图列表 3.支持游客发送聊天 4.直播流由RTMP改为HTTP(FLV) 1.3 1.直播间分享 2.直播间支持自动旋转（横屏观看） 3.豪华礼物特效（Webp） 4.增加排行榜 1.4 1.千帆导量 2.0 1.账户打通（可使用搜狐账号登陆） 2.送礼 3.充值（内购） 4.千帆导量修改 2.0.1 1.千帆导量修改 2.拉起千帆开播 3.分享奖励 … … 更多版本正在开发之中…","categories":[],"tags":[{"name":"千帆SDK","slug":"千帆SDK","permalink":"http://debugly.cn/tags/千帆SDK/"}]},{"title":"使用 Jekyll 搭建博客","slug":"2016/11/27-blog-use-jekyll","date":"2016-11-27T08:21:35.000Z","updated":"2018-03-27T14:45:15.689Z","comments":true,"path":"2016/11/27/2016/11/27-blog-use-jekyll.html","link":"","permalink":"http://debugly.cn/2016/11/27/2016/11/27-blog-use-jekyll.html","excerpt":"","text":"博客大改版在此之前使用的是 Octopress 博客系统，或许是厌倦了吧，因此改为直接使用 Jekyll 来搭建,花了几个晚上的时间，一步步摸索着做了个 Jekyll 的主题出来，毕竟 Jekyll 的主题不是一个 Geek 想要的，我前端能力有限，所以目前这个主题只是能用而已，so 就没不做主题包（丢人现眼）了，如果有需要的请联系我，我（厚着脸皮）做一个。 亲身感受如果你看到了我的博客，那么我的建议是去折腾一下自己吧，不要直接使用这些已经做好的系统，如果你有时间和兴趣的话，因为你会从中学到很多东西，你可能要学习这些： DIV + CSS （SASS） Pygments Jekyll Liquid Ruby ‘s Task DIV + CSS: 排版很大程度上是个体力活，我更多的是在纠结何时应该使用 id 还是 class !还有一些我们需要知道的小技巧，比如我们知道一个 class 类型的样式，可供多个 HTML 元素使用，但有的时候你想对某一种使用了改class的元素额外加样式应该怎么写？这个其实很简单，但对于非前端工程师而言，你不得不去 Google 度娘了吧： 1234///只有使用 highlight 样式的 pre 标签背景设置为 #dedede.pre.highlight&#123; background:#dedede;&#125; Pygments : 是用来做代码高亮使用的，你需要做的很简单，就是选个模板而已，你可以在线选择，这是我创建的一个 OC demo: oc method，使用如下命令生成一个样式，然后你放进你的网站里，在HTML里引入就可以了： 1pygmentize -S xcode -f html &gt; pygments.css Jekyll : 即使你什么都不去了解，这个博客系统也是完整的，可以生成一个网站哦！自有像我一样，想自己写主题，你才需要学习这么多，比如需要了解内置变量，因为你肯定需要获取博客的日期、标题、内容等，这些是有对应的内置变量的去查文档就好了；还有一些命令，我的自动化部署其实也是封装的这些命令和 Git 操作的命令而已。 Liquid : 他的作用是帮助你实现动态化，你就只管写布局好了，生成的时候，会把你写的博客内容替换为对应的模板标签；作为一个模板引擎，我觉得很赞的是他内置的很多 Filters，以及这种编程范式，比如： 1234&#123;% raw %&#125;&#123;&#123; article.published_at | date: \"%Y\" &#125;&#125;//2016&#123;% endraw %&#125; Ruby: 这门语言我并没有系统的学习过，都是用到哪去查哪，所以不敢多说，觉得他的 block 也是很赞的， Liquid 的 Filter 跟这个类似，比如： 12(Dir[&quot;#&#123;deploy_dir&#125;/*&quot;]).each &#123; |f| rm_rf(f) &#125;//each后面的括号就是block体 一般我们写 Task 都是用于完成一些流程化的工作，从而节省时间和体力，今天下午借鉴了 Octopress 的 Rakefile，借鉴的前提是要理解，所以经过这么一折腾，对于 Octopress 的理解也加深了不少，然后我自己也为我的博客系统写了一个，保持相同的命名，毕竟我已经习惯了使用 rake deploy，rake preview 等命令。下面是一个最简单的 Rake Task ： 123456789desc \"Task description\"task :printit, [:msg] do |t, args| puts args[:msg]end//executerake printit['Hello.']//resultHello. 怎么样？基本了解了自建主题需要的知识后，对你而言有困难吗？是让你更加畏惧了，还是立马有兴趣要开搞了？ 这些网站也许对你有些帮助： http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html http://www.ruanyifeng.com/blog/2012/06/sass.html http://havee.me/internet/2013-08/support-pygments-in-jekyll.html http://9leg.com/other/2015/01/11/create-jekyll-markdown-by-java.html http://www.sassmeister.com/ http://xh.5156edu.com/page/z1015m9220j18754.html http://cobwwweb.com/4-ways-to-pass-arguments-to-a-rake-task https://docs.ruby-lang.org/en/2.1.0/Rake/FileList.html http://suanfazu.com/t/copy-a-file-creating-directories-as-necessary-in-ruby/12396 http://zhaoyuxiang.cn/bohu-jekyll-theme/index http://yongyuan.name/blog/collect-jekyll-theme.html https://liungkejin.github.io/about.html","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"}]},{"title":"统一管理网络变化","slug":"2016/06/19-SLReachability","date":"2016-06-19T15:26:50.000Z","updated":"2018-03-27T14:45:15.689Z","comments":true,"path":"2016/06/19/2016/06/19-SLReachability.html","link":"","permalink":"http://debugly.cn/2016/06/19/2016/06/19-SLReachability.html","excerpt":"故事背景Reachability 只能检测网络的变化，包括 WiFi ，WWAN 和 NoReachable 三种状态；她不能细分 WWAN 网络，不能参与用户的设置（某些App在设置里设有允许使用3G的开关），但是实际业务中我们会遇见这些情景，为了更加方便的获取、管理网络的各种状态，SLReachability 就运应而生了，现在她已经在两个项目里投入使用了，感觉还是挺方便的，现在拿来分享下。 SLReachability 与 Reachability 的区别SLReachability 完全兼容 Reachability ，因为内部关于网络变化的实现是和 Reachability 一样的，老实说就是完全 copy 过来的；在 Reachability 的基础之上，增加了检测 WWAN 变化的功能，并且考虑到了用户可能会增加允许使用 WWAN 的开关；SLReachability 就是把以上几种网络情况最终作了个大统一，更加方便开发者获取网络的状态！ 这是陪伴我好久的 Reachability 源码地址. 设计思路清楚了需求后，就是一步步实现了，首要需要的是完全兼容 Reachability ，具备 Reachability 的所有功能，其次还要拥有上面提到的检测 WWAN 变化的需求和允许用户增加开关；先看下如何兼容： 完全兼容（copy） Reachability 实现 1234567typedef NS_ENUM(NSInteger,SLReachStatus) &#123; SLNotReachable = 0, SLReachableViaWiFi, SLReachableViaWWAN&#125;;@property (nonatomic, assign, readonly) SLReachStatus reachStatus; 这个没什么难理解的，不再细说了； 下面是检测 WWAN 变化的实现，这里有以下几种情况，其中 SLNetWorkStatusWWANRefused 表示用户设置开关是关，不允许使用 WWAN 网络，出现的条件是：没有WiFi，用户不允许使用 WWAN； 1234567891011typedef NS_ENUM(NSUInteger, SLWWANStatus) &#123; SLWWANNotReachable = SLNotReachable, ///不允许WWAN网络；默认允许 SLNetWorkStatusWWANRefused = 3, ///使用WWAN； SLNetWorkStatusWWAN4G = 4, SLNetWorkStatusWWAN3G = 5, SLNetWorkStatusWWAN2G = 6,&#125;;@property (nonatomic, assign, readonly) SLNetWorkStatus wwanType;","text":"故事背景Reachability 只能检测网络的变化，包括 WiFi ，WWAN 和 NoReachable 三种状态；她不能细分 WWAN 网络，不能参与用户的设置（某些App在设置里设有允许使用3G的开关），但是实际业务中我们会遇见这些情景，为了更加方便的获取、管理网络的各种状态，SLReachability 就运应而生了，现在她已经在两个项目里投入使用了，感觉还是挺方便的，现在拿来分享下。 SLReachability 与 Reachability 的区别SLReachability 完全兼容 Reachability ，因为内部关于网络变化的实现是和 Reachability 一样的，老实说就是完全 copy 过来的；在 Reachability 的基础之上，增加了检测 WWAN 变化的功能，并且考虑到了用户可能会增加允许使用 WWAN 的开关；SLReachability 就是把以上几种网络情况最终作了个大统一，更加方便开发者获取网络的状态！ 这是陪伴我好久的 Reachability 源码地址. 设计思路清楚了需求后，就是一步步实现了，首要需要的是完全兼容 Reachability ，具备 Reachability 的所有功能，其次还要拥有上面提到的检测 WWAN 变化的需求和允许用户增加开关；先看下如何兼容： 完全兼容（copy） Reachability 实现 1234567typedef NS_ENUM(NSInteger,SLReachStatus) &#123; SLNotReachable = 0, SLReachableViaWiFi, SLReachableViaWWAN&#125;;@property (nonatomic, assign, readonly) SLReachStatus reachStatus; 这个没什么难理解的，不再细说了； 下面是检测 WWAN 变化的实现，这里有以下几种情况，其中 SLNetWorkStatusWWANRefused 表示用户设置开关是关，不允许使用 WWAN 网络，出现的条件是：没有WiFi，用户不允许使用 WWAN； 1234567891011typedef NS_ENUM(NSUInteger, SLWWANStatus) &#123; SLWWANNotReachable = SLNotReachable, ///不允许WWAN网络；默认允许 SLNetWorkStatusWWANRefused = 3, ///使用WWAN； SLNetWorkStatusWWAN4G = 4, SLNetWorkStatusWWAN3G = 5, SLNetWorkStatusWWAN2G = 6,&#125;;@property (nonatomic, assign, readonly) SLNetWorkStatus wwanType; 统一所有的网络状况，这是才是今天的主要工作： 12345678910111213typedef NS_ENUM(NSUInteger, SLNetWorkStatusMask) &#123; SLNetWorkStatusMaskUnavailable = 1 &lt;&lt; SLNotReachable, SLNetWorkStatusMaskReachableWiFi = 1 &lt;&lt; SLReachableViaWiFi,//这里直接使用这个枚举即可 SLNetWorkStatusMaskWWANRefused = 1 &lt;&lt; SLNetWorkStatusWWANRefused, SLNetWorkStatusMaskReachableWWAN4G = 1 &lt;&lt; SLNetWorkStatusWWAN4G, SLNetWorkStatusMaskReachableWWAN3G = 1 &lt;&lt; SLNetWorkStatusWWAN3G, SLNetWorkStatusMaskReachableWWAN2G = 1 &lt;&lt; SLNetWorkStatusWWAN2G, SLNetWorkStatusMaskReachableWWAN = (SLNetWorkStatusMaskReachableWWAN2G | SLNetWorkStatusMaskReachableWWAN3G | SLNetWorkStatusMaskReachableWWAN4G), SLNetWorkStatusMaskNotReachable = (SLNetWorkStatusMaskUnavailable | SLNetWorkStatusMaskWWANRefused), SLNetWorkStatusMaskReachable = (SLNetWorkStatusMaskReachableWiFi | SLNetWorkStatusMaskReachableWWAN),&#125;; 根据网络的情况定义了以上枚举，这里简单解释下： –Mask– –含义– SLNetWorkStatusMaskReachableWWAN 只要当前是 2G，3G，4G 网络的一种属于ReachableWWAN SLNetWorkStatusMaskNotReachable 当前没有网络 或者 当前是WWAN网络 (用户不允许) SLNetWorkStatusMaskReachable 当前是WiFi网络 或者 当前是WWAN网络（用户允许） 实现原理使用 Reachability 检测网络的变化， 使用 iOS7 新增的 API 检测 WWAN 的变化，也正因为如此，所以 SLReachability 从 iOS7 开始支持；每当检测到变化之后就就去更新网络状态 mask ，如果前后不一致就更新，并且发送通知，反之则忽略；这里对于不一致的判断是重写了 setter 方法来实现的，下面简单看下代码： 这是 Reachability 检测到网络变化后的回调，我的处理是给属性赋值，具体更新的方法在 setter 里去实现！ 123456789101112///网络状况变化回调；static void ReachabilityCallback(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags flags, void* info)&#123;#pragma unused (target, flags) if(info == NULL) return; if(![(__bridge NSObject*) info isKindOfClass: [SLReachability class]]) return; SLReachability* noteObject = (__bridge SLReachability *)info; ///update noteObject.reachStatus = [noteObject currentReachabilityStatus];&#125; 下面看下对 WWAN 的检测，需要创建这样一个对象才能去观察哦： 123456_radioAccessInfo =[[CTTelephonyNetworkInfo alloc]init];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(WWANDidChanged:) name:CTRadioAccessTechnologyDidChangeNotification object:nil]; 看下通知回调的处理： 12345678- (void)WWANDidChanged:(NSNotification *)notifi&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSString *radioAcc = [notifi object]; SLWWANStatus wwanType = WWANTypeWithRadioAccessTechnology(radioAcc); self.wwanType = wwanType; &#125;);&#125; 需要注意的是，这个回调不在主线里！处理同样很简单，给属性赋值！因此如果关系 WWAN 的变化，可以直接 Observe 这个属性，需要了解的是当前网络即使是 WiFi ，这个属性也会发生变化，这跟你的移动网络有关系，但是不会影响到 mask ，因为 mask 是 WiFi ！ 下面看下重写 setter 方法吧： 12345678910111213141516171819202122232425262728- (void)setWwanType:(SLWWANStatus)wwanType&#123; if (_wwanType != wwanType) &#123; _wwanType = wwanType; [self updateNetworkStatusMask]; [self postNotifi:kSLReachabilityWWANChanged]; &#125;&#125;//修改了设置里的开关- (void)setAllowUseWWAN:(BOOL)allowUseWWAN&#123; if(_allowUseWWAN != allowUseWWAN) &#123; _allowUseWWAN = allowUseWWAN; [self updateNetworkStatusMask]; &#125;&#125;- (void)setReachStatus:(SLReachStatus)reachStatus&#123; if(_reachStatus != reachStatus) &#123; _reachStatus = reachStatus; [self updateNetworkStatusMask]; [self postNotifi:kSLReachabilityReachStatusChanged]; &#125;&#125; 通过重写 setter 的方法去被动发现网络变化了，最终通过 updateNetworkStatusMask 方法去更新 mask : 12345678910- (void)updateNetworkStatusMask&#123; //update SLNetWorkStatusMask mask = [self netWorkStatusMaskWithNetStatus:_reachStatus WWANType:_wwanType WWANReachable:_allowUseWWAN]; self.netWorkMask = mask; //log it#ifdef DEBUG NSLog(@\"net is: [%@]\",SLNetWorkStatusMask2String(mask));#endif&#125; updateNetworkStatusMask 方法根据当前的网络和WWAN情况和用户设置的选项综合出来一个最终的 mask ，当 mask 变了之后就会发送通知告知发生了变化！ 12345678- (void)setNetWorkMask:(SLNetWorkStatusMask)netWorkMask&#123; if(_netWorkMask != netWorkMask) &#123; _netWorkMask = netWorkMask; [self postNotifi:kSLReachabilityMaskChanged]; &#125;&#125; 以上就是实现的原理，关于 allowUseWWAN 这个属性，你可以写个 SLReachability 的子类，子类检测到开关变化后去更改这个属性；不同的业务也许会有多个开关，这是一一创建子类就行了！ 便利方法：判断当前网络是不是 WiFi，当然你也可以扩展更多： 123456789NS_INLINE BOOL isWiFiWithMask(SLNetWorkStatusMask mask)&#123; return mask &amp; SLNetWorkStatusMaskReachableWiFi;&#125;NS_INLINE BOOL isWiFiWithStatus(SLReachStatus status)&#123; return mask == SLReachableViaWiFi;&#125; 使用方法112345_reach = [SLReachability reachabilityForInternetConnection]; //添加 observer [_reach addObserver:self forKeyPath:@\"netWorkMask\" options:NSKeyValueObservingOptionNew context:nil]; //获取当前的网络状态； SLNetWorkStatusMask mask = _reach.netWorkMask; 处理网络变化： 123456- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; NSNumber *statusNum = [change objectForKey:NSKeyValueChangeNewKey]; SLNetWorkStatusMask mask = [statusNum intValue]; //根据当前网络做出处理；&#125; 使用方法2除了可以 Observe 属性之外，当然也可以注册通知： 123456///网络状态变化，同 ReachabilityFOUNDATION_EXTERN NSString *const kSLReachabilityReachStatusChanged;///WWAN变化；WiFi网络也会变，跟当前网络有关；FOUNDATION_EXTERN NSString *const kSLReachabilityWWANChanged;///统一后的网络变化FOUNDATION_EXTERN NSString *const kSLReachabilityMaskChanged; 根据你的需要去注册，你可能要注意下他们 3 个之间的关系！ IPv6 SupportSLReachability 完全支持 IPv6 ，具体可参照 Reachability 的解释或者查看源码。 Demo 工程这是 Github 地址: https://github.com/debugly/SLReachabilityDemo","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"使用 UIBezierPath 绘制圆角六边形","slug":"2016/05/29-bezier-demo","date":"2016-05-29T14:42:49.000Z","updated":"2018-03-27T14:45:15.688Z","comments":true,"path":"2016/05/29/2016/05/29-bezier-demo.html","link":"","permalink":"http://debugly.cn/2016/05/29/2016/05/29-bezier-demo.html","excerpt":"UIBezierPath 能绘制各种图形，项目里总是用到，这里写个 demo 吧： 圆角，六边形 实现效果： 分析过程： 圆弧","text":"UIBezierPath 能绘制各种图形，项目里总是用到，这里写个 demo 吧： 圆角，六边形 实现效果： 分析过程： 圆弧 需求： 实现效果： 完源码地址 : https://github.com/debugly/UIBezierDemo","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"使用 Mac 开发必备神器","slug":"2016/05/06-new-mac-need-install-softwares","date":"2016-05-06T15:31:00.000Z","updated":"2018-03-27T14:45:15.688Z","comments":true,"path":"2016/05/06/2016/05/06-new-mac-need-install-softwares.html","link":"","permalink":"http://debugly.cn/2016/05/06/2016/05/06-new-mac-need-install-softwares.html","excerpt":"","text":"背景今天公司配的新 Mac Book Pro 到了，比我个人的电脑配置稍高了一点哈(固态硬盘是 512G 的,触摸板有 Force Touch 功能）; 拿到手先登录下Apple 账号，简单设置下网络就开始用喽！我觉得从一个新电脑入手到打造出顺手的开发环境还是费了不少力气的，这里就记录下，以后再配置就直接去下载就好了，省时省力！下面是我打造开发机器安装的软件清单以及下载地址，随着以后的陆续安装我也会再更新这个清单的。 Charles Chrome ImageOptim Lantern Snip MacDown Xcode 鱼摆摆 SourceTree 如果你有什么好用的软件千万不要吝啬哦，要拿出来，共同提高开发效率O(∩_∩)O ~ 给我留言或者微信邮箱都行，我为人人，人人为我，不是么…","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"解决 CALayerInvalidGeometry 问题","slug":"2016/03/28-calayerinvalidgeometry","date":"2016-03-28T14:08:16.000Z","updated":"2018-03-27T14:45:15.688Z","comments":true,"path":"2016/03/28/2016/03/28-calayerinvalidgeometry.html","link":"","permalink":"http://debugly.cn/2016/03/28/2016/03/28-calayerinvalidgeometry.html","excerpt":"今天遇到了很多 calyer 设置坐标的崩溃，原因如下： Fatal Exception: CALayerInvalidGeometryCALayer position contains NaN: [nan 8] 坐标竟然是 NaN (非数字)！这还得了，马上排查！！！下面是具体崩溃信息： 12345678910Thread : Fatal Exception: CALayerInvalidGeometry0 CoreFoundation 0x23a2a5f7 __exceptionPreprocess1 libobjc.A.dylib 0x3129cc77 objc_exception_throw2 CoreFoundation 0x23a2a53d -[NSException initWithCoder:]3 QuartzCore 0x268f01cf CA::Layer::set_position(CA::Vec2&lt;double&gt; const&amp;, bool)4 QuartzCore 0x268f00d3 -[CALayer setPosition:]5 QuartzCore 0x268f0065 -[CALayer setFrame:]6 UIKit 0x26ec8fe3 -[UIView(Geometry) setFrame:]7 SOHUVideo 0xa937d -[DiskStatusView updateDiskStatus] (DiskStatusView.m:65)...","text":"今天遇到了很多 calyer 设置坐标的崩溃，原因如下： Fatal Exception: CALayerInvalidGeometryCALayer position contains NaN: [nan 8] 坐标竟然是 NaN (非数字)！这还得了，马上排查！！！下面是具体崩溃信息： 12345678910Thread : Fatal Exception: CALayerInvalidGeometry0 CoreFoundation 0x23a2a5f7 __exceptionPreprocess1 libobjc.A.dylib 0x3129cc77 objc_exception_throw2 CoreFoundation 0x23a2a53d -[NSException initWithCoder:]3 QuartzCore 0x268f01cf CA::Layer::set_position(CA::Vec2&lt;double&gt; const&amp;, bool)4 QuartzCore 0x268f00d3 -[CALayer setPosition:]5 QuartzCore 0x268f0065 -[CALayer setFrame:]6 UIKit 0x26ec8fe3 -[UIView(Geometry) setFrame:]7 SOHUVideo 0xa937d -[DiskStatusView updateDiskStatus] (DiskStatusView.m:65)... 立马定位到 DiskStatusView 类的 updateDiskStatus 方法，发现他的一个子 view 的宽度在某种情况下会出现非数字的情况！知道问题所在就好改了，判断下就 OK 啦！ 说来也怪，宽度是非数字，为何异常却是：CALayer position contains NaN: [nan 8] 呢？！这个 8 是哪里来的，y 坐标本来设置的是 0 啊，这点真不理解呢 … NaN : 非数字，一般都是 0 作除数的结果！ 简单的说：rect 里面不能包含非数字，否则就会报 CALayerInvalidGeometry 异常！解决办法就是仔细检查 rect 的4个值！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"深入理解关联引用","slug":"2016/03/06-Objc-Associations-Advanced","date":"2016-03-06T01:58:46.000Z","updated":"2018-03-27T14:45:15.688Z","comments":true,"path":"2016/03/06/2016/03/06-Objc-Associations-Advanced.html","link":"","permalink":"http://debugly.cn/2016/03/06/2016/03/06-Objc-Associations-Advanced.html","excerpt":"","text":"今日吃饱了，确实撑得慌，找了我的邻居-阿杰一起散步，走了好大一圈，最后在小区下聊起了技术，从YYKit，SDWebImage 等第三方库，扯到了关联引用，因为他们都用到了这个技术，然而我又想到了单例，单例和关联引用在实现上有一个相同点—都需要一个静态变量；那么疑问就来了：同样都需要一个静态变量，为什么结果不一样呢？或许你还没明白我的疑问是什么，请继续阅读吧！ 一、回顾单例我简单的写了个单例类 SingletonObject ，把静态变量 instance 放在 sharedInstance 类方法里看起来可能更好一些，放在外面也是可以的，二者的区别是作用域不同，生命周期也差不多，我个人比较喜欢放在方法内部，因为外部一般不需要直接获取，这里放在外部是为了和我们今天的角儿进行对比，提出我的疑问做铺垫。 1234567891011121314@implementation SingletonObjectstatic id instance;+ (instancetype)sharedInstance&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc]init]; &#125;); return instance;&#125;@end 请问你有没有思考过，为什么这里可以实现单例，instance 变量不是每个对象都有一份吗？当然不是的！这个 instance 静态变量的地址是和类 SingletonObject 是对应的，也就说 instance 静态变量的地址是确定的，只要这个类的地址确定了，他也就是确定的了，因此可以简单的理解为 instance 静态变量是属于类的，姑且称之为 “类变量”，与实例变量相对应。 实际上这里所谓的 “类变量” 与 Java 之类的面向对象语言里的类变量不是一个意思，Objective C 是没有类变量，这里只是通过静态变量达到这种效果罢了，因此这里我将她称之为 “类变量”。 二、提出疑问我们已经知道了静态变量是个“类变量”，我们也都用过 SDWebImage，其内部实现正是使用了关联引用，才使得我们使用起来是那么的方便，图片可以准确无误的下载显示出来，也就是说每个 imageView 对应图片都是自己想要的，一一对应的，我的问题来了，既然关联引用也使用了“类变量”，那么不应该是 imageView 最终都要显示为同一张图片才对嘛？！虽然你创建了 N 个 imageView ，但是 imageView 的 “类变量”（关联引用的 key） 是唯一的啊，这明显是个一对多的关系！可为什么使用 SDWebImage 的时候一切都那么正常，最终图片都一一对应上了，你怎么看呢？我觉得此事必有蹊跷！ 三、大胆推测我最后给阿杰做了一个这样的推测：问题肯定在关联引用的处理上，要不然我们就没必要在使用的时候传个 key 进去了，或许正是根据这个 key 做了一个地址偏移什么的，每个对象都能获取元类信息，然后给自身加个偏移存储下这个关联的对象，我们可以从打印静态变量地址，打印堆栈信息，runtime源码入手… 然后就各回各家，各找各妈了… 四、揭开神秘面纱这么大的疑问放心里，肯定睡不着的，回家就开始找源码了，找到了内部实现代码，现在拿出来仔细分析下内部实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//这是我们调用的方法void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)&#123; objc_setAssociatedObject_non_gc(object, key, value, policy);&#125;//这是内部的私有方法；void objc_setAssociatedObject_non_gc(id object, const void *key, id value, objc_AssociationPolicy policy) &#123; _object_set_associative_reference(object, (void *)key, value, policy);&#125;//设置关联引用对象，最终将调用这个方法void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // 这段代码有点像重写 setter 方法的感觉；old就是赋值之前的老值，要被释放掉的；ObjcAssociation 下面会介绍； ObjcAssociation old_association(0, nil); // acquireValue：对传入的 value 做 reatain,copy 等策略 id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager;//这是重点，每个类都可以创建一个 manager 管理关联的对象，不过 manager 管理的 HashMap 一直都是一个，并且是线程安全的！ AssociationsHashMap &amp; (manager.associations());//获取唯一的 map 引用； disguised_ptr_t disguised_object = DISGUISE(object);//把对象伪装下，说得直白些就是将对象的地址转化为一个 unsigned long 的整型； if (new_value) &#123; //如果新值不是空的 // 这里是 c++ 语法，按照 key 查找 map 里的键值对，返回的是一个 iterator； AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; //说明找到了对象对应的 map 了； ObjectAssociationMap *refs = i-&gt;second; //取 value，first 是取 key http://www.cplusplus.com/reference/unordered_map/unordered_map/ ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; //说明在对象对应的 map 里找到了 key 对应的 map ； old_association = j-&gt;second; //取值赋给 old，后面会释放； j-&gt;second = ObjcAssociation(policy, new_value); //赋上新值；这里包装了下，不是直接赋值，可思考下为什么？ &#125; else &#123; //说明在对象对应的 map 里没能找到 key 对应的 map ！ (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; //找不到对象对应的 map ；第一次肯定都找不到，需要创建； // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; //创建一个 map ，对象是 key; (*refs)[key] = ObjcAssociation(policy, new_value); //然后把关联对象放到对象对应的空 map 里；key就是关联引用使用的那个静态变量； object-&gt;setHasAssociatedObjects(); //做个标记；下次就能够找到了； &#125; &#125; else &#123; //如果新值是空的，相当于 set 了 nil ； // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; //找到了对象对应的 map 了； ObjectAssociationMap *refs = i-&gt;second; //取出对象对应的 map ObjectAssociationMap::iterator j = refs-&gt;find(key); //查找 key 对应的 ObjcAssociation if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; //取值赋给 old，后面会释放； refs-&gt;erase(j); //从 map 里擦除； &#125; &#125; &#125; &#125; // 释放 old if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 仔细阅读完源码后，疑问马上没了，也挺好理解的，只不过需要一点 c++ 的知识，基本每一行都加了注释，这里就不详细说了，做个简单的总结： 1.使用AssociationsManager类管理所有类关联的对象，其内部用静态的（也就是唯一的） AssociationsHashMap 存储，map 存的是键值对，这里的键就是这个类的对象（需要处理下），值是 ObjectAssociationMap。（这两个 map 有着不同的父类）简单看下AssociationsManager： 12345678910111213class AssociationsManager &#123; static spinlock_t _lock; //还用到了自旋锁 static AssociationsHashMap *_map; // associative references: object pointer -&gt; PtrPtrHashMap.public: AssociationsManager() &#123; spinlock_lock(&amp;_lock); &#125; ~AssociationsManager() &#123; spinlock_unlock(&amp;_lock); &#125; AssociationsHashMap &amp;associations() &#123; //c++ 的引用，好难理解清楚引用和指针 if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;; 2.每个对象的ObjectAssociationMap里存的当然也是键值对，这里的键就是你定义的关联对象的 key，值是 ObjcAssociation ，这里做了一次包装，看下他的源码： 123456789101112class ObjcAssociation &#123; uintptr_t _policy; //存储策略，这个在销毁对象的时候需要用到； id _value;//被包装的对象 public: ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125; ObjcAssociation() : _policy(0), _value(nil) &#123;&#125; uintptr_t policy() const &#123; return _policy; &#125; id value() const &#123; return _value; &#125; bool hasValue() &#123; return _value != nil; &#125;//还记得上面用到这个方法了吗？ &#125;; 3.明白了setter方法之后，很容易理解getter方法，简单看下objc_getAssociatedObject内部的细节：12345678910111213141516171819202122232425262728293031323334353637//这是我们调用的方法id objc_getAssociatedObject(id object, const void *key)&#123; return objc_getAssociatedObject_non_gc(object, key);&#125;//这是内部的私有方法；id objc_getAssociatedObject_non_gc(id object, const void *key) &#123; return _object_get_associative_reference(object, (void *)key);&#125;//获取关联引用对象，最终将调用这个方法id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); //上面的还是那两步，最后根据key找到对应的关联对象；这里冒出来一个 getter policy，倒是很少遇见！或许在 copy 对象的时候才会遇见吧... if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease); &#125; return value;&#125; 五、内存如何管理关联引用对象是不需要管理内存的，这里看下源码就知道怎么回事了；销毁对象的时候，内部调用了这个方法：1234567891011121314151617181920212223242526/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory.* Calls C++ destructors.* Calls ARR ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.* Be warned that GC DOES NOT CALL THIS. If you edit this, also edit finalize.* CoreFoundation and other clients do call this under GC.**********************************************************************/void *objc_destructInstance(id obj)&#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects(); bool dealloc = !UseGC; // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj);//移除关联的对象 if (dealloc) obj-&gt;clearDeallocating(); &#125; return obj;&#125; 下面看下 _object_remove_assocations(obj) 方法： 123456789101112131415161718192021void _object_remove_assocations(id object) &#123; vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123; elements.push_back(j-&gt;second);//Add element at the end //http://www.cplusplus.com/reference/vector/vector/ &#125; // remove the secondary table. delete refs; associations.erase(i); &#125; &#125; // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());&#125; 从 manager 里取出类对应的 AssociationsHashMap，然后查找当前对象对应的AssociationsHashMap ；如果找到了，说明这个对象确实使用了关联引用，然后取出对应的 ObjectAssociationMap ； 接着枚举 ObjectAssociationMap ，取出关联的对象，然后放到 vector 的末尾； 最后通过 for_each 操作 vector 里的每一个元素，都去调用 ReleaseValue（）方法； 前面已经见过ReleaseValue()这个方法了，这里看下源码： 12345678910111213static void releaseValue(id value, uintptr_t policy) &#123; if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;//这就是为何要把关联的对象包装一下的原因！ ((id(*)(id, SEL))objc_msgSend)(value, SEL_release);//发送release消息； &#125;&#125;struct ReleaseValue &#123; //应该是重载运算符了，我的c++知识忘光了耶； void operator() (ObjcAssociation &amp;association) &#123; releaseValue(association.value(), association.policy()); &#125;&#125;; 由此看来，我们无需关系关联对象的内存管理，当一个对象释放的时候，会自动去释放被关联的对象！这也正好符合内存管理的法则：谁使用谁管理！ 六、验证类变量我觉得我的猜测应该是靠谱的，因此我打印了类的起始地址和结束地址，各种类变量地址，全局变量地址，以及对象地址，结果如下： 12345678910111213141516172016-03-06 14:17:42.056 StudyAssociationSourceCode[27561:2531350]-------------类方法的地址:0x100001770起始地址:0x100002320结束地址:0x100002328@implementation之内，方法之外全局变量地址:0x100002348实例方法内的静态变量地址:0x100002360@implementation之外，静态变量地址:0x100002361@implementation之内，方法之外静态变量地址:0x100002362对象的起始地址:0x1002005e0对象的结束地址:0x1002005e8--------------------------2016-03-06 14:17:42.056 StudyAssociationSourceCode[27561:2531350] association key:0x100002363 1.可以看出这几个的地址是连续的： 12340x100002360 :实例方法内的静态变量地址0x100002361 :@implementation之外，静态变量地址0x100002362 :@implementation之内，方法之外静态变量地址0x100002363 :@implementation之外的 association key 静态变量地址【不同的文件】 这说明类变量不管写到哪里都是放到了一起的，都在一个区域内； 2.这几个的内存空间是相近的： 1234560x100001770 :类方法的地址0x100002320 :类起始地址0x100002328 :类结束地址0x100002348 :全局变量地址0x100002360 :静态变量变量地址... 这里看起来很是怪异，类方法的地址竟然在类的地址空间之前！！要想解释这个现象就需要知道 OC 对象的继承体系、元类、Class结构体等，这里先卖个关子，后续博客介绍。 大体上看，凡是跟类相关的变量，无论是全局的还是静态的变量或方法的内存都是在一块逻辑区域内分配的； 3.对比类地址和对象地址： 120x100002320 :类起始地址0x100600450 :对象的起始地址 可以看出他们的内存空间差的很多，这说明了在内存分配上类和对象是分开的！更加具体的细节以后验证吧，我现在也不能把他们说明白。 这是我测试工程的地址：https://github.com/debugly/StudyAssociationSourceCode 七、总结一切都清楚了，对于 “类变量” 的理解也是没错的，简单的说：类变量是属于类的，实例变量是属于对象的，清楚这一点有利于我们在编码过程中正确的使用使用类变量，迅速找到使用类变量埋下坑，类变量属于类这一特性有时候真的可能会给你带来问题，比如你写一个局部静态变量，页面每次进来都修改下这个值，可是你会发现第二次进来的时候他仍旧是上次修改过的，或许这不是你想看到的！ 关联引用的实现如此巧妙，元类如此的迷人，这些都需要继续深入学习才能体会得到！苹果把 Runtime 开源了，那么我们就有必要去看看源码，即使我们不能为之作出什么贡献，但至少可以提升自身，对于知识体系的形成都有很大帮助！ 不足之处请多多指正！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"关联引用的使用方法","slug":"2016/03/05-Objc-Associations-Useage","date":"2016-03-05T14:57:36.000Z","updated":"2018-03-27T14:45:15.687Z","comments":true,"path":"2016/03/05/2016/03/05-Objc-Associations-Useage.html","link":"","permalink":"http://debugly.cn/2016/03/05/2016/03/05-Objc-Associations-Useage.html","excerpt":"","text":"实际开发中，关联引用的使用是很广泛并且实用的，比如我们熟知的 SDWebImage,下拉刷新控件，YYKit等库里均有使用；我 14 年看 EGO 下拉刷新实现的时候发现了这种用法，那是我第一次接触，这里简单的介绍下使用方法… 假如现有工程里已经有个类 SingletonObject，我想给他加个属性，我们知道类别是不可以加属性的，这里就要使用 Runtime 的技术了—关联引用； 1.第一步创建个类别文件，声明一个静态变量，用于被关联对象的和次对象产生关系； 1234static char keyAddress;@implementation SingletonObject (association)@end 2.导入头文件：#import &lt;objc/runtime.h&gt; ；提供getter和setter方法； 1234567891011- (void)setTestAddNum:(NSNumber *)testAddNum&#123; objc_setAssociatedObject(self, &amp;keyAddress, testAddNum, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSNumber *)testAddNum&#123; NSLog(@\"@implementation之外的 association key:%p\",&amp;keyAddress); NSNumber *value = objc_getAssociatedObject(self, &amp;keyAddress); return value;&#125; 3.把 getter 和 setter 方法暴漏到头文件中就行了，不过我们习惯了属性，因此我描述了一个属性； 123456@interface SingletonObject (association)//通过关联引用给 SingletonObject加上一个 testAddNum 属性；@property (nonatomic, retain) NSNumber *testAddNum;@end 4.这就OK啦，测试下吧： 123SingletonObject *single = [SingletonObject sharedInstance];single.testAddNum = @(3597);NSLog(@\"---%@\",single.testAddNum); 结果必须是打印“—3597”啦！ 5.这里我写的是个单例类，不过没关系啦，单利只是保证只有一个对象而已，我给这个对象关联一个 num 对象是木有问题的！ 总结关联引用+类别 有着继承无法比拟的优势！不需要创建新类就可以增加新的属性和方法，对于已有类没有侵害，不用修改继承体系！并且使用关联引用无需管理内存，详细的内部实现介绍请看下篇博客: 浅析关联引用； 测试工程的地址：https://github.com/debugly/StudyAssociationSourceCode","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"我的 2015","slug":"2015/12/31-my2015","date":"2015-12-31T14:01:58.000Z","updated":"2018-03-27T14:45:15.687Z","comments":true,"path":"2015/12/31/2015/12/31-my2015.html","link":"","permalink":"http://debugly.cn/2015/12/31/2015/12/31-my2015.html","excerpt":"今天是 2015 年的最后一天了，在 7月 7号那天我搭建了属于自己的博客，6个月的时间发布了 20篇博客，还有需要完善的 11篇没有发布，等日后完善好了，可以拿出来晒晒的时候再发出来吧，毕竟我不需要追求数量；现在简单回顾下过去的这两年我经历了什么，收获了什么？遇见了哪些可爱的人？","text":"今天是 2015 年的最后一天了，在 7月 7号那天我搭建了属于自己的博客，6个月的时间发布了 20篇博客，还有需要完善的 11篇没有发布，等日后完善好了，可以拿出来晒晒的时候再发出来吧，毕竟我不需要追求数量；现在简单回顾下过去的这两年我经历了什么，收获了什么？遇见了哪些可爱的人？ 14 年工作生活自我感觉是一个热爱工作的人，工作差一点就成为了我生活的全部了，除了工作也没太多别的爱好了，仅有的爱好也因为知识的匮乏和有限的精力加上种种的借口丢到角落里去了… 我 14年过完春节来的北京，3月份去了搜房网，在搜房挺好的，单位离家也比较近，为此还买了一辆山地车，夏天的时候我就是骑着车去的，大约需要半个小时多谢，在一个部队大院住，其实也挺好的，20平的房子吧，有台电视机，免费的网络、洗衣机、电冰箱、天然气、水等，每月 1000元，其实这跟我的一个同事阿杰离得很近呢，不过那个时候我们并不认识，我们是10月份才认识的。 一个人住很孤单，我的一个朋友经常来找我问些问题，他也是一个人，老婆孩子在家里，后来我就搬走和他一起合租了一个小次卧，每月 1400元，主要是有个说话的，凡事不那么无助吧，这次从东大街的最南边搬到了东大街一直往北走的另一条街上去了，那附件有个电影院，我办了会员卡，有时间就陪女友去看场电影，不过离我女朋友的单位就远了点了，需要坐2站的公交车，或者骑着我的车偶尔去送送饭，因为她上班很辛苦，有的时候真的是一天一顿饭呢！谁让我这么闲呢…这个小次卧是转租的，我们在这吃过火锅；还有次他烧梨糖忘记关火了，直到邻居说哪来的糊味，才知道烧干锅了，因为厨房的门关了，屋里开了空调了，所以闻不到糊味；那是夏季，因为都很喜欢吃西瓜，所以就经常买，然后回来用我们的公费报销，相处的很融洽，从来没有因为这点公费有过摩擦！房间好小，只有一个单人床，于是我睡在地上，他睡光板床，大概住了3个月吧，房东说是亲戚回来了，不租了，我们只好另寻别处，我记得我陪女友去开封考试了，说到这也谢谢我开封的那个同学，当然她应该根本就不会看见；房子是这个朋友找的，房子不好找，还是个转租的，是个 3居室，我们住在东面，所以每天早晨都可以看见太阳，之前的房子一个是背面的，一个是在西面的；在 10月底，我们就全部搬过去了，有的时候会做些饭，大多数是他做的，我不会做，我一般都选择刷刷锅而已，吃饭的时候没事干一起看看今日说法，让撒贝宁带着我们回到案发现场，看看警察是如何破获几十年前的案件的，说着说着就不禁开始回味起来了… 应该是搬家之后我的工作也有过调整，我一直在 7楼属于二手房部门的，10月有次人员变动，我们的租房帮项目不再继续做了，我们组就开始分散了，有的跳槽了，有的去了 9楼；而我去了 9楼，开始做搜房家居，属于搜房主 App的一个模块，移动组都是按业务模块分组的，有新房组，二手房组，家居装修组，技术组，通用组等等吧；每个组都有一个组长，我前面说到阿杰就是我们刚成立的小组组长，因为年龄差不多，技术也差不多，交流无障碍，所以成了我一直以来的好朋友；15年年底，阿杰去了一家创业公司，领导给我加薪后，大组长找我谈了话，说要我接替他的位置，其实我也接到了一家做 P2P 公司的邀请，还在考量之中；事发突然，我毫无准备，没有给大组长说出来，然后我们的郑总找了我，这下我想不要再隐瞒了，就如实说了我的情况—可能会去这个做金融的公司，让他多找个备胎；紧接着就到了过年了，除夕前天做了卧铺，除夕清晨到了老家，爸爸接的我们… 12314年感谢我的爱人，室友，阿杰，胖子(的牛肉干),搜房一起加班的同事们；一起吃饭，越来越少的 7 楼原班同事们...更要感谢我 7 楼的经理毕姐以及 9 楼的领导，我 7 楼的老大敬敬，没有你们就没有我 14 年的职业生涯... 15 年工作生活15 年的春节假期结束了，郑总给足了面子了，找我谈了话，我还是选择了离开，大组长也表示很无奈，然后办理了离职后去了那家名为太有乾的创业公司；在那里我认识了一批新的同事，不过我一直在忙着写我们的朋贝项目，所以交流不是那么多，不过也都很熟悉，很多也是河南老乡呢，因为初期就我自己，花了3个月写好了，白天一直写代码，都是一个人写，感觉怎么爽就怎么写，所以封装了好多东西，有的甚至是用 C 写的，原因是跟类无关，不依赖于某个类，我现在还有这样的习惯，诸如一些工具方法之类的还首先想到的还是 C方法而不是 OC的类方法，以及提供各种服务的 Service，存储 DAO等；五一过后招了一个朋友过来，需求也基本写完了，剩下的小任务我就交给他去完成了，我的任务不多了，利用了这些闲暇的时间创建了我的博客；那两个月信心满满的期待上线，期待着能在八月份拿到我们的 A轮呢，神马加薪都不是问题啊!…可是7月开了一个让我很意外的会议，我们的经理（我们这些同事都是他拉来的）突然说要离开了，我万万没有一点心理准备呀！紧接着就是上海总部的一个经理过来接管我们了，首先是梳理组织架构，然后说我们移动端可能接下来做一个新的项目—没几个页面，主要的页面成了H5了，支付也是；我可怜的朋贝就这么死在了襁褓里了，朋贝项目虽然没有上线，但是我们实现了所有的流程都是有的，我们的理财产品，发布众筹，购买，资产管理，充值，收益详情，登陆，注册，手势密码解锁… 7月份我联系了阿杰和敬敬，阿杰内推我去 51CTO，那里的 HR是他的老乡加同事；我给了简历，过了几天没信了，后来问了 HR才知道，原来是因为我是去年毕业的，感觉技术不行，没有面试机会，阿杰也是醉了，因为阿杰的同事（很菜的）已经面试通过了，我却机会都没有；回来经过 HR的帮助，约了 14号上午去面试，得知他们准备招个leader，我太年轻了，面试官不懂 iOS，面试的结果自然也不理想，有些技术没法说明白，只好问我算法了，我算法不好， LRU当时也不知道，真是后悔大学没有认真学习数据结构！完毕后直接去了搜狐，中午没有食欲，吃了一碗面而已，吃过饭在附件溜达一下，熟悉下环境，小树林里环境可不错呢，很多人在那里聊着天，嬉笑着，还有攀岩的呢；不到两点就去等着了，刚好遇见了一个搜房的老同事，寒暄了一下，挺好的，遇见熟人是可以减少我的压力的；等到了下午两点，我填写了一个面试登记表，然后约了面试官；来了两个人去了地下一层，我们聊得很不错，聊了两个小时，问了很多的问题，感觉比上午好多了，毕竟大都是 iOS的问题，多线程，网络协议，最后一个算法；当时很是兴奋的，真的感觉遇见了牛人了，很期待加入，最喜欢的是面试官的循循善诱，我不太理解的问题，他可以给我提示；然后紧接着是下来的是主管，我感觉我们聊得并不好，我的回答我自己都不满意呢；后来经过争取，在23号迎来了一次复试，最终搜狐决定要我了，不过不是我面试的高级工程师，因为以我现在的实力很不足以胜任！人贵在有自知之明，虽然不是高级的，我也很是高兴，因为我需要的是这个平台，而不是跟头衔挂钩的薪资！太有乾这边我是 30号拿到离职证明的，之前也有过加班，所以我们行政说 31号可以不来了。 太有乾这边已经确定了，重新做一个 App，对于这个新 App我真的不感冒，尽管我都没有离职，我已经不去写了，全部交给我的同事去写，有问题我来帮助解决，在我的内心深处最不舍得的是我们的朋贝，我一手写起来的朋贝！我们几个月的努力基本都白费了；经理走后，走了好几个人，我就是第二个走的；我们的UI设计先走的，安卓和我是一起走的，随后是我们的后台，我们的行政；现在公司还在，新的 App也上了线，据说又要重视 P2P了，想想真是可笑，人走了这么多了，技术主力都走了，怎么像做梦一样，才睡醒么？走了就是走了，都不可能再回去… 8 月先是和朋友一起去了欢乐谷玩耍，然后接下来没有意料到我会休息那么长时间，一直等着，8号去体检，照相，10号在线填写 offer 完毕，本以为 12号能去入职，结果 HR离职等原因，时间紧，不行；13号办理暂住证，办理租用公共自行车；这个证在以后考驾照也用得到；在 19号我终于去报道了！开始了搜狐的职业生涯… 在搜狐我很满足，我可以做我想做的，我负责下载相关业务，我一直在努力解决下载存在的问题，提高下载的成功率，发现了如下错误：516，404，403，-1001等等，其中 -1001的解决方法很逗呢，解决方案名字很是大气，叫反运营商劫持，以后有时间，我会写篇博客出来； 10月 25号我和我的同事阿杰一起报名考了驾驶证，这个貌似是个的必需品，也是大学应该拿到的，一直推到今天—15年的最后一天才拿到！报名的时候他好磨叽，还不愿意报，我再三劝说，终于还是报了，接下来的一个多月，我们就一起去驾校学习了，没有一点空闲了，确实有些累呢；阿杰科目三挂了，后台去补考，然后直接科目四，顺利拿到了驾照，我科目四迟迟没去考，直到看到 16年要实行新的交通法规了，我的同事也劝我去考，我才临时决定 31号去考试，结果考题还有 400多道没看完，科目四刚好及格，欧弟那个小心脏啊，最后3道多选，可是吓死宝宝了，生怕错了，心里默默告诉自己一道也不能错了，因为已经错了 5道题了！ 今年的圣诞节是在搜狐度过的，发了好几次苹果，送了她一个，还参加游戏拿到了限量的圣诞小狐狸； 好快，元旦来了,满满的都是对新的一年的期待… 1234515 年感谢好基友把我推荐到太有乾，体验了下创业公司，认识了那里的新同事们；感谢阿杰，敬敬的内推；感谢现在搜狐同事们的照顾，感谢在 2015遇见了你们... 16年计划现在下载的技术成功率已经高于其他平台了，不过这个还不够，对于一个很偏执的工匠来说，距离完美主义还有长的路，因为往上提升的难度越来越难了，这并不会吓到我滴，我会继续优化；还需要努力提升几个点上去！现阶段比较重要的是改进 404 和 -1001问题解决方案的成效！ iOS 工作已经 2年了，感觉自己的水平还是没有明显的提升，我需要学习的还有太多太多；下面就简单列举几个，等我这些完成了，再来更新这个博客，提出下一个规划，正如我国现在处于 12个五年计划，提出 13个五年计划一样，好高骛远不行，必须脚踏实地！YYKit 的作者我很佩服，也是 90后，学习 iOS的时间还没我时间长，但是技术确实牛叉，不得不说阅读有质量的开源代码是多么的重要，我也感觉到了学习技术真的没有捷径，就算是有捷径，也只有一个，那就是站在巨人的肩上，阅读他们的代码，思考如可解决问题，多一些解决问题的方法！ 对比 YYKit，MJExtension，Mantle，JOSNModel，优化我写的JSONUtil小框架； 阅读 AFNetWorking,也许不久的将来我们会升级到 iOS7，那么我会使用 AF3.0的库，抛弃AFURLConnection； 研读 SDWebImage和FastImage，加上 QQZone 给出的设计方案，想办法打造出一个更加快速的图片加载处理框架，其实我是读过 SDWebImage的，但是还没有优化过； Come on, mango, You can if you believe！","categories":[],"tags":[{"name":"个人总结","slug":"个人总结","permalink":"http://debugly.cn/tags/个人总结/"}]},{"title":"通过浏览器调试视图和沙河","slug":"2015/12/27-online debug","date":"2015-12-27T13:30:26.000Z","updated":"2018-03-27T14:45:15.687Z","comments":true,"path":"2015/12/27/2015/12/27-online debug.html","link":"","permalink":"http://debugly.cn/2015/12/27/2015/12/27-online debug.html","excerpt":"Introduction最近在 GitHub 上看到了 Damian 写的一个在浏览器调试视图的工程 iOS Hierarchy Viewer ，跟 xCode 自带的类似，不过几乎没什么版本限制，我在他的基础上增加了查看沙河文件的功能，增加了一个首页，和返回首页… At a glance 首页：","text":"Introduction最近在 GitHub 上看到了 Damian 写的一个在浏览器调试视图的工程 iOS Hierarchy Viewer ，跟 xCode 自带的类似，不过几乎没什么版本限制，我在他的基础上增加了查看沙河文件的功能，增加了一个首页，和返回首页… At a glance 首页： 调试试图： 调试沙河： 沙河调试之前都是使用 iFunBox 导出沙河里的文件，iOS 8之后不能导出线上，这可能出于更加安全的考虑，但是也给开发人员导出日志增加了难度；因此开发了这个线上导出的功能，用于 debug 调试； 用到的技术设备这边作为 socket 服务器端，看了实现下跟大学学习的 Linux 网络编程是一样，所以看了下就明白了，使用 HTTP 协议传输数据，为了使下载的文件有文件名和后缀名还要学习下 HTTP 相应头，通过 socket 以 JSON 格式传输本地遍历的目录数据，然后通过 JS 处理下数据使用开源的 zTree 展示；你或许还要了解这些技术才行 js，jQuery，html，css，socket… 下载沙河文件如上图看到的树状结构，你可以点击加号展开，这个使用 ajax 异步加载的；点击文件就直接下载到本地了，我是用的是 chrom 浏览器，safari 的表现可能没有这么好，这个日后再来调整； 使用方法 1.执行 build_fat 就能自动打出一个静态库来了; 2.连同 bundle 拖到你的工程里，导入头文件，调用 startService 方法启动服务; 观察控制台输出的 IP 地址，粘贴到浏览器就可以啦… 123456@interface iOSOnlineDebug : NSObject+ (BOOL)startService;+ (void)stopService;@end 项目地址： iOSOnlineDebug","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"Remember review your code","slug":"2015/12/07-review your code","date":"2015-12-07T12:05:14.000Z","updated":"2018-03-27T14:45:15.687Z","comments":true,"path":"2015/12/07/2015/12/07-review your code.html","link":"","permalink":"http://debugly.cn/2015/12/07/2015/12/07-review your code.html","excerpt":"","text":"今天科目二顺利过关，很高兴，可是紧接着就再也高兴不起来了，因为由于我的失误造成公司的项目上线延期了一天，失误了，原因很简单，没有看清楚类别是加了 DEBUG 判断了，我的方法当然也被这个宏包裹了，所以 release 下必崩无疑！","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://debugly.cn/tags/Other/"}]},{"title":"iOS 通用 Alert、ActionSheet","slug":"2015/12/04-ql-commom-alert","date":"2015-12-04T14:41:00.000Z","updated":"2018-03-27T14:45:15.687Z","comments":true,"path":"2015/12/04/2015/12/04-ql-commom-alert.html","link":"","permalink":"http://debugly.cn/2015/12/04/2015/12/04-ql-commom-alert.html","excerpt":"Introduction在 14 年 iOS 8 发布之后就想着统一一下 AlertView 和 iOS 8 开始使用的 AletViewController，最近终于把这事给办了；虽然最近也很忙，但还是准备了不少东西，除了这个通用封装之外，紧接着将还有一篇，先剧透下—是有关通过浏览器线上调试的… 封装思路iOS 8 有了很大的变化，每个按钮对应了一个 UIAlertAction 对像，相关的索引和标题都在这里存放；block 回掉点击事件；因此，想办法处理一下 iOS 7 的AlertView，使之支持添加 Action，block 回掉点击事件；然后搞个manager，来管理 iOS 8 前后调用的类，从而达到通用的效果! ActionSheet 也是同样的道理，我觉得分开处理比较好，因此最终我讲封装出来两个控制器出来。 iOS 7并没有 Action 类，因此自己写个命名为 QLBlockAlertAction ;并且定义相关的枚举值，这个很好做，直接 copy iOS 8 系统定义的改个名字就行了; 实现代码按照上面描述的思路开始 code： 处理 iOS 7 的 AlertView123456789@interface QLBlockAlertAction : NSObject+ (instancetype)actionWithTitle:(NSString *)title style:(QLAlertActionStyle)style handler:(void (^)(QLBlockAlertAction *action))handler;@property (nonatomic, copy, readonly) NSString *title;@property (nonatomic, assign,readonly) QLAlertActionStyle style;@property (nonatomic, copy, readonly) void (^AlertHandler)(QLBlockAlertAction *);@end","text":"Introduction在 14 年 iOS 8 发布之后就想着统一一下 AlertView 和 iOS 8 开始使用的 AletViewController，最近终于把这事给办了；虽然最近也很忙，但还是准备了不少东西，除了这个通用封装之外，紧接着将还有一篇，先剧透下—是有关通过浏览器线上调试的… 封装思路iOS 8 有了很大的变化，每个按钮对应了一个 UIAlertAction 对像，相关的索引和标题都在这里存放；block 回掉点击事件；因此，想办法处理一下 iOS 7 的AlertView，使之支持添加 Action，block 回掉点击事件；然后搞个manager，来管理 iOS 8 前后调用的类，从而达到通用的效果! ActionSheet 也是同样的道理，我觉得分开处理比较好，因此最终我讲封装出来两个控制器出来。 iOS 7并没有 Action 类，因此自己写个命名为 QLBlockAlertAction ;并且定义相关的枚举值，这个很好做，直接 copy iOS 8 系统定义的改个名字就行了; 实现代码按照上面描述的思路开始 code： 处理 iOS 7 的 AlertView123456789@interface QLBlockAlertAction : NSObject+ (instancetype)actionWithTitle:(NSString *)title style:(QLAlertActionStyle)style handler:(void (^)(QLBlockAlertAction *action))handler;@property (nonatomic, copy, readonly) NSString *title;@property (nonatomic, assign,readonly) QLAlertActionStyle style;@property (nonatomic, copy, readonly) void (^AlertHandler)(QLBlockAlertAction *);@end 这个是支持AlertView block 回调的； 123456789@interface QLBlockAlertView : UIAlertView+ (instancetype)alertWithTitle:(NSString *)title message:(NSString *)message;- (void)addActionWithTitle:(NSString *)title style:(QLAlertActionStyle)style handler:(void (^)(QLBlockAlertAction *action))handler;@property (nonatomic, strong, readonly) NSArray *actions;@end 集成系统类，封装得跟 iOS 8一样，这样减轻了manager的麻烦，就能统一处理了，支持添加 action； 12345typedef NS_ENUM(NSInteger, QLAlertActionStyle) &#123; QLAlertActionStyleDefault = 0, QLAlertActionStyleCancel, QLAlertActionStyleDestructive //actionsheet使用&#125;; 这个很简单，copy iOS 8 的就行了；主要是区分 actionstyle 和 alert 和 actionsheet 的；iOS 8 alert 和 actionsheet 是一个控制器；这个抽取一个Header 叫：QLAlertSheetCommonHeader ； 到此为止 iOS 8之前的 alertview 已经改造完毕了；现在就可以是使用了；同样的方式去改造 actionsheet； 123456789@interface QLBlockActionSheet : UIActionSheet- (instancetype)initWithTitle:(NSString *)title;- (void)addActionWithTitle:(NSString *)title style:(QLAlertActionStyle)style handler:(void (^)(QLBlockAlertAction *action))handler;@property (nonatomic, strong, readonly) NSArray *actions;@end 接下来改写我们的统一的管理者了，这里分开写，一个是管理 AlertView 的，一个是管理 ActionSheet 的；这里简单看下 AlertView 的通用管理者： QLAlertViewController ； 1234567891011@interface QLAlertViewController : NSObject+ (instancetype)alertWithTitle:(NSString *)title message:(NSString *)message;- (void)addActionWithTitle:(NSString *)title style:(QLAlertActionStyle)style handler:(void (^)(QLBlockAlertAction *action))handler;- (NSArray *)actions;- (void)showInViewController:(UIViewController *)vc;@end 看着跟 iOS 8的没什么两样，所以就没写注释；看下内部实现吧： 123456789101112131415161718192021@interface QLAlertViewController ()@property (nonatomic, strong) QLBlockAlertView *alertView;@property (nonatomic, strong) UIAlertController *alertController;@end@implementation QLAlertViewController- (instancetype)initWithTitle:(NSString *)title message:(NSString *)message&#123; self = [super init]; if (self) &#123; if (_IS_IOS8_LATER_) &#123; self.alertController = [UIAlertController alertControllerWithTitle:title message:message preferredStyle:UIAlertControllerStyleAlert]; &#125;else&#123; self.alertView = [QLBlockAlertView alertWithTitle:title message:message]; &#125; &#125; return self;&#125; 说白了就是根据系统版本进行区分，iOS 8 以后就用系统的 UIAlertController 处理；反之就使用我们封装的 QLBlockAlertView ；因为我们是按照 iOS 8 的形式封装的，所以内部处理也很简单： 123456789101112131415161718- (void)addActionWithTitle:(NSString *)title style:(QLAlertActionStyle)style handler:(void (^)(QLBlockAlertAction *))handler&#123; if (_IS_IOS8_LATER_) &#123; void (^actionHandler)(UIAlertAction * action) = NULL; if (handler) &#123; actionHandler = ^(UIAlertAction * action)&#123; QLBlockAlertAction *ac = [QLBlockAlertAction actionWithTitle:title style:style handler:handler]; handler(ac); &#125;; &#125; UIAlertAction *action = [UIAlertAction actionWithTitle:title style:QLAlertActionStyle2UIAlertActionStyle(style) handler:actionHandler]; [self.alertController addAction:action]; &#125;else&#123; [self.alertView addActionWithTitle:title style:style handler:handler]; &#125;&#125; 展示 AlertView 的使用需要一个控制器: 123456789101112- (void)showInViewController:(UIViewController *)vc&#123; if (_IS_IOS8_LATER_) &#123; UIViewController *presentingViewController = vc; while (presentingViewController.presentedViewController) &#123; presentingViewController = presentingViewController.presentedViewController; &#125; [presentingViewController presentViewController:self.alertController animated:YES completion:nil]; &#125;else&#123; [self.alertView performSelectorOnMainThread:@selector(show) withObject:nil waitUntilDone:YES]; &#125;&#125; 是不是很简单呢？有木有… 简单的使用看下 ActionSheet 的使用吧，AlertView跟也是这个一样的： 1234567891011121314151617181920//创建对象；QLActionSheetController *actionsheet = [QLActionSheetController actionSheetWithTitle:@\"哼哼，我是一个ActionSheet\"]; //添加处理action； [actionsheet addActionWithTitle:@\"我很特别吧！\" style:QLAlertActionStyleDestructive handler:^(QLBlockAlertAction *action) &#123; [weakself updateForRow:indexPath.row text:action.title]; &#125;]; //添加处理action； [actionsheet addActionWithTitle:@\"你很闲吗？\" style:QLAlertActionStyleDefault handler:^(QLBlockAlertAction *action) &#123; [weakself updateForRow:indexPath.row text:action.title]; &#125;]; //添加取消action； [actionsheet addActionWithTitle:@\"喝杯咖啡怎么样？\" style:QLAlertActionStyleCancel handler:^(QLBlockAlertAction *action) &#123; [weakself updateForRow:indexPath.row text:action.title]; &#125;]; //展示； [actionsheet showInViewController:self]; 效果 项目地址已经传到了 github 上了，欢迎 pull request ，多谢支持！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"Xcode7 Transition Guide","slug":"2015/11/11-xcode7-transition","date":"2015-11-11T13:41:12.000Z","updated":"2018-03-27T14:45:15.686Z","comments":true,"path":"2015/11/11/2015/11/11-xcode7-transition.html","link":"","permalink":"http://debugly.cn/2015/11/11/2015/11/11-xcode7-transition.html","excerpt":"","text":"Introduction使用 Xcode 7 开发已经有一段时间了，记录下使用时遇见的问题；有些东西记不住，所以当做笔记，需要的时候打开博客复制下就好了。 Bitcode 一般好多第三方库不支持这个特性，毕竟是苹果刚推出的，需要一段时间，这个等日后第三方库都支持之后可以开启，暂时需要关闭，否则将出现如下类似的错误！这个设置项默认是开启的，在 build setting 里搜索就可以找到啦。 NSAppTransportSecurity 使用 Xcode 7之后发现接口（HTTPS 除外）不好使了，没数据了！尼玛啊，什么情况，坑死老子嘛？！不要慌张，在你工程的 info.plist （这个可以修改，默认是info）里添加个字典配置下就可以啦：（可以右键plist，Open as-&gt; Source Code 然后复制到最后，plist本身也是个文本（xml）文件，所以当然可以这样看啦） 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt;&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt; 昨天刚从 7GM 版升级到了 7.1,在添加这个字典的时候就发现系统做了修改，自动把你写的 NSAppTransportSecurity 变为 App Transport Security Settings 这个不用我们管他，是自动变的。这是比较懒的做法，我们写Demo的时候可以直接这样搞，如果项目里的接口 HTTPS 的居多，则可以过滤特定的，具体怎么做就请自己 Google 吧,建议使用 HTTPS 的接口，最近 Xcode Ghost 事件闹得沸沸扬扬的，如果是 HTTPS 就不会这样了，当然使用 HTTPS 会使得接口更慢，需要增加成本在证书机构购买 SSL 证书… 使用条件预编译 使用 IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 90000 兼容 7之前的 Xcode 编译，可以在 Xcode 7上看到宏定义 IPHONE_9_0 就是 90000；具体这么写： 123#if (__IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 90000)//your ios 9 SDK code#endif 有了这些就做 iOS9 的适配工作了… 申请自己的证书使用 Xcode 7之后就可以登录自己的普通账户，调试我们写的 demo 的时候把team改为自己的账户名，然后就会提示自动请求匹配的证书。 升级到 OS X EI Captain 之后 jekyll 丢了 Errno::ENOENT: No such file or directory - jekyll 所以这篇博客没那么顺利发布了就，苹果搞什么飞机啊！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"Mac 上使用 SSH key","slug":"2015/11/06-Use-ssh-key","date":"2015-11-06T13:35:37.000Z","updated":"2018-03-27T14:45:15.686Z","comments":true,"path":"2015/11/06/2015/11/06-Use-ssh-key.html","link":"","permalink":"http://debugly.cn/2015/11/06/2015/11/06-Use-ssh-key.html","excerpt":"","text":"Introduction SSH key 用来标识某台计算机被信任！一旦被信任，以后在这台计算机上进行的操作就不需要输入你账户的密码，可以理解为令牌，拿着令牌就可以做事，当然权限是可控制的！SSH key 是部分平台的，也就说今天举例的 MAC 系统可以用，经常使用的 Windows 也可以用，Linux等系统均可，因为说白了就是使用了一种加密方法，计算机生成了一对密钥；一个公钥，一个私钥，公钥当然就是公开使用的，一般会用于第三方平台，私钥是保留在计算机里的，因此在操作的时候只需公私钥配对即可，只要配对就认为是信任的计算机所为，就可以继续操作！今天以 SSH key 方式访问 github 举例… 使用场景 免密码登录远程服务器 免密码推送、拉取 git 远程仓库 比如我的博客使用的是 git page，说白了就是一个特殊的 github 仓库而已；本地生成站点之后，就需要 push 到 github，为了不用每次都输入用户名和密码，可以配置 ssh key，然后把远程仓库地址设置为 ssh 格式即可。 工作时虽然使用的是内部的 git 托管服务器 git lab，但使用方式跟 github 也没啥不一样的，同样支持配置 ssh key。 查看本地 ssh 密钥ssh 公钥默认存放在 ~/.ssh 目录下，因此可以 ls 查看下： 12345678910111213ls ~/.ssh如果曾经使用过 GitHub 客户端的话，应该是这样的：-rw------- 1 xuqianlong staff 1766 3 11 2015 github_rsa-rw-r--r--@ 1 xuqianlong staff 405 10 18 17:31 github_rsa.pub-rw-r--r-- 1 xuqianlong staff 1595 7 2 01:33 known_hosts也有可能是这样的：-rw------- 1 xuqianlong staff 3243 8 20 00:15 id_rsa-rw-r--r-- 1 xuqianlong staff 742 8 20 00:15 id_rsa.pub-rw-r--r-- 1 xuqianlong staff 803 8 20 09:38 known_hosts只不过是文件名的前缀不同罢了； 如果 ssh 已经添加到 github 了，那么可以通过 ssh -T git@github.com 验证下： 1234还没添加：Permission denied (publickey).或者：Hi debugly! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 如果本地没有可用的 ssh key，或者你不想用之前的，或者想让之前的实效，那么你可以全部删掉，然后重新生成即可。 生成新的 SSH Key使用 ssh-keygen -t rsa -b 4096 -C &quot;xx@yyyzzz.com&quot; 生成，这里的 “xx@yyyzzz.com“ 替换成你的邮箱或者随便写都行，没限制的，最好起个能分的清楚的名字，有可能你有多个电脑，配置了多个 key。 输入上面的命令后，接下来连续 3 次回车就好了，具体细节是： Enter file in which to save the key (/Users/xuqianlong/.ssh/id_rsa): 文件存放位置，默认(~/.ssh) Enter passphrase (empty for no passphrase):我这里无需设置密码，直接回车 Enter same passphrase again: 再次输入密码回车 这是我执行的结果： 12345678910111213141516171819202122bogon:~ xuqianlong$ ssh-keygen -t rsa -b 4096 -C \"qianlongxu@home.mbp\"Generating public/private rsa key pair.Enter file in which to save the key (/Users/xuqianlong/.ssh/id_rsa): Created directory '/Users/xuqianlong/.ssh'.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/xuqianlong/.ssh/id_rsa.Your public key has been saved in /Users/xuqianlong/.ssh/id_rsa.pub.The key fingerprint is:SHA256:GzJ1j3gh0ws/IwF/KMQwoIvHhmnoPPW/v+w+pmDmSFo qianlongxu@home.mbpThe key's randomart image is:+---[RSA 4096]----+| ..ooo || . o.o o ||. . O = ||o= o X = ||*.+. o S B . ||+o. . o = o || + E = . || = = o .o || . . . +B*o |+----[SHA256]-----+ 添加到 ssh-agent ssh-add ~/.ssh/id_rsa : Identity added: /Users/xuqianlong/.ssh/id_rsa (/Users/xuqianlong/.ssh/id_rsa) 即使不操作这一步，一般也没问题的。 如果英文不错，那么可以直接去看 github 官网提供的文档： Generating-ssh-key . Github 账号添加 SSH key 将公钥复制到剪切板 pbcopy &lt; ~/.ssh/id_rsa.pub或者cat ~/.ssh/id_rsa.pub | pbcopy 登录 Github 账号，点击 Setting: 点击左侧的 SSH keys: 点击 Add SSH keys: 直接将公钥复制到输入框里面，一般 title 会自动生成: 点击 Add key 即可: 添加到 github 后检查下 ssh key 状态 ssh -T git@github.com 应该看到如下内容: 123The authenticity of host &apos;github.com (192.30.252.130)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 因为这是第一次使用，没有 IP 记录，因此输入 yes 即可； 12Warning: Permanently added &apos;github.com,192.30.252.130&apos; (RSA) to the list of known hosts.Hi debugly! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 看到你 Github 的用户名后就表示成功了！ 体验免密码 git clone git@github.com:debugly/NeedUpdate.git 1234567Cloning into 'NeedUpdate'...remote: Counting objects: 149, done.remote: Compressing objects: 100% (98/98), done.remote: Total 149 (delta 42), reused 149 (delta 42), pack-reused 0Receiving objects: 100% (149/149), 10.30 MiB | 16.00 KiB/s, done.Resolving deltas: 100% (42/42), done.Checking connectivity... done.","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"Swift 学习（一）","slug":"2015/11/05-swift-study-1","date":"2015-11-05T15:46:42.000Z","updated":"2018-03-27T14:45:15.686Z","comments":true,"path":"2015/11/05/2015/11/05-swift-study-1.html","link":"","permalink":"http://debugly.cn/2015/11/05/2015/11/05-swift-study-1.html","excerpt":"IntroductionSwift 最新已经是 2.1 了，更优美了，日趋成熟了，加上公司项目以后可能支持到 iOS7，就可以使用 Swift 写项目了，所以必须学习下了，先看看官方的文档: Using Swift with Cocoa and Objective-C (Swift 2.1) Interoperablility : 互动性 Initialization oc 初始化方法，在swift里省去了with，with后面的变成了参数名： 1234- (instancetype)initWithFrame:(CGRect)framestyle:(UITableViewStyle)style;init(frame: CGRect, style: UITableViewStyle) &#123; /* ... */ &#125; oc alloc swift不需要调用，alloc和init一气呵成： 123UITableView *myTableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped];let myTableView: UITableView = UITableView(frame: CGRectZero, style: .Grouped) Class Factory Methods and Convenience Initializers oc 工厂方法保留，提供便利性 123UIColor *color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];let color = UIColor(red: 0.5, green: 0.0, blue: 0.5, alpha: 1.0)","text":"IntroductionSwift 最新已经是 2.1 了，更优美了，日趋成熟了，加上公司项目以后可能支持到 iOS7，就可以使用 Swift 写项目了，所以必须学习下了，先看看官方的文档: Using Swift with Cocoa and Objective-C (Swift 2.1) Interoperablility : 互动性 Initialization oc 初始化方法，在swift里省去了with，with后面的变成了参数名： 1234- (instancetype)initWithFrame:(CGRect)framestyle:(UITableViewStyle)style;init(frame: CGRect, style: UITableViewStyle) &#123; /* ... */ &#125; oc alloc swift不需要调用，alloc和init一气呵成： 123UITableView *myTableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyleGrouped];let myTableView: UITableView = UITableView(frame: CGRectZero, style: .Grouped) Class Factory Methods and Convenience Initializers oc 工厂方法保留，提供便利性 123UIColor *color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];let color = UIColor(red: 0.5, green: 0.0, blue: 0.5, alpha: 1.0) Failable Initialization oc 初始化失败返回 nil, swift 把这处理成了一种语言特性，称之为 failable initialization. 12345if let image = UIImage(contentsOfFile: \"MyImage.png\") &#123;// loaded the image successfully&#125; else &#123;// could not load the image&#125; Accessing Properties swift property attributes: nonnull,nullable,null_resettable readonly: just a getter {get} weak: marked with the weak keyword (weak var) assign,copy,strong,unsafe_unretained == oc atomic / noatomic : are not reflected in swift(没有用了，不过oc导入swift的时候有用) getter= / setter= : are ignoerd by swift(忽略了) 访问属性使用 dot. Working with Methods swift 里访问 oc 的方法也可以使用 dot. 123456 oc 方法名被拆开：[myTableView insertSubview:mySubview atIndex:2]; swift 方法名是oc的第一段，剩下的段作为参数名，第一个参数并没有参数名！myTableView.insertSubview(mySubview, atIndex: 2) 对于没有参数的，直接带个小括号myTableView.layoutIfNeeded() id Compatibility id compatibility 兼容性：swift include an AnyObject type, is similar to oc&#39;s id type;保持类的灵活性； 12345var myObject: AnyObject = UITableViewCell()myObject = NSDate()let futureDate = myObject.dateByAddingTimeInterval(10)let timeSinceNow = myObject.timeIntervalSinceNow This includes Objective-C compatible methods and properties marked with the @objc attribute. Unrecognized Selectors and Optional Chaining 和 oc 一样的，AnyObject 对象调用方法不会有警告，如果不能响应，在运行时就会crash; For example, the following code compiles without a compiler warning, but triggers an error at runtime: 12myObject.characterAtIndex(5)// crash, myObject doesn't respond to that method 不过 swift 做的很好！！！ swift use optionals to guard against such unsafe behavior. swift 使用自选项来规避诸如此类的危险行为。 Accessing a property on AnyObject always returns an optional value. 属性访问总是返回自选值； Downcasting AnyObject 当确定或者能够合理推断时向下转换对象类型； but can not guaranteed to succeed. 不确定的时候用 ： as?12345let userDefaults = NSUserDefaults.standardUserDefaults()let lastRefreshDate: AnyObject? = userDefaults.objectForKey(\"LastRefreshDate\")if let date = lastRefreshDate as? NSDate &#123;print(\"\\(date.timeIntervalSinceReferenceDate)\")&#125; 确定的时候用： as!12let myDate = lastRefreshDate as! NSDatelet timeInterval = myDate.timeIntervalSinceReferenceDate 如果类型不一致就会报错，有点assert的味道哦1let myDate = lastRefreshDate as! NSString // Error Nullability and Optionals oc object references can be nil, swift all values--including structures and object references--are guaranteed to be on-null. value 的 type 是可选的；赋值为 nil 意味着 值的丢失；Instead, you represent a value that could be missing by wrapping the type of the value in an optional type. When you need to indicate that a value is missing, you use the value nil. For more information about optionals, see Optionals in The Swift Programming Language (Swift 2.1). 情形 使用 针对于个人类型: _Nullable / _Nonnull 针对于个人属性: nullable / nonnull / null_resettable 针对于整个区域: NS_ASSUM_NONNULL_BEGIN - NS_ASSUM_NONNULL_END 如果没有相关的信息，swift 就不能区分是不是自选的，并且将作为 an implicitly unwrapped optional. For example, consider the following Objective-C declarations: 1234567891011121314@property (nullable) id nullableProperty;@property (nonnull) id nonNullProperty;@property id unannotatedProperty;NS_ASSUME_NONNULL_BEGIN- (id)returnsNonNullValue;- (void)takesNonNullParameter:(id)value;NS_ASSUME_NONNULL_END- (nullable id)returnsNullableValue;- (void)takesNullableParameter:(nullable id)value;- (id)returnsUnannotatedValue;- (void)takesUnannotatedParameter:(id)value; Here’s how they’re imported by Swift: 123456789101112var nullableProperty: AnyObject?var nonNullProperty: AnyObjectvar unannotatedProperty: AnyObject!func returnsNonNullValue() -&gt; AnyObjectfunc takesNonNullParameter(value: AnyObject)func returnsNullableValue() -&gt; AnyObject?func takesNullableParameter(value: AnyObject?)func returnsUnannotatedValue() -&gt; AnyObject!func takesUnannotatedParameter(value: AnyObject!) Lightweight Generics 轻型、泛型 For example, consider the following Objective-C property declarations: 123@property NSArray&lt;NSDate *&gt; *dates;@property NSSet&lt;NSString *&gt; *words;@property NSDictionary&lt;NSURL *, NSData *&gt; *cachedData; Here’s how Swift imports them: 123var dates: [NSDate]var words: Set&lt;String&gt;var cachedData: [NSURL: NSData] 除了Foundation这些之外，别的会被忽略；Aside from these Foundation collection classes, Objective-C lightweight generics are ignored by Swift.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"小心 unsigned 数据类型埋下坑","slug":"2015/10/30-unsigned-type-use","date":"2015-10-30T13:59:14.000Z","updated":"2018-03-27T14:45:15.685Z","comments":true,"path":"2015/10/30/2015/10/30-unsigned-type-use.html","link":"","permalink":"http://debugly.cn/2015/10/30/2015/10/30-unsigned-type-use.html","excerpt":"","text":"Introduction 今天来说下使用 unsigned 数据类型时遇到的坑，也许这个很不起眼，但是有的时候她会坑了你的，如果你不信就来试试下面这道题，如果做对了那么说明你很细心，足够优秀，也不用继续看我的博客了，当然这也不排除是由于我提前说明了注意点使你细心… 小试牛刀习惯性的说下故事的背景，无缘无故的剧情我不喜欢，也不会是我入戏，作为一个 coder ，就像演员一样，你若想很出色地展示出你的演技就要入戏很深… 项目中某处逻辑需要评估磁盘剩余空间，以便做出决策是否继续任务，故而同事写了类似如下的逻辑： 12345678910- (BOOL)hasEnoughDiskSpace &#123; //获取磁盘剩余空间； UInt64 validFreeSpaceSize = [self getTotalFreeSpace]; //此次任务需要的总空间； UInt64 taskTotalSize = self.totalSize; //此次任务已经完成的空间； UInt64 downloadedSize = self.finishedSize; return ((validFreeSpaceSize - (taskTotalSize - downloadedSize)) &gt; 0);&#125; 题目剖析不用说上面的代码肯定是存在问题的，下面是我改过之后的代码，对比下也没有多少不同，按数学运算来看没什么不一样，你说是吗： 12345678910- (BOOL)hasEnoughDiskSpace &#123; //获取磁盘剩余空间； UInt64 validFreeSpaceSize = [self getTotalFreeSpace]; //此次任务需要的总空间； UInt64 taskTotalSize = self.totalSize; //此次任务已经完成的空间； UInt64 downloadedSize = self.finishedSize; return (validFreeSpaceSize &gt; (taskTotalSize - downloadedSize));&#125; 看到这里你能明白问题出在哪了吗？如果你还是疑惑的话，或许你该去复习下 C 语言的数据类型了，特别是 有没有符号这一说；C 语言基础数据类型默认是有符号的，也就说有正负之分，无符号意味着都是非负数；上面之所以使用无符号是因为空间的大小不会存在负的，还有就是使用无符号能够表示的值就是有符号的二倍！ 简单了解了 unsigned 之后，就来仔细看这个表达式吧： 当 validFreeSpaceSize 大于 (taskTotalSize - downloadedSize) 时，确实没有问题； 当 validFreeSpaceSize 等于 (taskTotalSize - downloadedSize) 时，也没有问题； 当 validFreeSpaceSize 小于 (taskTotalSize - downloadedSize) 时，问题就来了，由于是无符号数据类型，所以我们认为的结果会是一个负值，其实却是一个非常大的正值！因此当没有足够磁盘空间的时候也检查不出来，说白了这个检查没有作用，永远返回 YES！ 经过这样 (validFreeSpaceSize &gt; (taskTotalSize - downloadedSize)) 的比较其实就避免了刚才小于判断出错问题； 后记对于 unsigned 这种数据类型来说是需要的，因为他能够表示值的空间大了一倍，诸如磁盘空间这样的场景使用有符号类型也是一种浪费，因为变量占用着同样大小的空间，却不能够表示那么大的范围！因此使用时切记她带来的非负性就好了，不要让结果和 0 比较！ C 语言的数据类型长度不是固定的，跟机器字长有关系，我也记不太清；不过 Java 是跨平台的，长度固定，这个是我记忆中的 Java 数据类型长度，可以简单看下： 类 型 长 度 值的范围 无符号值的范围 Byte 1 -2(7)-1 ~ 2(7) 0 ~ 2(8)-1 char 2 -2(15)-1 ~ 2(15) 0 ~ 2(16)-1 short 2 -2(15)-1 ~ 2(15) 0 ~ 2(16)-1 int 4 -2(31)-1 ~ 2(31) 0 ~ 2(32)-1 long 8 -2(63)-1 ~ 2(63) 0 ~ 2(64)-1","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"使用 Block 的一些技巧和心得","slug":"2015/10/29-Block_Use_Experiences","date":"2015-10-29T13:43:10.000Z","updated":"2018-03-27T14:45:15.685Z","comments":true,"path":"2015/10/29/2015/10/29-Block_Use_Experiences.html","link":"","permalink":"http://debugly.cn/2015/10/29/2015/10/29-Block_Use_Experiences.html","excerpt":"Introduction项目中大量使用了 Block，今天无意间有了新的用法，不同往常的一般使用方法，使得编程又有了新的乐趣！想了一下，第一次写 Block 应该是两年前了，这么长时间并没有总结过，今天顺便总结下使用 Block 的场景 … Block的一般使用场景 以下场景均是个人理解，词汇也是个人命名，理解就好了： 完成事情的回掉；方法一般可以附加一个 completion handler 参数作为完成的回掉，AFNetworking 里网络请求好多都是这种场景了，比如这个方法，GET 请求成功后就会回调 success ，失败则回调 failure，并且可以带有 参数 （ps：这个以后会有大用处）！ 1234- (NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(id)parameters success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure; 下发任务的区块；方法附带一个获取任务的 block,我们把需要处理的任务放到里面即可，利用 GCD 派发任务，做动画等等都是这样做的，由于是单纯的任务，所以一般不需要参数： 123456789void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);[UIView animateWithDuration:0.25 animations:^&#123; //do your animates&#125;];[NSBlockOperation blockOperationWithBlock:^&#123; //your task &#125;]; 权利下放；如果做一件事情的时候，我们不知道该如何拍板，抉择的时候，就可以把这个权利下放给调用者，这样的代码就显得很灵活； 123[needSortArray sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return NSOrderedAscending;//your power!&#125;]; 封装代码块；如果你的逻辑比较复杂，需要判断很多种情况，各种 if else 嵌套；很多个 else 的地方都调用同样的代码块，则可以考虑使用 block 块；我觉得你应该也遇见过这种情况！至少我见过别人这么写过，结果就是同样的代码块几十行，在一个方法里写了两次，其实不用 block 也行的，抽取一个方法或许也行，使用 block 的好处，大概就是可以捕获了！如果代码块是一个方法，那么可能就没必要使用 block 来封装了，不过如果是好多行的逻辑，使用 block 封装下很是比较好的！ 123456789101112131415161718192021NSString* (^callback)(NSArray *needSortArray) = ^(NSArray *needSortArray)&#123; [needSortArray sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return NSOrderedAscending;//your power! &#125;]; return [needSortArray componentsJoinedByString:@\"|\"]; &#125;; BOOL A,B,C; NSArray *needArr = @[@\"A\",@\"C\",@\"D\",@\"F\",]; if (A) &#123; if (B) &#123; if (C) &#123; [self handleArr:needArr]; &#125;else&#123; callback(needArr); &#125; &#125;else&#123; [self handleArr2:needArr]; &#125; &#125;else&#123; callback(needArr); &#125; 从技术层面上看，基本上这些使用代理也可以完成，但是绝对没有使用 block 来的优雅！我是一个喜欢使用的 block 的 coder，因为觉得编写代理很麻烦，代码不是那么的直观；这里只是简单总结了下平时我经常用到的场景，当然还有别的很多场景；希望你能发邮件给我，补充这里来；","text":"Introduction项目中大量使用了 Block，今天无意间有了新的用法，不同往常的一般使用方法，使得编程又有了新的乐趣！想了一下，第一次写 Block 应该是两年前了，这么长时间并没有总结过，今天顺便总结下使用 Block 的场景 … Block的一般使用场景 以下场景均是个人理解，词汇也是个人命名，理解就好了： 完成事情的回掉；方法一般可以附加一个 completion handler 参数作为完成的回掉，AFNetworking 里网络请求好多都是这种场景了，比如这个方法，GET 请求成功后就会回调 success ，失败则回调 failure，并且可以带有 参数 （ps：这个以后会有大用处）！ 1234- (NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(id)parameters success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure; 下发任务的区块；方法附带一个获取任务的 block,我们把需要处理的任务放到里面即可，利用 GCD 派发任务，做动画等等都是这样做的，由于是单纯的任务，所以一般不需要参数： 123456789void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);[UIView animateWithDuration:0.25 animations:^&#123; //do your animates&#125;];[NSBlockOperation blockOperationWithBlock:^&#123; //your task &#125;]; 权利下放；如果做一件事情的时候，我们不知道该如何拍板，抉择的时候，就可以把这个权利下放给调用者，这样的代码就显得很灵活； 123[needSortArray sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return NSOrderedAscending;//your power!&#125;]; 封装代码块；如果你的逻辑比较复杂，需要判断很多种情况，各种 if else 嵌套；很多个 else 的地方都调用同样的代码块，则可以考虑使用 block 块；我觉得你应该也遇见过这种情况！至少我见过别人这么写过，结果就是同样的代码块几十行，在一个方法里写了两次，其实不用 block 也行的，抽取一个方法或许也行，使用 block 的好处，大概就是可以捕获了！如果代码块是一个方法，那么可能就没必要使用 block 来封装了，不过如果是好多行的逻辑，使用 block 封装下很是比较好的！ 123456789101112131415161718192021NSString* (^callback)(NSArray *needSortArray) = ^(NSArray *needSortArray)&#123; [needSortArray sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return NSOrderedAscending;//your power! &#125;]; return [needSortArray componentsJoinedByString:@\"|\"]; &#125;; BOOL A,B,C; NSArray *needArr = @[@\"A\",@\"C\",@\"D\",@\"F\",]; if (A) &#123; if (B) &#123; if (C) &#123; [self handleArr:needArr]; &#125;else&#123; callback(needArr); &#125; &#125;else&#123; [self handleArr2:needArr]; &#125; &#125;else&#123; callback(needArr); &#125; 从技术层面上看，基本上这些使用代理也可以完成，但是绝对没有使用 block 来的优雅！我是一个喜欢使用的 block 的 coder，因为觉得编写代理很麻烦，代码不是那么的直观；这里只是简单总结了下平时我经常用到的场景，当然还有别的很多场景；希望你能发邮件给我，补充这里来； Blokc 高级用法说高级用法可能会有些夸张，不过这确实不是很常用，因为常用的场景上面已经说过了，所以这里为了区分就是用了高级这个词汇！下面就来见识下我所谓的 “高级” 吧，我看问题喜欢有上下文，因此先看下场景： 1234567891011121314151617181920212223242526272829303132///添加一个下载任务- (void)addDownloadTask:(id)task handleError:(BOOL(^)(NSInteger errCode))errHandle completion:(void(^)(id task , NSInteger errCode))comBlock&#123;// 1.generate err code; NSInteger errCode = 12432;// 2.check error; if (errHandle) &#123; if(errHandle(errCode))&#123; //下放权利，调用者灵活判断后 add [self doAdd:task]; &#125; &#125;else&#123; // 默认的判断条件 3.add [self doAdd:task]; &#125;&#125;- (void)doAdd:(id)task&#123;&#125;//处理错误，可能是单独的类(QLErroHandel)；+ (BOOL)handleError:(NSInteger)errCode&#123; BOOL someCons; if(someCons)&#123; return YES; &#125; return NO;&#125; 有了上面的方法后就可以封装一个通用的自动处理错误的方法了，因为我是那么的懒，当然这也是面向切面编程的体验，面向错误处理这个切面编程，不让错误处理流落到每个添加调用处，避免日后维护的工作！ 123456789101112///封装一个通用的自动处理错误的方法- (void)addDownloadTaskAutoHandleError:(id)task NoErrorCompletion:(void(^)(id task))comBlock&#123; [self addDownloadTask:task handleError:^BOOL(NSInteger errCode) &#123; return [[QLErroHandel class]handleError:errCode]; &#125; completion:^(id task, NSInteger errCode) &#123; if (comBlock) &#123; comBlock(task); &#125; &#125;];&#125; 如果只是这些的话，看着还不错，一劳永逸，错误处理自动处理了，没错误后就添加任务！ But，有了新的需求了，要加入会员特权，可以免流量下载！并且流程和之前也有所不同了，有些情况是不能添加的！什么？这怎么办！淡定么，代码是我写怕啥！那么就在 handleError 里处理不行吗？ 不行！因为会员的判断是异步的，同时伴有 Alert 等提示！异步是最麻烦的，因为没办法直接返回 bool 值了！因此必须重构 handleError 方法，等待异步出结果，是不是能够添加任务！考虑了一阵子，决定从 block 上入手，想到的办法是传递一个权利下放的 callBackblock 到 handleError 方法；当 handleError 获取到会员信息后回调 callBackblock；如何传递呢？没有更好的办法，因此就尝试把 callBackblock 作为参数传递下去，改造后是这样的: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+ (void)asynVIP:(void(^)(bool))compBlock&#123; //异步请求VIP信息&#125;//处理错误，可能是单独的类；+ (void)handleError:(NSInteger)errCode withCallback:(void(^)(NSInteger flag))calback&#123; [self asynVIP:^(bool isVIP)&#123; //使用 callback 告诉上层 api 是不是要开始添加任务 if (calback) &#123; calback(isVIP); &#125; &#125;];&#125;///添加一个下载任务- (void)addDownloadTask:(id)task handleError:(void(^)(NSInteger errCode,void(^calback)(NSInteger flag)))errHandle completion:(void(^)(id task , NSInteger errCode))comBlock&#123;// 1.generate err code; NSInteger errCode = 12432;// 2.check error; if (errHandle) &#123; void(^calback)(NSInteger flag) = ^(NSInteger flag)&#123; if (flag) &#123;// 3.add [self doAdd:task]; &#125; &#125;; //下放权利，调用者灵活判断 errHandle(errCode,calback); &#125;&#125;///封装一个通用的自动处理错误的方法- (void)addDownloadTaskAutoHandleError:(id)task NoErrorCompletion:(void(^)(id task))comBlock&#123; [self addDownloadTask:task handleError:^(NSInteger errCode, void(^callback)(NSInteger flag)) &#123; //把 callback 传递下去，等待时机成熟，回掉回来，决定任务是不是添加 [[QLErroHandel class] handleError:errCode withCallback:callback]; &#125; completion:^(id task, NSInteger errCode) &#123; if (comBlock) &#123; comBlock(task); &#125; &#125;];&#125; 这样 VIP 的需求就搞定啦，总结下就是： block 的参数可以是 block；这个可以作为 B 调用 A 的时候，B 在适当的时机回掉给 A 一些信息，而不是 B 仅仅从听从 A 安排的时间被调用！相当于握手，相互传递了信息，而不是单方向被动调用，这就相当于 A 在某个时候让 B 做一些任务，B 完成了任务之后根据完成的情况拿着 A 传给他的callback 回掉到 A 决定 A的下一步任务！这个也许需要你静静的思考品位几分钟… 再回过头来看看之前的权利下放方式：通过返回值去决定 A 的下一步任务，这个在 B 没有异步任务的情况下很实用，不过 B 有了异步任务后就不行了，特别是 B 的任务又是通过 block 派发的情形，就更不适合这个返回值模式了！ 时间比较仓促，写的不对的地方或者疑惑之处可以评论等其他方式联系我…","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"UITableViewCell 编辑模式","slug":"2015/10/26-UITableViewCell-Edit","date":"2015-10-26T13:57:49.000Z","updated":"2018-03-27T14:45:15.685Z","comments":true,"path":"2015/10/26/2015/10/26-UITableViewCell-Edit.html","link":"","permalink":"http://debugly.cn/2015/10/26/2015/10/26-UITableViewCell-Edit.html","excerpt":"IntroductionUITableView 提供了很多很方便的方法以至于我们有的时候不能完全记住他的代理方法，这里说下他的编辑模式；项目里用到了编辑，在踩过一些坑之后，对 UITableView 的编辑更加的清晰了，这里简单记录下。 开启编辑模式 这个很简单了，设置 UITableView 的编辑属性即可，方法则提供了动画选项： 123// default is NO. setting is not animated.@property (nonatomic, getter=isEditing) BOOL editing;- (void)setEditing:(BOOL)editing animated:(BOOL)animated; 如果控制器是 UITableViewController ,那么可直接使用控制器的方法，而无需写一句代码，iOS 代码就是这么简单，系统为我们做了太多的东西了，点击 item 的方法也已经绑定好了！ 1self.navigationItem.leftBarButtonItem = self.editButtonItem; editButtonItem 是控制器的属性；你可以重写这个方法，处理一些必要的操作，不过千万要记得调用 super 哦！ 123456789@interface UIViewController (UIViewControllerEditing)@property(nonatomic,getter=isEditing) BOOL editing;// Updates the appearance of the Edit|Done button item as necessary. Clients who override it must call super first.- (void)setEditing:(BOOL)editing animated:(BOOL)animated;// Return an Edit|Done button that can be used as a navigation item's custom view. Default action toggles the editing state with animation.- (UIBarButtonItem *)editButtonItem;@end","text":"IntroductionUITableView 提供了很多很方便的方法以至于我们有的时候不能完全记住他的代理方法，这里说下他的编辑模式；项目里用到了编辑，在踩过一些坑之后，对 UITableView 的编辑更加的清晰了，这里简单记录下。 开启编辑模式 这个很简单了，设置 UITableView 的编辑属性即可，方法则提供了动画选项： 123// default is NO. setting is not animated.@property (nonatomic, getter=isEditing) BOOL editing;- (void)setEditing:(BOOL)editing animated:(BOOL)animated; 如果控制器是 UITableViewController ,那么可直接使用控制器的方法，而无需写一句代码，iOS 代码就是这么简单，系统为我们做了太多的东西了，点击 item 的方法也已经绑定好了！ 1self.navigationItem.leftBarButtonItem = self.editButtonItem; editButtonItem 是控制器的属性；你可以重写这个方法，处理一些必要的操作，不过千万要记得调用 super 哦！ 123456789@interface UIViewController (UIViewControllerEditing)@property(nonatomic,getter=isEditing) BOOL editing;// Updates the appearance of the Edit|Done button item as necessary. Clients who override it must call super first.- (void)setEditing:(BOOL)editing animated:(BOOL)animated;// Return an Edit|Done button that can be used as a navigation item's custom view. Default action toggles the editing state with animation.- (UIBarButtonItem *)editButtonItem;@end 这是我 Demo 里重写的,目的是切换编辑效果的，每次点击都会不一样，循环往复的： 1234567891011- (void)setEditing:(BOOL)editing animated:(BOOL)animated&#123; if (editing) &#123; self.editingStyle = self.editingStyle + 1; if (UITableViewCellEditingStyleInsert &lt; self.editingStyle) &#123; self.editingStyle = UITableViewCellEditingStyleNone; &#125; &#125; [self.tableView reloadData]; [super setEditing:editing animated:animated];&#125; 设置编辑样式 系统提供了3中编辑样式，分别是： 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone, UITableViewCellEditingStyleDelete, UITableViewCellEditingStyleInsert&#125;; UITableViewCellEditingStyleDelete 对应的效果是: UITableViewCellEditingStyleInsert 对应的效果是: UITableViewCellEditingStyleNone 对应的效果是: 前两个都比较熟悉了，对于最后这个有些同学可能不是很熟悉了，这个是系统为我们提供的空白的，所以我们就利用这个进行自定义； 自定义编辑样式 自定义编辑样式的思路是：选择的系统样式 UITableViewCellEditingStyleNone，然后自己添加视图，做动画；实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)setEditing:(BOOL)editing animated:(BOOL)animated&#123; if (self.isEditing == editing) return; if (UITableViewCellEditingStyleNone == self.editingStyle) &#123; if (editing) &#123; UIControl *view = [[UIControl alloc]initWithFrame:CGRectMake(-20,(self.bounds.size.height -20)/2.0, 20, 20)]; view.backgroundColor = [UIColor redColor]; [view addTarget:self action:@selector(tipedEditView) forControlEvents:UIControlEventTouchUpInside]; view.tag = 23456; [self addSubview:view]; CGRect destRect = view.frame; destRect.origin.x = 15; if (animated) &#123; [UIView animateWithDuration:0.25 animations:^&#123; view.frame = destRect; &#125;]; &#125;else&#123; view.frame = destRect; &#125; &#125;else&#123; UIView *view = [self viewWithTag:23456]; CGRect destRect = view.frame; destRect.origin.x = -20; if (animated) &#123; [UIView animateWithDuration:0.25 animations:^&#123; view.frame = destRect; &#125;completion:^(BOOL finished) &#123; [view removeFromSuperview]; &#125;]; &#125;else&#123; view.frame = destRect; [view removeFromSuperview]; &#125; &#125; &#125; [super setEditing:editing animated:animated];&#125;- (void)tipedEditView&#123;// 回掉到tableview的dasource去； id&lt;UITableViewDataSource&gt;delete = self.ownerTable.dataSource; NSIndexPath *idx = [self.ownerTable indexPathForCell:self]; [delete tableView:self.ownerTable commitEditingStyle:UITableViewCellEditingStyleNone forRowAtIndexPath:idx];&#125; datasource 处理： 12345// 自定义删除； [self.objects removeObjectAtIndex:indexPath.row]; [tableView beginUpdates]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationRight]; [tableView endUpdates]; 最终的效果是： 通过验证发现，编辑动画，系统也是在 setEditing 方法里处理的；如果直接返回的话可以看到向右滑动的效果就没有了； 1234- (void)setEditing:(BOOL)editing animated:(BOOL)animated&#123; return;&#125; 注：这个是 不支持多选 的！ 以上编辑模式，会触发这个代理方法： 1- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath; 通过 editingStyle 区分开是哪种编辑；以上模式编辑时默认不可以选择，所以也不会触发选择的代理方法！可以通过 tableView.allowsSelectionDuringEditing = YES;允许选择！ 如何支持多选？这是有些个头疼的问题 使用系统提供的一个开关开启多选模式；在开启编辑模式前打开这个开关即可： 1self.tableView.allowsMultipleSelectionDuringEditing = YES;//默认关闭的 效果是： 如果没什么特别要求，那么这个是可以满足需求的；选中和取消分别调用下面的代理方法，回调方法和其他编辑模式不太一样： 12- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath; 注：开启这个开关后，这个代理方法不再调用1- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath 使用系统没有公开的枚举值开启: 1234- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return UITableViewCellEditingStyleDelete | UITableViewCellEditingStyleInsert;&#125; 如果想改变这个多选的圆圈，切入口还是 cell 的 - (void)setEditing:(BOOL)editing animated:(BOOL)animated；方法;做法是找到系统的图片隐藏掉，然后把自己想要的加上，做下动画就行了，具体代码暂不放出了… 这个 Demo 已经传到了github 上，多谢支持！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"RunLoop Study (一)","slug":"2015/10/15-RunLoopStudy1","date":"2015-10-15T14:17:57.000Z","updated":"2018-03-27T14:45:15.685Z","comments":true,"path":"2015/10/15/2015/10/15-RunLoopStudy1.html","link":"","permalink":"http://debugly.cn/2015/10/15/2015/10/15-RunLoopStudy1.html","excerpt":"","text":"前言很久之前就想写一下 RunLoop — iOS里一个很重要的概念；最近一直很忙，一拖再拖，提到拖延 — 有点像下面要说的定时器了，可以无节操的一直拖，无上限了！O(∩_∩)O~~ 终于轮到定时器了，尽管很累，还是要坚持 run 起来！这是 RunLoop 相关文章的第一篇，认真写，开个好头吧！ 我第一次听到的应该是消息事件循环，因为使用了autorelease,所以就想知道这个被延迟释放的对象到底什么时候会释放，被告知这个消息事件循环结束后，这个真不理解… 还有，使用了定时器，定时更新一些UI，结果在滑动scrollview的时候定时器停止了，网上搜了下，修改下runloop的mode就行了，这个也不知到为啥… 还有对一些现象的观察：我们知道depatch一个子线程之后，这个线程执行的任务完成后，就被销毁了，如果不想被销毁，而是周期性的做一些事情，那就得写个while循环或者递归了，然后在加上sleep；就能像timer周期性的循环做一件事； 反思主线程：怎么感觉主线程就是一直存活的呀，app可以随时响应我们的操作，你可以停一会，也可以持续操作，主线程和分线程怎么就不一样了呢，为什么主线程能一直存活？查看代码之后，也没有发现哪里有while循环啊，甚至于递归，此事必有蹊跷，元芳你怎么看？ 我的假设：假如系统隐式地创建了一个循环，那么主线程就能一直跑了，而不会运行之后就停止了。当初学java的时候，曾经写过一个猜大小的小游戏，程序运行后，会随机生成一个1-1000的整数，然后一直猜，如果猜的不对就输出你猜大了或者猜小了，并且继续等待输入，猜对时提示恭喜猜对了，是否继续玩游戏？编写这个小游戏，主要是用两个while循环（嵌套），外部的while循环一次，表示游戏玩了一局，内部的while循环一次，表示猜了一次；不过玩游戏的时候只能一直等待输入，线程阻塞到这了！所以我们app的主线程不可能是一个简单的while循环就能搞定的，要做到不阻塞就需要一种机制，让app有事要做的时候就干活，没事了就睡觉… NSRunLoop 的简单介绍这个类在 Foundation framework 里，十分简单，这是他的所有方法了，这个类提供了部分 runloop 的接口，可以方便的获取到她，或者添加定时器或者端口等； 12345678910111213141516171819202122232425262728293031323334//获取所在线程的 runloop+ (NSRunLoop *)currentRunLoop;//获取主线程的 runloop+ (NSRunLoop *)mainRunLoop NS_AVAILABLE(10_5, 2_0);//当前输入类型@property (nullable, readonly, copy) NSString *currentMode;//获取core foundation 对象，实现更多的功能，比如添加监听；- (CFRunLoopRef)getCFRunLoop CF_RETURNS_NOT_RETAINED;//把定时器加入到runloop- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode;- (void)addPort:(NSPort *)aPort forMode:(NSString *)mode;- (void)removePort:(NSPort *)aPort forMode:(NSString *)mode;- (nullable NSDate *)limitDateForMode:(NSString *)mode;- (void)acceptInputForMode:(NSString *)mode beforeDate:(NSDate *)limitDate;@end@interface NSRunLoop (NSRunLoopConveniences)- (void)run;- (void)runUntilDate:(NSDate *)limitDate;- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;@end@interface NSRunLoop (NSOrderedPerform)- (void)performSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg order:(NSUInteger)order modes:(NSArray&lt;NSString *&gt; *)modes;- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target;@end WARNING 1The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results. 其中 currentRunLoop ，current 指代的线程！我们可以把 runloop 当做线程的基础组件来对待；因为没有她的话，线程运行就会遇到一些问题，或者要费事些，比如有些线程可以让操作系统唤醒睡眠的线程以管理到来的事情，而 runloop 就是这些线程的基础； runloop 是一种可以在一个周期内调度任务并处理到来的事件的循环；也就是说循环是有周期的（这不是废话么），具备调度和处理事件的能力，这是了不起的； RunLoop 和线程的关系 每个线程最多只有一个 runloop，创建一个线程时，默认没有；当调用获取方法的时候懒加载创建；主线程系统默认创建了，具体何时创建的不知道，或许系统在某个时候（当然是app启动完毕之前）调用了获取方法，这样就创建好了，换句话说在 applicationDidFinishLaunching 之后你就可以访问了！ 分线程开始运行 runloop 之前，要添加输入源或者定时器，要不然 runloop 会立刻退出！ runloop 为我们提供了与线程交互的能力，视情况而定，也许根本就用不到她；最常用的可能就是牵涉到网络交互的时候，这个最好的教程当然是 matt 大神写的 AFNetWorking 啦；有兴趣的看下源码吧，日后有时间我也会分享下阅读第三方框架的心得； runloop 的作用在于当有事情（事情来自于下文的输入源，与 Mode 也有关系）要做的时侯他就去唤醒当前的线程开始工作，没事情可做就让线程去休眠； RunLoop 的输入源runloop 从输入源和定时器这两类源中接收事件；输入源(通常是基于端口或者自定义的)会异步向应用发送事件，主要差别在于内核会自动发出基于端口的源信号，而自定义源就需要从不同的线程中手动发出。可以通过实现与 CFRunLoopSourceRef 相关的几个回调函数来创建自定义输入源。 定时器，这个是 iOS 开发中经常用到的；你对他了解多少？定时器是基于时间的通知，他为线程提供了一种可以在未来某个时间执行某个任务的机制；他是同步发出的，并且与特定的 mode （就是把定时器添加进 runloop 的那个 mode）有关，如果没有监控特定的 mode ，那么事件就会被会略掉，当然线程也不会收到通知的，直到 runloop 运行在相应的 mode 下为止； 定时器的触发有必要解释下，我们可能知道定时器的定时间隔不是那么严格的，也就说可能会有偏差！定时器调度是基于设定的开始时间的而不是实际触发时间的！这句话可能不好理解，慢慢讲给你听吧，如果到达定时器触发时间之前有别的任务没有完成，那么就会向后拖延定时器的触发时间，如果一直拖延，加入0.5s应当执行的，拖延到了1.1s的时候可以执行了，那么上次的那个就被忽略了，如果是刷新 UI，那么效果上就是卡顿下；紧接着下一次循环触发时间不是 1.1s + 0.5s， 而是0.5s *3 = 1.5s;这下明白了吧，是基于你设定开始的那个时间的，如果中间拖延了，就会被忽略过去！并且这个延迟是没有上限的！ 注：使用定时器是否需要手动添加到 runloop 取决于创建的方式，通过阅读 NSTimer Class Reference 得到的结论： 1.使用 initWithFireDate 或者 timerWithTimeInterval 这些方式创建的定时器必须手动加入到runloop ； 2.使用 scheduledTimerWithTimeInterval 创建的则是默认加入到当前runloop的； 也可以为 runloop 添加监听者，可以在 runloop 执行过程中的某个时候收到回掉，比如进入或者退出、睡眠、唤醒、处理输入源或者定时器之前等；这个就需要使用 core Fundation 里的 api 了（CFRunLoopObserverRef 等）；Fundation 提供的 api 是对 core Fundation 的封装，因此你也能找到添加定时器和 source 的方法: CFRunLoopAddTimer / CFRunLoopAddSource ; 总的来说就是：如果你有事情想让 runloop 为你管理线程去完成，那么你选取一种输入源添加进 runloop，runloop就回去监测这些输入源有没有事情要做； RunLoop 和 Mode mode 有几种？阅读过 NSRunLoop Class Reference 文档之后见到了两种，NSDefaultRunLoopMode，NSRunLoopCommonModes; 其实不止两种呢，在别的地方也能找到：UIApplication Class Reference 123456789101112131415Run Loop Mode for TrackingMode while tracking in controls is taking place.DeclarationSWIFTlet UITrackingRunLoopMode: StringOBJECTIVE-CUIKIT_EXTERN NSString *UITrackingRunLoopMode;ConstantsUITrackingRunLoopModeThe mode set while tracking in controls takes place. You can use this mode to add timers that fire during tracking.Available in iOS 2.0 and later. 这种模式发生在 tracking 时，现在学习的 UIKit 中的控件貌似只有 scrollview 有tracking； mode 有什么用途？我们通过阅读上文已经知道了，runloop 可以调度线程去完成我们要做的事情，先看两个场景吧： 1.微信客户端中的聊天界面而言，当滑动聊天页面的时候，你发的动画就会暂停，手松开后就会动起来，这样做的好处就是使得滑动列表更加流畅； 2.还有一些相反的场景，就是在滑动列表的时候我们也想让我们的倒计时在一直跑秒而不是停下来； 这些都是可以通过 mode 来配置的，在不同的场景下 runloop 运行在不同的 mode 下；可以因此添加 timer ，port 时都要指定 这个源的 mode；这样 runloop 才能知道当前所处的 mode 是不是要处理输入源的事情！相当于对输入源分组，这个分组比较特殊，输入源可以同时属于不同的 mode；比如场景1设置为 DefaultRunLoopMode 就行了；对于场景2设置为DefaultRunLoopMode还不行，这会导致在滑动列表的时候停止更新UI，因为 滑动的时候 runloop 处于 UITrackingRunLoopMode ，不同于 DefaultRunLoopMode！因此到了定时器触发的时间了，却没有调用 target 的方法，所以要把 定时器加入到 UITrackingRunLoopMode 才行，这样滑动的时候也能触发定时器了！ 说了半天还未提及 NSRunLoopCommonModes 这个 mode ；有人把她称之为伪模式，因为他代表了所以模式，可以说不是一种真正的模式！这些模式名称都是字符串，如果你对于 mode 不理解的话，你大可把他们都当做 枚举 而 commonModes = (default + uitacking + other…);并且每个 mode 都映射一个数组，数组里放的是添加的输入源，当然可以把输入源放到多个数组里啦；这样 runloop 运行在不同的 mode 下时就去找不同的数组，去完成任务，相信我这样通俗的说你会明白的！ 这是 RunLoop 学习的第一篇博客，随着我学习的加深也会继续分享，我本人也很期待自己能耐心写作，毕竟写作的过程是枯燥的😢O(∩_∩)O~~","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"ImageOptim – 无损图片压缩工具","slug":"2015/09/27-bo-ke-ti-su-shi-yong-imageiptimya-suo-tu-pian","date":"2015-09-27T00:50:27.000Z","updated":"2018-03-27T14:45:15.684Z","comments":true,"path":"2015/09/27/2015/09/27-bo-ke-ti-su-shi-yong-imageiptimya-suo-tu-pian.html","link":"","permalink":"http://debugly.cn/2015/09/27/2015/09/27-bo-ke-ti-su-shi-yong-imageiptimya-suo-tu-pian.html","excerpt":"","text":"背景昨天发布的博客 港版苹果充电器DIY全过程 里使用了太多的图片，看了下好几十兆大，这怎么能行呢，作死的节奏啊！所以找了一款 mac 无损图片压缩工具 – ImageOptim ，压缩比特别高，支持 PNG/JPEG/GIF 等主流格式，并且是免费的！ 可以直接拖入文件夹批量处理，也可以直接拖入图片，默认自动开始处理；亲身感受如下, 这是我昨天博客的图片： 技巧：这里可以调节压缩比，默认的压缩比小些，博客图片质量不用很高，可以压缩定得更小些： 这是今天的截图，先压缩吧： 完有了这个工具就可以大大减小图片的体积了，并且是无损的，图片质量不受影响！ 开源地址：https://github.com/pornel/ImageOptim 软件下载地址：https://imageoptim.com","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://debugly.cn/tags/macOS/"}]},{"title":"港版苹果充电器 DIY 全过程","slug":"2015/09/26-gang-ban-ping-guo-chong-dian-qi-diyquan-guo-cheng","date":"2015-09-26T15:58:32.000Z","updated":"2018-03-27T14:45:15.684Z","comments":true,"path":"2015/09/26/2015/09/26-gang-ban-ping-guo-chong-dian-qi-diyquan-guo-cheng.html","link":"","permalink":"http://debugly.cn/2015/09/26/2015/09/26-gang-ban-ping-guo-chong-dian-qi-diyquan-guo-cheng.html","excerpt":"","text":"中秋节到了，先说声：“中秋接快乐” ！昨天晚上手机没电了，怎么办？这还用问！？脑瘫么？哦，不是啦；木有充电器啊，那就用电脑充吧，土豪么，吊！之前是用我的pro充，这次用公司发的电脑吧，两年不用忘记了windows睡眠了，结果第二天手机还是不到百分之三十的电量！这就是没有充电器的不便啊！我有港版的充电器啊，可是大陆的插排不能用啊，我有个插排，可以插上，可是不通电啊，仔细观察了下是因为港版的只有金属头是导电的，这个待会看图就明白啦！作为一个geek当然不甘寂寞！ 注意事项：需要给电容放电，虽然电容存储的电量不多，但是电压不低呢，我亲身感受过，你会被电的跳起来。。。 放电方法很简单，用改锥短路电容两极就行啦，如果你看到了火花，那就说明电容里确实存了电！最后一张图就是印证哦，电容存储的电供LED亮了15s呢！ （有史以来图片最多的一次了，一共41张，wifi下浏览吧,土豪就当我没说吧…） 还没开始动工呢,已经被我深深地伤害了呀….. 再看看吧： 先把这层模揭掉： 接着就用我为数不多的工具开始割肉啦，埋头苦干了好一会，没啥反应啊！这苹果的充电器没螺丝，都是胶粘好的，用刀子划不开啊！怎么办，记得上次查过融化公交卡的办法，有种化学药剂天那水就可以，网上开始查，发现这货好像没用，因为苹果的充电器不是普通的胶水粘的！这尼玛是什么玩意呢？一个术语出来了—超声热和；高大上的技术啊；苹果做工就是好，我这租房这里家伙不全，简单的砟了几下没卵用！网上有人说房冰箱里冻下，好吧，扔冰箱里试试，下午了拿出来，确实有点凉，没锤子，尼玛看见啥用啥，大学时候的硬盘（里面有什么你懂的）拿来用吧，结果试了几下，还是没卵用。。。 睡了一会觉。。。 这是肯定没完啊，想当年在老家时，熬过多少个夜晚，只为我那组装的音响，往事不堪回首啦，一晃几年了！这是你逼我的，用我的电烙铁吧！我查，好使，那就继续吧，没一小会，我就把周围给全部踏平了，然后拿掉了这个盖子，识得庐山真面目： 哈哈，这货是不是面目全非了： 不忍心看了： 接下来就是把电路板取出来了： 还有工作要做，因为边缘需要处理，有的地方烙进去了 不过问题不大，不严重，也不多：其实这材料挺硬的，需要小心，不要划到手，也不要划到电路板了 哈哈，拿出来了： 好好瞅瞅这家伙： 这里是伤到的地方： 这点小伤没啥的： 看看背面吧： 这是电源插头连接处，可以看出苹果也就是做个摆设啊，这地线根本就没连线！ 这货是出来了，我去哪里找个何时的外壳呢？卸开一个别的充电器看能不能放下吧，你看这电路板多简单呀，你就看中间这道黄线把，左边是220V的电源，一个整流桥，经过这个黄色的电感，得到低压，整流滤波，加个小灯完事，这比苹果的简单太多了，苹果的电路板上的东西我都看懂是啥，所以一个原装的充电器就是贵，今天就看到了，这是有原因滴！港版的是三角形的啊，放不进去： 那就自己做个壳吧，就地取材，没办法，身在外不由己；上星期买的鼠标，纸壳子还在呢，感觉够硬，拿来用吧，大致比划了下，还行吧： 给他留个盖子： 感觉只有前盖没后盖不得劲啊，算了，画图纸，再来一个： 我从小就喜欢看LED，记得第一次捡到一个绿色的led，用两节5号干电池点亮了一夜，陪着我入睡，陪着我醒来，那感觉很不错呢，所以我得装个指示灯！先看有地方没，刚好母插头旁边有地方，需要先取下她的铠甲才行呢： 不得不再说一次，苹果做的就是精细，一个插头，也给她做个小外壳，这设计的真好，不忍心干掉他了都： 去掉铠甲后，留下一条缝： 这是前面，这条缝刚好可以用来穿过led的导线： 这个LED小灯肯定是有着落啦，先找导线接通电源吧，这里我想灵活些，我可不想让她拖着长长的导线，所以又找来了废弃的光猫，上面有个插孔，刚好拿来用吧，就是这个黑色的啦： 后面的为什么有一堆烟盒呢？烟瘾这么大！？什么啊，哥不抽烟好久了…这是大学时买的，刚才找LED分压电阻时拿出来的，看看里面有啥吧（认识么？）： 620欧姆的电阻： 有电烙铁就好办事，取下来，焊接下，通电试试，这是物理老师教的哦，你忘了没？不要什么都做好了才通电，结果发现电路板已经挂了，那不就白费了嘛： 我擦类，什么情况，怎么我的手机没有显示充电啊！我晕，尼玛的，老子很小心了啊，不可能啊，怀疑是光猫插头的事，立马查看电路板，看到了吗，那两个是连着的，再看我的电路，不一样，凭借经验断定我接的那个不是导电的，而是起固定作用的，莫慌，让我调换下导线，记得拔掉电源啊!!! 然后开始接LED吧，测试了下正负极之后就确定了，LED的具体位置了，开搞吧，红色的太普遍啦咱不用，黄色的做指示灯的不多吧，白色是照明才用的，7彩色的我也没了，那就蓝色的吧，看放这里还行吧，也别无他选了呀： 图纸早就剪好了，开始包装吧，是不是很丑啊： 后面包好了，包前面吧，这里需要留孔，可是纸壳子不好搞，最终把留下的前盖给剪掉了，这算是个败笔啦，图纸是白画了！ 看到小灯了吗？ 好了，盖子都粘好了，通电吧： 配备的是1k的电阻，高亮度的LED，是不是很亮了！ 看下后面吧，这个插头，可以拔下，剩下的就是个火柴盒那么大了： 插上线试试充电吧： 完工啦，来个华丽的转身： 看看我这凌乱的工作台吧： 哇，好乱啊！ ಥ_ಥ，电源拔了还能亮15s左右呢！电容在放电啦,不稀奇… Done不管别人怎么看，反正我是很享受这个过程啦，这是我的一个兴趣爱好而已！很遗憾没有学习物理电学，所以我也是个小白啦，仅仅知道一点电路罢了，让你们见笑了，O(∩_∩)O~~ 这是别人拆绿点的过程 国外大神拆解苹果绿的充电器+深入解读其设计+绿点的由来 2015 中秋快乐！","categories":[],"tags":[{"name":"生活中的欢乐","slug":"生活中的欢乐","permalink":"http://debugly.cn/tags/生活中的欢乐/"}]},{"title":"ViewController 子控制器 view 的大小问题","slug":"2015/09/05-viewcontroller-tian-jia-zi-kong-zhi-qi-shi","date":"2015-09-05T15:00:07.000Z","updated":"2018-03-27T14:45:15.684Z","comments":true,"path":"2015/09/05/2015/09/05-viewcontroller-tian-jia-zi-kong-zhi-qi-shi.html","link":"","permalink":"http://debugly.cn/2015/09/05/2015/09/05-viewcontroller-tian-jia-zi-kong-zhi-qi-shi.html","excerpt":"","text":"ViewContrller 管理的 view 的大小是如何确定的？ 不同的系统版本 View 的大小一样吗？ 用 ViewContrller 管理的 view 的大小如何优雅的控制？ 这些问题是我在写项目的时候遇到的，比较有感受；我写的是一个只支持横屏的 iPad 项目，view 比较多，因此按区域划分为好几个控制器分别管理，为了确保使用期间对象的安全存在，所以要把控制器保留住，如果不保留控制器，MRC 就会内存泄露，ARC下控制器就会释放，剩下他的 view 孤军奋战，这肯定不是你想要的结果，所以常规做法是保留控制器，然后把view添加上去，改变frame；这也可能是你现在正在使用的方法吧？！这里隐含了一个条件，在这个控制器里添加子控件的时候，是按一定的大小来写的，比如，A 控制器是一个详情展示，view 大小是(500,768),那么子视图的参考平面就是{(0,0),(500,768)}了,当然也可以超出边界，但这不是讨论的范围。 这种方法有什么问题？其实这种方法可以，不过我在写某个模块时遇到了这样一个情形： 图 1 点击标签显示为图2 图 2 先看第一张图，很简单的九宫格布局；点击标签会出来一个浮层，样式大致是一样的，就是少了一个标签而已，所以立马想到的应该是重用了！（我可不想写两套布局）先别写哦，想下改怎么写？ 按照引言部分的分析，大小已经确定了，不能重用！对于一个固执的人，没办法，就是要重用！因此考虑下怎么把这个 view 的大小变得可操控，然后子视图参考父视图而自动改变不就行了！ 查看view创建时的大小吧，因为这个很关键，子视图要参考的： 12在 viewDidLoad 里打印时，不论你模拟器的是什么方向，它默认总是竖屏(Portrait) size，也就是说在横屏模式下 width 和 height 是相反的，不是你想要的；本来猜测着vc的view的宽高会跟window的有关，通过测试把window 的宽高翻转也不行，反而会带来别的问题！经过测试，在viewDidAppear时，已经修改好了，变成横屏的大小了！又测试了下系统版本，发现：!!!iOS 8 已经没这个问题了，也就是说iOS 8 之后view的大小就是你的屏幕大小，而且与方向对应，比如横屏就是(1024,768)； 问题来了，我们布局子视图的代码都写在 viewDidLoad 里，当我们在外部修改 view 的大小时 viewDidLoad 已经调用过了，因此这个外部指定的大小对于子视图来说然并卵啊！参照个毛线啊！有没有一举两得的办法，外部可以指定 子控制器 view 的大小，并且子控制器 viewDidLoad 里可以获取到指定的大小，而不是没有卵用的屏幕大小？ 由果索因 — view 从哪里来？ 当控制器的 view 被访问时就会调用 loadView 方法创建，然后紧接着调用 viewDidLoad ， 我们创建添加子视图的代码一般也都写在这里面，因此如果 loadView 的时候 size 能正确的指定， 我们就可以在 viewDidLoad 参照 view 的大小，布局子视图了！先打印看看结果吧， 结果和 viewDidLoad 里打印的一样；所以可以从这里下手， 在 loadVeiw 的时候指定一个 view 的 size， 那么不可避免的就要加一个属性 viewSize 了！然后处理： 123456789101112131415161718192021222324252627 - (instancetype)initWithViewSize:(CGSize)aSize&#123; self = [super init]; if (self) &#123; self.viewSize = aSize; &#125; return self;&#125;- (void)loadView&#123; [super loadView];// 这里用了frame；用bound可能会导致origin不是0,0;导致 view 在其父视图上的位置有偏移； CGRect rect = self.view.frame; rect.size = self.viewSize; self.view.frame = rect;&#125;- (void)setViewSize:(CGSize)viewSize&#123; _viewSize = viewSize; if (self.isViewLoaded) &#123; CGRect rect = self.view.frame; rect.size = self.viewSize; self.view.frame = rect; &#125;&#125; 有了上面的处理我们就可以在 viewDidLoad 以 view 的大小为参照布局子视图了！只需在外部调用的时候赋值就行了，不过需要注意，最好在外部使用到 view 之前给 viewSize 赋值，尽管已经实现了 setViewSize 方法！ 12345678910111213141516171819202122232425// 这个 fetch 方法是根据索因找出对应控制器的，如果是刚创建的就需要添加为子控制器- (UIViewController *)fetchAControllerwidthIndex:(NSUInteger)idx&#123; if (idx &gt;= self.btnArr.count) &#123; return nil; &#125; BLBaseViewController *vc = self.controllers[idx]; if ([vc isKindOfClass:[UIViewController class]]) &#123; return vc; &#125;else&#123; //!!!创建控制器 vc = (BLBaseViewController *)[self createViewControllerwidthIndex:idx]; if (vc) &#123; //!!! 访问 view 属性之前指定 view 的大小 vc.viewSize = _contentView.bounds.size; //!!! 添加控制器和 view [self addChildViewController:vc]; [self.contentView addSubview:vc.view]; //!!! 这个显然就没什么用了；vc.view.frame = _contentView.bounds; [self.controllers replaceObjectAtIndex:idx withObject:vc]; &#125; return vc; &#125;&#125; 这样一来我就可以参考父视图写我的子控制器了，由于页面几乎一样，所以抽取了父类，页面布局都是在父类完成的，逻辑统一处理，两个子类就剩下寥寥数行而已！ 加了一个属性，使用方法一样，还是在外部指定大小，最重要的是内部可以参考了！这达到了我预期的要求了！经过在项目中的使用，感觉比较理想！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"ACM-过河问题","slug":"2015/08/12-acm-guo-he-wen-ti","date":"2015-08-12T05:40:04.000Z","updated":"2018-03-27T14:45:15.683Z","comments":true,"path":"2015/08/12/2015/08/12-acm-guo-he-wen-ti.html","link":"","permalink":"http://debugly.cn/2015/08/12/2015/08/12-acm-guo-he-wen-ti.html","excerpt":"","text":"在我的一个群里，小伙伴发了一道题，考察下算法，自己试着想了想，拿出来一起看下吧，下面是题目： 在漆黑的夜里，N 位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。不幸的是，N 个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。如果各自单独过桥的话，N 人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间。问题是，如何设计一个方案，让这 N 人尽快过桥。（ ACM 难度系数 ：5） 分析问题面对毫无头绪的问题只能慢慢分析喽，首先把 N 个人需要的时间放到一个数组 T[n] 里面吧，时间的长短是不定的，因此先排为升序；既然是 N 个人，那就从 N = 1开始分析，找找规律吧： 1234N ＝ 1； 当然需要花费 T[0] 喽（数组下标从 0 开始）；N ＝ 2； 需要花费 T[0] ＋ T[1]，也就是两个人一起过去；N ＝ 3； 需要花费 T[0] ＋ T[1] ＋ T[2]; 很容易想到的是让最快那个人去送最慢的那个花费了 T[2]；他返回来花费了 T[0]，然后最快的这个和剩下的这个速度不是很快的一起过去花费了 T[1]；N ＝ 4； 这个怎么过？陷入沉思之中... 这道题目的说白了就是送人，时间由最慢的那个人决定，而且送完一个，还要返回来接着送，所以我们不可能让一个走的慢的人来充当这个‘摆渡’的，既然如此，那么我们就从走的慢的人下手吧，因为他不能充当‘摆渡’的，那么他早晚都要‘坐船’走呀，所以 N ＝ 4 就转化为花最少的时间送走‘坐船’的；（为了简化描述，按照时间升序的顺序将4人命名为a,b,c,d）下面分析下： 根据 N = 3 的经验，我们很容易想到让 a 去送每一个人，送完一个就返回，接着送最慢的，如此3次； 可是还有一种送法，a 送 b,a 回来；c 送 d，b 回来；a 送 b，也可以，而且时间不一定哪个短，因此要比较下哪个短； 4个人不可能就这两种送法啊，还有别的，不过时间都要比这两个长； 当 N &gt; 4 呢？其实根据 N = 4 的情况来看，这就是一个如何先送走最慢的的2个人的问题，因此 N &gt; 4 的时候，先不考虑中间的，把最快的，次快的，最慢的，此慢的拿出来摆渡，然后问题就变成了 N - 2 的问题了！当然可以写个递归了！ 下面是主要代码123456789101112131415161718int sumTimeNeed = 0;while (size &gt; 3) &#123; int time1 = a[1] + a[0] + a[size-1] + a[1] ; int time2 = a[size-1] + a[0] + a[size-2] + a[0]; size -= 2; sumTimeNeed += MIN(time1, time2);&#125;if (size == 3) &#123; sumTimeNeed += a[0] + a[1] + a[2];&#125;else if (size == 2)&#123; sumTimeNeed += a[1];&#125;else if (size == 1)&#123; sumTimeNeed += a[0];&#125;return sumTimeNeed; 欢迎去我的 GitHub 建议 NYOJ_47 ac了很多 蓝飞技术部落格 1.最古老的过河问题 一个农民携带一只狼，一只羊和一棵白菜，要借助一条小船过河。小船上除了农民只能再带狼、羊、白菜中的一样。而农民不在时，狼会吃羊，羊会吃白菜。农民最少需要几趟才能安全过河呢？ 2.人鬼殊途 三个鬼与三个人都要过河。河中只有一条小船，可容两人(鬼)。而且无论在船上或在岸上，每边的鬼数量如果多于人,鬼就会把人吃掉。最少需要几趟才能安全过河 3.道士与和尚 四个道士与四个和尚四个老道士与四个和尚分别在一条河的两岸，都要到河的对岸去。河中只有一条小船，可容两人。只有一个道士和一个和尚会划船。而且无论在船上或在岸上，道士的数量都不能超过和尚的数量。最少需要几趟才能安全过河 4.夫妻过河 两对夫妻两对夫妻要过河，河中只有一条小船，可容两人。两个丈夫都不愿让自己的妻子和另一个男人在一起，除非自己也在场。最少需要几趟才能安全过河？ 5.一家人及警察与犯人 现有一条河，共有八个人要过河，分别是爸爸，妈妈，两个儿子，两个女儿，一个警察，一个犯人．现有一条木伐，一次最多载两个人，在这八个人中，有妈妈，爸爸，警察会开船，即这个船上必须有爸爸，妈妈，警察三个中的一个，船才会开动．船过去无法自动回来．并且要避免以下三件事发生，１，警察不在犯人会伤害一家六口．２，爸爸不在，妈妈会伤害儿子．３，妈妈不在，爸爸会伤害女儿．最少需要几趟才能安全过河 6.虎毒不食子 三只大老虎A、B、C和各自的小老虎a.b.c；其中只有A、B、C和a会划船；如果小老虎不和自己的母亲在一起就会被其他大老虎吃掉；只有一条船；船上可以坐一只大老虎和任意的小老虎；问：最少需要几趟才能安全过河 7.八仙过海 铁拐李 、汉钟离 、 张果老 、蓝采和 、 何仙姑 、 吕洞宾 、 韩湘子 、 曹国舅一同过海。小船只能容下三人，而且只有道铁拐李 、汉钟离、韩湘子会划船。如果韩湘子不在，曹国舅会攻击所有人；如果铁拐李不在，汉钟离会攻击张果老和蓝采和；如果汉钟离不在，铁拐李会攻击何仙姑 、 吕洞宾。请问最少需要几趟才能安全过海？ 有兴趣的快去 AC 吧！","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://debugly.cn/tags/Other/"}]},{"title":"无限循环轮播图","slug":"2015/07/30-wo-xie-de-lun-bo-tu","date":"2015-07-30T03:09:45.000Z","updated":"2018-03-27T14:45:15.683Z","comments":true,"path":"2015/07/30/2015/07/30-wo-xie-de-lun-bo-tu.html","link":"","permalink":"http://debugly.cn/2015/07/30/2015/07/30-wo-xie-de-lun-bo-tu.html","excerpt":"","text":"我们的 App 要展示广告，形式为几张循环滚动的图片，俗称 Banner，这里我称之为轮播图。 我写了两个版本一个 EY 版和一个 EZ 版，区别是实现方式的不同：EY 使用 ScrollerView，最多会有 3 个子 view ，EZ 使用 CollectionView，她有重用机制，所以最多会有 2 个子 view；轮播的触发使用了定时器，这个已经解决了循环引用问题，直接使用了，不清楚的可以移步 这里 ！下面分别介绍下： EY 实现思路在 ScrollView 上添加 3 张 ImageView 展示图片，为了节省内存，所以最多创建 3 张就行了(其实 2 张也是可以的，这个后续继续优化，版本且定为 EYS ，哈哈她是 EY 的加强版)！ 比如现在有6张（［1,2,3,4,5,6］）图片需要显示，那么首先我会配置出来需要显示的图片索引，放在一个数组里［6，1，2］当作数据源，然后调整偏移量让 ScrollView 滚动到中间，那么看到的就是第一张了，此时向右滑动看到最后一张，向左滑动看到第二张；如下流程： * ScrollView 滚动到中间显示［1］，数据源里为［6，1，2］，刷新视图，此时可以滑动 * 向右滑动显示［6］之后就重新配置为［5，6，1］,然后刷新视图让 ScrollView 滚动到中间 * 向左滑动显示［2］之后就重新配置为［1，2，3］,然后刷新视图让 ScrollView 滚动到中间 同时还需要处理一张图片的情况，如果就 1 张，那么不可滑动，数据源为［1］； 可以看出，中间那一张是当前看到的，他的左右两侧会放上合适的图片，这样滑动的时候就感觉像是一直在循环♻️一样了； 先看使用方法吧123456789101112EYCarouseImageView *carouseY = [[EYCarouseImageView alloc]initWithFrame:CGRectMake(0, 20, self.view.bounds.size.width, 240) animationDuration:3];[carouseY resetEasyURLArr:@[@\"http://pic.nipic.com/2007-11-09/2007119122519868_2.jpg\", @\"http://pic26.nipic.com/20121223/9252150_195341264315_2.jpg\", @\"http://b.hiphotos.baidu.com/album/pic/item/cb8065380cd79123c6f9b8dead345982b2b7807a.jpg?psign=c6f9b8dead345982b2b7d0a20cf431adcaef76094b36a442\", @\"http://pic.nipic.com/2007-11-09/2007119121849495_2.jpg\"]];[self.view addSubview:carouseY];[carouseY didClickedEYCarouseImageView:^(NSUInteger idx) &#123; NSLog(@\"----%lu\",(unsigned long)idx);&#125;]; 内部实现 配置下 ScrollView,添加手势处理点击；注册内存警告⚠的通知； 处理控制轮播的属性: autoScrollTimeInterval,allowAutoScroll; 配置定时器: 12345678//一个时间间隔后开始轮播- (void)resumeAutoScroll//销毁定时器- (void)invalidateTimer//重置timer；- (void)resetTimer//定时器触发的自动轮播；- (void)autoScrollLoop 准备数据源 12345678910111213141516171819202122232425//获取下一个可用的索引- (NSInteger)getValidNextPageIndexWithPageIndex:(NSInteger)currentPageIndex &#123; if(currentPageIndex == -1) &#123; return self.totalCount - 1; &#125; else if (currentPageIndex == self.totalCount) &#123; return 0; &#125; else &#123; return currentPageIndex; &#125;&#125;//准备当前需要显示的索引数组；- (NSArray *)prepareNeedShowPageIdxArr&#123; NSArray *idxArr = nil; if (_urlArr.count == 1) &#123; idxArr = @[@(0)]; &#125;else&#123; NSInteger prevPageIndex = [self getValidNextPageIndexWithPageIndex:self.currentIdx - 1]; NSInteger nestPageIndex = [self getValidNextPageIndexWithPageIndex:self.currentIdx + 1]; idxArr = @[@(prevPageIndex),@(self.currentIdx),@(nestPageIndex)]; &#125; return idxArr;&#125; 刷新的视图的时候需要更新图片 1234567891011121314151617181920212223242526- (void)updateImage4URLIdx:(NSUInteger)uidx&#123; NSNumber *idxNum = [self.showURLIdxMap objectForKey:[self getMapKey:uidx]]; if (idxNum) &#123; NSUInteger idx = [idxNum integerValue]; UIImageView *imgView = self.contentViewArr[idx]; NSString *url = self.urlArr[uidx]; UIImage *img = [[SDImageCache sharedImageCache]imageFromMemoryCacheForKey:url]; if (img) &#123; imgView.image = img; &#125;else&#123; imgView.image = self.placeHolderImage; // 内存里没有，就查本地； __weak __typeof(self)weakSelf = self; [[SDImageCache sharedImageCache]queryDiskCacheForKey:url done:^(UIImage *image, SDImageCacheType cacheType) &#123; // 查到了就放内存，刷新下view； __strong __typeof(weakSelf)strongSelf = weakSelf; if (image &amp;&amp; strongSelf) &#123; [strongSelf updateImage4URLIdx:uidx]; &#125; &#125;]; &#125; &#125;&#125; 重写数据源处理必要的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)setUrlArr:(NSArray *)urlArr&#123; // copy个新的，防止外部改变了，影响了轮播图 _urlArr = [urlArr copy]; self.totalCount = _urlArr.count; self.currentIdx = 0; self.scrollEnabled = self.totalCount &gt; 1;// 配置子view； [self prepareScrollViewContentDataSource]; if (self.totalCount &gt; 0) &#123;// 更新子view显示的图片； [self updateSubViews]; &#125; // 重设下，更新自动轮播的状态； self.allowAutoScroll = self.allowAutoScroll; // 下载图片； for (int i = 0; i &lt; _urlArr.count; i ++) &#123; NSString *url = _urlArr[i]; __weak __typeof(self)weakSelf = self; [[SDWebImageManager sharedManager]downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:NULL completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; // 更新下当前显示的图片； __strong __typeof(weakSelf)strongSelf = weakSelf; if (strongSelf &amp;&amp; image) &#123; if (i &lt; strongSelf.urlArr.count) &#123; [strongSelf updateImage4URLIdx:i]; &#125; &#125; &#125;]; &#125;&#125;- (void)updateSubViews&#123; NSArray *idxArr = [self prepareNeedShowPageIdxArr]; NSInteger counter = 0; for (NSNumber *tempNumber in idxArr) &#123; NSInteger tempIndex = [tempNumber integerValue]; [self.showURLIdxMap setObject:@(counter) forKey:[self getMapKey:tempIndex]]; [self updateImage4URLIdx:tempIndex]; counter++; &#125; // 显示中间的； if (self.totalCount &gt; 1) &#123; [self setContentOffset:CGPointMake(self.frame.size.width, 0)]; &#125;&#125; 重新配置数据源逻辑 12345678910- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat contentOffsetX = scrollView.contentOffset.x; if(contentOffsetX &gt;= (2 * CGRectGetWidth(scrollView.frame))) &#123; [self showNextPage]; &#125;else if(contentOffsetX &lt;= 0) &#123; [self showPreviousPage]; &#125;&#125; 处理点击事件 123456789101112- (void)tapScrollView:(UITapGestureRecognizer *)sender&#123; [self resumeAutoScroll]; if (self.DidClickedBlock) &#123; self.DidClickedBlock(self.currentIdx); &#125; if (self.carouseDelegate &amp;&amp; [self.carouseDelegate respondsToSelector:@selector(eyCarouseImageView:didClickedImageView:)]) &#123; [self.carouseDelegate eyCarouseImageView:self didClickedImageView:self.currentIdx]; &#125;&#125; EZ 实现思路思路和EY是一样的，只不过这个使用 CollectionView 来实现，数据源的配置是一样的，就是减少了一个展示图片的 ImageView ！ 使用方法：123456789101112EZCarouseImageView *carouse = [[EZCarouseImageView alloc]initWithFrame:CGRectMake(0, 20, self.view.bounds.size.width, 240) animationDuration:3];[carouse resetEasyURLArr:@[@\"http://cdn.duitang.com/uploads/item/201110/09/20111009155438_ddWci.jpg\", @\"http://pic27.nipic.com/20130220/11588199_085521216128_2.jpg\", @\"http://a0.att.hudong.com/57/78/05300001208815130387782748704.jpg\", @\"http://pic29.nipic.com/20130506/3822951_101843891000_2.jpg\"]];[self.view addSubview:carouse];[carouse didClickedEZCarouseImageView:^(NSUInteger idx) &#123; NSLog(@\"--点击：--%lu\",(unsigned long)idx);&#125;]; 内部实现 配置下collectionview的Layout； 1234567891011121314151617- (instancetype)initWithFrame:(CGRect)frame&#123; UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init]; layout.minimumLineSpacing = 0; layout.minimumInteritemSpacing = 0; layout.itemSize = frame.size; layout.sectionInset = UIEdgeInsetsZero; layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; self = [super initWithFrame:frame collectionViewLayout:layout]; if (self) &#123; [self initialization]; [self registerMemoryWarningNotification]; &#125; return self;&#125; 配置定时器 注册MemoryWarningNotification；内存警告后加载当前显示的图片； 12345678910111213141516- (void)registerMemoryWarningNotification&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(needLoadImageFromDisk2Memory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];&#125;//内存警告后，从本地加载当前需要显示的图片到内存；- (void)needLoadImageFromDisk2Memory&#123; NSInteger idx = [self itemMapedURLidx:self.currentIdx]; if (idx != NSNotFound) &#123; [self fetchImageForCellWithURLidx:idx]; &#125;&#125; 重写数据源处理跟EY类似 12345678910111213141516171819202122232425262728293031323334353637- (void)setUrlArr:(NSArray *)urlArr&#123; // copy个新的，防止外部改变了，影响了轮播图 _urlArr = [urlArr copy]; if (_urlArr &amp;&amp; _urlArr.count &gt; 0) &#123; self.currentIdx = 0; // 更新映射的索引； [self updateMapedIdx:[self prepareNeedShowPageIdxArr]]; [self reloadData]; if ([self totalCount] &gt; 1) &#123; self.scrollEnabled = YES; // 显示第一张；假如有n（n &gt; 1）帧，那么［n－1，0，1］ [self scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:1 inSection:0] atScrollPosition:UICollectionViewScrollPositionNone animated:NO]; &#125;else&#123; self.scrollEnabled = NO; &#125; // 重设下，更新自动轮播的状态； self.allowAutoScroll = self.allowAutoScroll; // 下载图片； for (NSString *url in _urlArr) &#123; __weak __typeof(self)weakSelf = self; [[SDWebImageManager sharedManager]downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:NULL completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; // 更新下当前显示的图片； __strong __typeof(weakSelf)strongSelf = weakSelf; if (strongSelf &amp;&amp; image) &#123; [strongSelf reloadItemsAtIndexPaths:[strongSelf indexPathsForVisibleItems]]; &#125; &#125;]; &#125; &#125;else&#123; // 重设下，更新自动轮播的状态； self.allowAutoScroll = self.allowAutoScroll; [self reloadData]; &#125;&#125; 看下UICollectionView 的 DataSource吧 12345678910111213141516- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; EZCarouseCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:EZCarouseCellReuseIdentifier forIndexPath:indexPath]; // 通过item获取对应的数组索引； NSInteger idx = [self itemMapedURLidx:indexPath.item]; UIImage *image = nil; if (idx != NSNotFound) &#123; image = [self fetchImageForCellWithURLidx:idx]; &#125; // 找不到图片就用placeHolder if (!image &amp;&amp; self.placeHolderImage) &#123; image = self.placeHolderImage; &#125; cell.imgView.image = image; return cell;&#125; 根据图片的数量配置cell个数； 12345678910- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; if ([self totalCount] == 1)&#123; return 1;//一个不让滚动 &#125;else if([self totalCount] &gt; 1)&#123; return 3;//超过一个就用3个，然后显示中间的 &#125;else&#123; return 0; &#125;&#125; 何时更新map的索引，更新显示的图片？ 12345678910- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat contentOffsetX = scrollView.contentOffset.x; //显示了第3个item,或者第1个item时就要更新下显示的图片索引数组 if(contentOffsetX &gt;= (2 * CGRectGetWidth(scrollView.frame))) &#123; [self showNextPage];//这个会更新视图 &#125;else if(contentOffsetX &lt;= 0) &#123; [self showPreviousPage];//这个会更新视图 &#125;&#125; 点击事件 123456789101112131415//点击支持代理和block回调- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; if (self.carouseDelegate &amp;&amp; [self.carouseDelegate respondsToSelector:@selector(ezCarouseImageView:didClickedImageView:)]) &#123; [self.carouseDelegate ezCarouseImageView:self didClickedImageView:[self itemMapedURLidx:indexPath.item]]; &#125; if (self.DidClickedBlock) &#123; self.DidClickedBlock([self itemMapedURLidx:indexPath.item]); &#125;&#125;- (void)didClickedEZCarouseImageView:(void (^)(NSUInteger))block&#123; self.DidClickedBlock = block;&#125; 完核心的逻辑都在这了，欢迎在 github 上提问题！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"学习多线程需要明白的概念","slug":"2015/07/20-xue-xi-duo-xian-cheng-xu-yao-ming-bai-de-gai-nian","date":"2015-07-20T02:20:11.000Z","updated":"2018-03-27T14:45:15.683Z","comments":true,"path":"2015/07/20/2015/07/20-xue-xi-duo-xian-cheng-xu-yao-ming-bai-de-gai-nian.html","link":"","permalink":"http://debugly.cn/2015/07/20/2015/07/20-xue-xi-duo-xian-cheng-xu-yao-ming-bai-de-gai-nian.html","excerpt":"","text":"学习多线程开发前，我们需要知道很多的概念，这也是我曾经比较困惑的，至少别人问我的时候，我说不清楚，下面就针对这些概念总结下： 进程 操作系统早已经是多任务的了，早期她还有个名字叫多道程序；正是这个伟大的发明，我们才能享受一边听歌，一边写文档，一边聊天的乐趣；其实我们运行的程序都是来回切换的，只不过速度过快，我们无法感知而已，如何切换是由操作体统调度的，有相应的调度算法。我们只需要明白应用程序开启后，操作系统会为之开辟一个进程，她拥有地址空间，数据，以及各种资源等，当进程终止时，这些创建的资源被销毁，系统的资源被释放或者关闭。进程（程序）每隔一段时间就会暂停，保存下他的工作环境，然后开始运行另外一个进程，恢复他的现场，执行这个进程的任务，就这样循环的暂停，恢复，暂停，恢复…很多系统使用的是时间片轮转调度，也就是说每个进程（程序）运行的时间是平均分配的； 作业调度算法补充： 先进先出（FIFO）,最短作业优先法（SJF）,最高响应比优先法（HRN）,定时轮转法,优先数法,事件驱动法,各种不同类型作业搭配调度算法等. 线程 我们已经知道了进程是被操作系统调度的单位，是一个应用的象征，而线程时操作系统能够调度的最小单位，他被包含在进程之中，是进程的实际运作单位；一个进程中可以并发多个线程，每条线程并行执行不同的任务，Unix System中称为轻量级进程；也就是说线程是属于进程的，同一个进程中的线程共享进程中的全部系统资源，如虚拟地址空间，IO，信号等；但同一和进程中的多个线程有各自的调用栈，自己的寄存器环境等； 多线程:程序启动后，系统为程序创建了一个进程，每一个进程都会有一个主执行线程，且被默认创建，为了充分利用CPU，我们也会创建线程，做一些想做的事情，这样就会出现一个进程包含多个线程的情况； 在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责IO处理、人机交互而常备阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。 并发 对于单核CPU来说的，操作系统会按照一定的调度算法切换线程，让各个线程都能执行的方式叫做并发。描述的是任务之间的关系。 并行 对于多核的CPU来说，可以同时让两个以上的线程同时运行，这种执行方式叫做并行。 同步、异步 他们是描述任务何时返回（完成）和派发任务所在线程之间的关系问题的； 比如在主线程使用xx()函数派发了一个新任务，如果只有当xx()函数执行完才能返回到主线程，那么这个函数xx就是同步的，特点是阻塞线程； 如果，在主线程派发了之后，立马返回了，无需等待任务的完成，那么这个函数就是异步的； 临界区 多线程环境下，可能会有资源被多个线程访问的情况，这样一来二去，这个资源就变得不可信了，变了质了，不再是准确的了；这当然也不是我们想要的；后续博客会解决这个不可信问题，也就是多线程同步问题！(ps :这里说的同步跟上面提到的同步，异步不是一个概念哦！) 参考的文档： https://zh.wikipedia.org/wiki/多任务处理 https://zh.wikipedia.org/wiki/线程 https://books.google.co.jp/books?id=qjNUgoRkXLMC&amp;pg=PA57&amp;lpg=PA57&amp;dq=多任务+操作系统+出现&amp;source=bl&amp;ots=AKZJIbR047&amp;sig=BkOHhV_ZEAZx2p0LjyCS3FcJWfc&amp;hl=zh-CN&amp;sa=X&amp;ved=0CEoQ6AEwCWoVChMI79yjtt3oxgIVgxmUCh3vcgnL#v=onepage&amp;q=多任务%20操作系统%20出现&amp;f=false https://www.freebsd.org/doc/zh_CN.UTF-8/books/handbook/basics-processes.html https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md http://www.zhihu.com/question/19901763 http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://debugly.cn/tags/Other/"}]},{"title":"解决 NSTimer 内存泄漏问题","slug":"2015/07/14-jie-jue-nstimeryin-qi-de-nei-cun-xie-lou","date":"2015-07-14T02:38:52.000Z","updated":"2018-03-27T14:45:15.683Z","comments":true,"path":"2015/07/14/2015/07/14-jie-jue-nstimeryin-qi-de-nei-cun-xie-lou.html","link":"","permalink":"http://debugly.cn/2015/07/14/2015/07/14-jie-jue-nstimeryin-qi-de-nei-cun-xie-lou.html","excerpt":"","text":"NSTimer 是 iOS 很常用的一个类，可以很方便的做延迟任务，也可以做周期性的轮询。不过我在写轮播图的时候却发现 Timer造成了内存泄漏！ 背景我在 ViewController 里使用了 Timer，结果发现 pop 掉该控制器后，他的 dealloc 却没有调用！这是个内存泄露的问题，比较严重，要尽快解决！ 分析原因 在使用 Timer 的时候，我们需要给他指定一个 Target，而 Timer 的内部会持有该 Target，原因可想而知，当 Timer 到时间之后就要触发目标方法，如果不持有 Target 的话，就可能会导致 Target 已经释放，无法达到调用目标方法的效果；在没有ARC的年代，如果用assign势必会造成野指针崩溃的，因此要持有 Target； 要知道 Timer 的运行依赖于 Runloop 的驱动，即 fire 之前需要加入到 Runloop 中，但这样一来 Timer 就被 Runloop 持有了，除非调用 invalidate，才会从 Runloop 中移除； 实际使用的时候，Target 就是我的 ViewController，我是在 ViewController 的 dealloc 里将 Timer invalidate 掉的； 如上所述，Target 会被 Timer 持有，Timer 会被 Runloop 持有，结果就导致了 ViewController 一直被持有着，所以在 ViewController 的 dealloc 里 invalidate 掉 Timer 是没作用的，压根不会走这个逻辑，所以当导航控制器 pop 之后，页面消失了，但是内存却没释放，这就导致了内存泄漏！ 解决问题如果能在 pop ViewController 之前将 Timer invalidate 掉，就可以解除 Timer 对 ViewController 的持有，让 ViewController 正常释放； 简单的做法是在控制器的 viewwilldisappear 中 invalidate，不过一般情况下就要对应的在 viewwillappear 中重新创建 Timer，这么做一般情况都是可以的，但如果 Target 不是 ViewController 就需要多写点代码了；更糟糕的是，我遇到过调用了 viewwillappear 却没调用 viewwilldisappear 就要dealloc 的情况，这时情况就很糟糕了，看来需要一个优雅的解决办法才是完全之策。 要解决这个问题，就要从打破持有上解决，Runloop 持有 Timer 估计是没办法做文章了，那能不能想办法把 Target 转移下呢? 是的，可以将自身作为 Target，然后通过 block 回调出去？外部调用使用 weak-storng dance ，不让 block持有 target；似乎可行哦，立马行动： 1234+ (NSTimer *)scheduledWithTimeInterval:(NSTimeInterval)ti repeats:(BOOL)yesOrNo block:(void (^)())block&#123; return [NSTimer scheduledTimerWithTimeInterval:ti target:self selector:@selector(ql_blockInvoke:) userInfo:[block copy] repeats:yesOrNo];&#125; 把传入的block当作userinfo穿过去，userinfo是个id类型的，故而可以传递一个block过去，block是在栈上分配的，所以必须copy到堆上，这样日后回调的时候才能找到它； 1234567+ (void)ql_blockInvoke:(NSTimer *)sender&#123; void (^block)() = sender.userInfo; if (block) &#123; block(); &#125;&#125; 通过类别，我们给timer加上了这些方法； 使用12345__weak __typeof(self)weakSelf = self;NSTimer *timer = [NSTimer scheduledWithTimeInterval:animationDuration repeats:YES block:^&#123; __strong __typeof(weakSelf)strongSelf = weakSelf; [strongSelf animationTimerDidFired];&#125;]; 使用scheduledTimerWithTimeInterval方法创建的timer会自动加入到当前runloop中，并在interval之后fire；如果不想立马开始可以这样做： 1[timer setFireDate:[NSDate distantFuture]]; 记得在target的dealloc里把这个timer invalidate即可； 增加了几个方便的方法123- (void)pauseTimer;- (void)resumeTimer;- (void)resumeTimerAfterTimeInterval:(NSTimeInterval)interval; 完 开源地址：https://github.com/debugly/QLCodes","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://debugly.cn/tags/iOS/"}]},{"title":"Hello My Blog","slug":"2015/07/07-bo-ke-an-jia-la","date":"2015-07-07T05:36:28.000Z","updated":"2018-03-27T14:45:15.683Z","comments":true,"path":"2015/07/07/2015/07/07-bo-ke-an-jia-la.html","link":"","permalink":"http://debugly.cn/2015/07/07/2015/07/07-bo-ke-an-jia-la.html","excerpt":"","text":"出于对前端的兴趣和 markdown 的热衷，于是今天摸索着搭建了一个使用 markdown 写文章，经过 jekyll 解析生成静态站点，发布到 github 的博客，折腾过程中还学习了些前端的知识！ 在此之前曾在 新浪博客，CSDN 上写过几篇文章，可是未能坚持下去。 写博客的过程也是自我认识和能力提升的一个过程，因为要把一个不熟悉的东西说清楚真的很困难,有困难才会有进步，不是嘛？ 版本记录 17 年 12 月换成 hexo，主题则采用了 hexo-theme-yaris. 17 年 7 月自己编写 jekyll 主题 Yaris. 16 年 12 月开始使用独立域名 debuly.cn. 15 年 7 月使用 octopress 搭建了我的博客，从此之后再无安宁之日，没事了就来折腾我的博客.","categories":[],"tags":[{"name":"Script","slug":"Script","permalink":"http://debugly.cn/tags/Script/"}]}]}